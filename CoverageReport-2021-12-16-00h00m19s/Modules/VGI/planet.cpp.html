<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>planet.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
#include &lt;algorithm&gt;
#define _USE_MATH_DEFINES
#include &lt;cmath&gt;
#include &lt;ctime&gt;
#include &lt;date.h&gt;

#include "planet.h"
#include "../util/util.h"
#include "../spice/spice.h"

#include &lt;GLFW/glfw3.h&gt;
#include &lt;glm/glm.hpp&gt;
#include &lt;glm/gtc/matrix_transform.hpp&gt;
#include &lt;glm/gtc/type_ptr.hpp&gt;

const float SCALE = 0.00000025;

<span style = "background-color:#fdd">Planet::Planet(glm::vec3 coordinates, std::string texturePath) : Sphere(0.5f, 36, 18) {
    m_Coordinates = coordinates;
    m_Texture = util::LoadTexture(texturePath);
}</span>

<span style = "background-color:#fdd">Planet::Planet(float r, int sectors, int stacks, glm::vec3 coordinates, std::string texturePath) : Sphere(r, sectors, stacks) {
    m_Coordinates = coordinates;
    m_Texture = util::LoadTexture(texturePath);
}</span>

<span style = "background-color:#dfd">static float ComputeSphereRadius(YAML::Node values) {
    float radius = values["diameter"].as&lt;float&gt;() / 2;
    return radius / 15000;
}</span>

<span style = "background-color:#dfd">static float ComputeAcademicSphereRadius(YAML::Node values) {
    float earth_radius = 6378;
    float radius = values["academic"].as&lt;float&gt;() * earth_radius;
    return radius / 15000;
}</span>

<span style = "background-color:#dfd">Planet::Planet(YAML::Node values, std::string name, bool isAcademic) : Sphere(isAcademic ? ComputeAcademicSphereRadius(values) : ComputeSphereRadius(values), 36, 18) {
    m_Texture = util::LoadTexture(values["texture"].as&lt;std::string&gt;());
    m_Name = name;</span>

<span style = "background-color:#dfd">    std::vector&lt;float&gt; coordinates = values["coordinates"].as&lt;std::vector&lt;float&gt;&gt;();
    m_Coordinates = glm::vec3(coordinates[0], coordinates[1], coordinates[2]);
    m_K = values["k"].as&lt;int&gt;();
    float UA = 149597870.7;
    m_OrbitRadius = (UA * (0.4 + 0.3 * m_K)) / 10000000;
    m_OrbitalPeriod = values["period"].as&lt;int&gt;();</span>

<span style = "background-color:#dfd">    glGenVertexArrays(1, &amp;m_OrbitsVAO);
    glGenBuffers(1, &amp;m_OrbitsVBO);</span>

<span style = "background-color:#dfd">    if (m_Name != "sun") {
        GenerateFullOrbit();</span>
    }

<span style = "background-color:#dfd">    if (!values["satelites"].IsNull()) {
        for (auto satelite = values["satelites"].begin(); satelite != values["satelites"].end(); satelite++) {
            m_satelites.push_back(new Satelite(satelite-&gt;second, satelite-&gt;first.as&lt;std::string&gt;(), true));
        }</span>
    }
<span style = "background-color:#dfd">}</span>

<span style = "background-color:#dfd">void Planet::UpdateOrbitVAO() {
    glBindVertexArray(m_OrbitsVAO);
    glBindBuffer(GL_ARRAY_BUFFER, m_OrbitsVBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(float) * m_OrbitVertices.size(), m_OrbitVertices.data(), GL_STATIC_DRAW);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (GLvoid*)0);
    glEnableVertexAttribArray(0);
    glBindBuffer(GL_ARRAY_BUFFER, 0);
    glBindVertexArray(0);
}</span>

<span style = "background-color:#dfd">void Planet::AddNextOrbitVertex(glm::vec3 coordinates) {
    if (m_OrbitVertices.size() &lt; 2001) {
        m_OrbitVertices.push_back(coordinates[0]);
        m_OrbitVertices.push_back(coordinates[1]);
        m_OrbitVertices.push_back(coordinates[2]);
    } else {
        std::rotate(m_OrbitVertices.begin(), m_OrbitVertices.begin() + 3, m_OrbitVertices.end());
        m_OrbitVertices[1998] = coordinates[0];
        m_OrbitVertices[1999] = coordinates[1];
        m_OrbitVertices[2000] = coordinates[2];</span>
    }
<span style = "background-color:#dfd">    UpdateOrbitVAO();
}</span>

<span style = "background-color:#dfd">void Planet::ClearOrbitBuffer() {
    m_OrbitVertices = std::vector&lt;float&gt;();
}</span>

<span style = "background-color:#dfd">void Planet::Draw() {
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, m_Texture);
    Sphere::Draw();
}</span>

<span style = "background-color:#dfd">void Planet::DrawOrbit() {
    glBindVertexArray(m_OrbitsVAO);
    glLineWidth(1.0f);
    glDrawArrays(GL_LINE_STRIP, 0, (GLsizei)m_OrbitVertices.size() / 3);
}</span>

<span style = "background-color:#dfd">void Planet::GenerateFullOrbit() {</span>
    using namespace date;

<span style = "background-color:#dfd">    int step = std::round(m_OrbitalPeriod / 365.0);
    if (step == 0) step = 1;</span>

<span style = "background-color:#dfd">    m_OrbitVertices = std::vector&lt;float&gt;(373 * 3);</span>

<span style = "background-color:#dfd">    year_month_day date = sys_days{ 1970_y / January / 01 };</span>

<span style = "background-color:#dfd">    for (int i = 0; i &lt; 373 * 3; i += 3) {
        date = sys_days{ date } + days{ step };</span>

<span style = "background-color:#dfd">        std::stringstream date_str;
        date_str &lt;&lt; date;</span>

<span style = "background-color:#dfd">        double ephemerisTime = spice::GetEphemerisTime(date_str.str());
        glm::vec3 coordinates = spice::GetCoordinate(ephemerisTime, m_Name + " barycenter");
        coordinates *= SCALE;</span>

<span style = "background-color:#dfd">        m_OrbitVertices[i] = coordinates[0];
        m_OrbitVertices[i + 1] = coordinates[1];
        m_OrbitVertices[i + 2] = coordinates[2];
    }</span>

<span style = "background-color:#dfd">    UpdateOrbitVAO();
}</span>

<span style = "background-color:#dfd">void RenderPlanets(std::vector&lt;Planet*&gt; planets, State&amp; state, Camera&amp; camera, Shader&amp; shader) {
    double ephemerisTime = spice::GetEphemerisTime(state.GetDate());
    for (Planet* planet : planets) {
        glm::vec3 position = glm::vec3(0.0f, 0.0f, 0.0f);
        if (planet-&gt;GetName() != "sun") {
            position = spice::GetCoordinate(ephemerisTime, planet-&gt;GetName() + " barycenter");
            position *= SCALE; // scale down the planet's position</span>
        }

<span style = "background-color:#dfd">        if (planet-&gt;GetName() == state.GetSelectedPlanet() &amp;&amp; state.IsFocusedOnPlanet()) {
            glm::vec3 pos = glm::vec3(position[0] * 1.5, position[1] + planet-&gt;GetRadius() + 5, position[2] * 1.5);
            camera.SetCameraPos(pos);
            camera.SetCameraFront(-pos); // look at the origin</span>
        }

<span style = "background-color:#dfd">        glm::mat4 model = glm::mat4(1.0f);
        model = glm::translate(model, position);
        model = glm::rotate(model, (float)glfwGetTime() * glm::radians(50.0f), glm::vec3(0.0f, 1.0f, 0.0f));</span>

<span style = "background-color:#dfd">        shader.SetMat4("u_Model", model);</span>

<span style = "background-color:#dfd">        planet-&gt;Draw();</span>

<span style = "background-color:#dfd">        if (!state.FullOrbitModeEnabled()) {
            planet-&gt;AddNextOrbitVertex(position);</span>
        }
<span style = "background-color:#dfd">        shader.SetMat4("u_Model", glm::mat4(1.0f));
        planet-&gt;DrawOrbit();</span>

        // Render Rings
<span style = "background-color:#dfd">        if (planet-&gt;GetName() == "saturn") {
            glLineWidth(2.0f);
            GLfloat rr = 0.01f;
            for (int i = 0; i &lt; 25; i++) {
                glm::mat4 ringModel(1);
                ringModel = glm::translate(ringModel, position);
                ringModel = glm::rotate(ringModel, glm::radians(10.0f), glm::vec3(0.0f, 0.0f, 1.0f));
                ringModel = glm::scale(ringModel, glm::vec3(rr, rr, rr));
                shader.SetMat4("u_Model", ringModel);
                glDrawArrays(GL_LINE_LOOP, 0, (GLsizei)planet-&gt;GetOrbitVertices().size() / 3);
                if (i == 15)
                    rr += 0.0003f;</span>
                else
<span style = "background-color:#dfd">                    rr += 0.0002f;
            }</span>
        }

        //-------------------------------------------------------------------------------------------------------------------------
<span style = "background-color:#dfd">        if (planet-&gt;GetName() == "earth") {
            for (Satelite* satellite : planet-&gt;GetSatelites()) {</span>
                double satelite_lt;

<span style = "background-color:#dfd">                position = spice::GetCoordinate(ephemerisTime, satellite-&gt;GetName());
                position *= SCALE;
                position *= 1.05; // TODO: find out the value
                glm::mat4 model = glm::mat4(1.0f);
                model = glm::translate(model, position);
                model = glm::rotate(model, (float)glfwGetTime() * glm::radians(50.0f), glm::vec3(0.0f, 1.0f, 0.0f));
                shader.SetMat4("u_Model", model);</span>

<span style = "background-color:#dfd">                satellite-&gt;Draw();
            }</span>
        }
        //-------------------------------------------------------------------------------------------------------------------------
<span style = "background-color:#dfd">    }
}</span></pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>