<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>iterator.h</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
#ifndef VALUE_DETAIL_ITERATOR_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define VALUE_DETAIL_ITERATOR_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) &amp;&amp; (__GNUC__ == 3 &amp;&amp; __GNUC_MINOR__ &gt;= 4) || \
     (__GNUC__ &gt;= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include "yaml-cpp/dll.h"
#include "yaml-cpp/node/detail/node_iterator.h"
#include "yaml-cpp/node/node.h"
#include "yaml-cpp/node/ptr.h"
#include &lt;cstddef&gt;
#include &lt;iterator&gt;


namespace YAML {
namespace detail {
struct iterator_value;

template &lt;typename V&gt;
class iterator_base {

 private:
  template &lt;typename&gt;
  friend class iterator_base;
  struct enabler {};
  using base_type = node_iterator;

  struct proxy {
<span style = "background-color:#dfd">    explicit proxy(const V&amp; x) : m_ref(x) {}
    V* operator-&gt;() { return std::addressof(m_ref); }</span>
    operator V*() { return std::addressof(m_ref); }

    V m_ref;
  };

 public:
  using iterator_category = std::forward_iterator_tag;
  using value_type = V;
  using difference_type = std::ptrdiff_t;
  using pointer = V*;
  using reference = V;

 public:
<span style = "background-color:#fdd">  iterator_base() : m_iterator(), m_pMemory() {}</span>
  explicit iterator_base(base_type rhs, shared_memory_holder pMemory)
<span style = "background-color:#dfd">      : m_iterator(rhs), m_pMemory(pMemory) {}</span>

  template &lt;class W&gt;
  iterator_base(const iterator_base&lt;W&gt;&amp; rhs,
                typename std::enable_if&lt;std::is_convertible&lt;W*, V*&gt;::value,
                                        enabler&gt;::type = enabler())
      : m_iterator(rhs.m_iterator), m_pMemory(rhs.m_pMemory) {}

<span style = "background-color:#dfd">  iterator_base&lt;V&gt;&amp; operator++() {
    ++m_iterator;
    return *this;
  }</span>

<span style = "background-color:#dfd">  iterator_base&lt;V&gt; operator++(int) {
    iterator_base&lt;V&gt; iterator_pre(*this);
    ++(*this);
    return iterator_pre;
  }</span>

  template &lt;typename W&gt;
  bool operator==(const iterator_base&lt;W&gt;&amp; rhs) const {
    return m_iterator == rhs.m_iterator;
  }

  template &lt;typename W&gt;
<span style = "background-color:#dfd">  bool operator!=(const iterator_base&lt;W&gt;&amp; rhs) const {
    return m_iterator != rhs.m_iterator;
  }</span>

<span style = "background-color:#dfd">  value_type operator*() const {
    const typename base_type::value_type&amp; v = *m_iterator;
    if (v.pNode)
      return value_type(Node(*v, m_pMemory));
    if (v.first &amp;&amp; v.second)
      return value_type(Node(*v.first, m_pMemory), Node(*v.second, m_pMemory));</span>
<span style = "background-color:#fdd">    return value_type();</span>
<span style = "background-color:#dfd">  }</span>

<span style = "background-color:#dfd">  proxy operator-&gt;() const { return proxy(**this); }</span>

 private:
  base_type m_iterator;
  shared_memory_holder m_pMemory;
};
}  // namespace detail
}  // namespace YAML

#endif  // VALUE_DETAIL_ITERATOR_H_62B23520_7C8E_11DE_8A39_0800200C9A66</pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>