<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>egl_context.c</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
//========================================================================
// GLFW 3.4 EGL - www.glfw.org
//------------------------------------------------------------------------
// Copyright (c) 2002-2006 Marcus Geelnard
// Copyright (c) 2006-2019 Camilla LÃ¶wy &lt;elmindreda@glfw.org&gt;
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//    claim that you wrote the original software. If you use this software
//    in a product, an acknowledgment in the product documentation would
//    be appreciated but is not required.
//
// 2. Altered source versions must be plainly marked as such, and must not
//    be misrepresented as being the original software.
//
// 3. This notice may not be removed or altered from any source
//    distribution.
//
//========================================================================
// Please use C89 style variable declarations in this file because VS 2010
//========================================================================

#include "internal.h"

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;


// Return a description of the specified EGL error
//
static const char* getEGLErrorString(EGLint error)
<span style = "background-color:#fdd">{
    switch (error)</span>
    {
        case EGL_SUCCESS:
<span style = "background-color:#fdd">            return "Success";</span>
        case EGL_NOT_INITIALIZED:
<span style = "background-color:#fdd">            return "EGL is not or could not be initialized";</span>
        case EGL_BAD_ACCESS:
<span style = "background-color:#fdd">            return "EGL cannot access a requested resource";</span>
        case EGL_BAD_ALLOC:
<span style = "background-color:#fdd">            return "EGL failed to allocate resources for the requested operation";</span>
        case EGL_BAD_ATTRIBUTE:
<span style = "background-color:#fdd">            return "An unrecognized attribute or attribute value was passed in the attribute list";</span>
        case EGL_BAD_CONTEXT:
<span style = "background-color:#fdd">            return "An EGLContext argument does not name a valid EGL rendering context";</span>
        case EGL_BAD_CONFIG:
<span style = "background-color:#fdd">            return "An EGLConfig argument does not name a valid EGL frame buffer configuration";</span>
        case EGL_BAD_CURRENT_SURFACE:
<span style = "background-color:#fdd">            return "The current surface of the calling thread is a window, pixel buffer or pixmap that is no longer valid";</span>
        case EGL_BAD_DISPLAY:
<span style = "background-color:#fdd">            return "An EGLDisplay argument does not name a valid EGL display connection";</span>
        case EGL_BAD_SURFACE:
<span style = "background-color:#fdd">            return "An EGLSurface argument does not name a valid surface configured for GL rendering";</span>
        case EGL_BAD_MATCH:
<span style = "background-color:#fdd">            return "Arguments are inconsistent";</span>
        case EGL_BAD_PARAMETER:
<span style = "background-color:#fdd">            return "One or more argument values are invalid";</span>
        case EGL_BAD_NATIVE_PIXMAP:
<span style = "background-color:#fdd">            return "A NativePixmapType argument does not refer to a valid native pixmap";</span>
        case EGL_BAD_NATIVE_WINDOW:
<span style = "background-color:#fdd">            return "A NativeWindowType argument does not refer to a valid native window";</span>
        case EGL_CONTEXT_LOST:
<span style = "background-color:#fdd">            return "The application must destroy all contexts and reinitialise";</span>
        default:
<span style = "background-color:#fdd">            return "ERROR: UNKNOWN EGL ERROR";</span>
    }
<span style = "background-color:#fdd">}</span>

// Returns the specified attribute of the specified EGLConfig
//
static int getEGLConfigAttrib(EGLConfig config, int attrib)
<span style = "background-color:#fdd">{</span>
    int value;
<span style = "background-color:#fdd">    eglGetConfigAttrib(_glfw.egl.display, config, attrib, &amp;value);
    return value;
}</span>

// Return the EGLConfig most closely matching the specified hints
//
static GLFWbool chooseEGLConfig(const _GLFWctxconfig* ctxconfig,
                                const _GLFWfbconfig* desired,
                                EGLConfig* result)
<span style = "background-color:#fdd">{</span>
    EGLConfig* nativeConfigs;
    _GLFWfbconfig* usableConfigs;
    const _GLFWfbconfig* closest;
    int i, nativeCount, usableCount;

<span style = "background-color:#fdd">    eglGetConfigs(_glfw.egl.display, NULL, 0, &amp;nativeCount);
    if (!nativeCount)</span>
    {
<span style = "background-color:#fdd">        _glfwInputError(GLFW_API_UNAVAILABLE, "EGL: No EGLConfigs returned");
        return GLFW_FALSE;</span>
    }

<span style = "background-color:#fdd">    nativeConfigs = _glfw_calloc(nativeCount, sizeof(EGLConfig));
    eglGetConfigs(_glfw.egl.display, nativeConfigs, nativeCount, &amp;nativeCount);</span>

<span style = "background-color:#fdd">    usableConfigs = _glfw_calloc(nativeCount, sizeof(_GLFWfbconfig));
    usableCount = 0;</span>

<span style = "background-color:#fdd">    for (i = 0;  i &lt; nativeCount;  i++)</span>
    {
<span style = "background-color:#fdd">        const EGLConfig n = nativeConfigs[i];
        _GLFWfbconfig* u = usableConfigs + usableCount;</span>

        // Only consider RGB(A) EGLConfigs
<span style = "background-color:#fdd">        if (getEGLConfigAttrib(n, EGL_COLOR_BUFFER_TYPE) != EGL_RGB_BUFFER)
            continue;</span>

        // Only consider window EGLConfigs
<span style = "background-color:#fdd">        if (!(getEGLConfigAttrib(n, EGL_SURFACE_TYPE) &amp; EGL_WINDOW_BIT))
            continue;</span>

#if defined(_GLFW_X11)
        {
            XVisualInfo vi = {0};

            // Only consider EGLConfigs with associated Visuals
            vi.visualid = getEGLConfigAttrib(n, EGL_NATIVE_VISUAL_ID);
            if (!vi.visualid)
                continue;

            if (desired-&gt;transparent)
            {
                int count;
                XVisualInfo* vis =
                    XGetVisualInfo(_glfw.x11.display, VisualIDMask, &amp;vi, &amp;count);
                if (vis)
                {
                    u-&gt;transparent = _glfwIsVisualTransparentX11(vis[0].visual);
                    XFree(vis);
                }
            }
        }
#endif // _GLFW_X11

<span style = "background-color:#fdd">        if (ctxconfig-&gt;client == GLFW_OPENGL_ES_API)</span>
        {
<span style = "background-color:#fdd">            if (ctxconfig-&gt;major == 1)</span>
            {
<span style = "background-color:#fdd">                if (!(getEGLConfigAttrib(n, EGL_RENDERABLE_TYPE) &amp; EGL_OPENGL_ES_BIT))
                    continue;
            }</span>
            else
            {
<span style = "background-color:#fdd">                if (!(getEGLConfigAttrib(n, EGL_RENDERABLE_TYPE) &amp; EGL_OPENGL_ES2_BIT))
                    continue;</span>
            }
<span style = "background-color:#fdd">        }
        else if (ctxconfig-&gt;client == GLFW_OPENGL_API)</span>
        {
<span style = "background-color:#fdd">            if (!(getEGLConfigAttrib(n, EGL_RENDERABLE_TYPE) &amp; EGL_OPENGL_BIT))
                continue;</span>
        }

<span style = "background-color:#fdd">        u-&gt;redBits = getEGLConfigAttrib(n, EGL_RED_SIZE);
        u-&gt;greenBits = getEGLConfigAttrib(n, EGL_GREEN_SIZE);
        u-&gt;blueBits = getEGLConfigAttrib(n, EGL_BLUE_SIZE);</span>

<span style = "background-color:#fdd">        u-&gt;alphaBits = getEGLConfigAttrib(n, EGL_ALPHA_SIZE);
        u-&gt;depthBits = getEGLConfigAttrib(n, EGL_DEPTH_SIZE);
        u-&gt;stencilBits = getEGLConfigAttrib(n, EGL_STENCIL_SIZE);</span>

<span style = "background-color:#fdd">        u-&gt;samples = getEGLConfigAttrib(n, EGL_SAMPLES);
        u-&gt;doublebuffer = desired-&gt;doublebuffer;</span>

<span style = "background-color:#fdd">        u-&gt;handle = (uintptr_t) n;
        usableCount++;
    }</span>

<span style = "background-color:#fdd">    closest = _glfwChooseFBConfig(desired, usableConfigs, usableCount);
    if (closest)
        *result = (EGLConfig) closest-&gt;handle;</span>

<span style = "background-color:#fdd">    _glfw_free(nativeConfigs);
    _glfw_free(usableConfigs);</span>

<span style = "background-color:#fdd">    return closest != NULL;
}</span>

static void makeContextCurrentEGL(_GLFWwindow* window)
<span style = "background-color:#fdd">{
    if (window)</span>
    {
<span style = "background-color:#fdd">        if (!eglMakeCurrent(_glfw.egl.display,</span>
                            window-&gt;context.egl.surface,
                            window-&gt;context.egl.surface,
                            window-&gt;context.egl.handle))
        {
<span style = "background-color:#fdd">            _glfwInputError(GLFW_PLATFORM_ERROR,</span>
                            "EGL: Failed to make context current: %s",
                            getEGLErrorString(eglGetError()));
<span style = "background-color:#fdd">            return;</span>
        }
<span style = "background-color:#fdd">    }</span>
    else
    {
<span style = "background-color:#fdd">        if (!eglMakeCurrent(_glfw.egl.display,</span>
                            EGL_NO_SURFACE,
                            EGL_NO_SURFACE,
                            EGL_NO_CONTEXT))
        {
<span style = "background-color:#fdd">            _glfwInputError(GLFW_PLATFORM_ERROR,</span>
                            "EGL: Failed to clear current context: %s",
                            getEGLErrorString(eglGetError()));
<span style = "background-color:#fdd">            return;</span>
        }
    }

<span style = "background-color:#fdd">    _glfwPlatformSetTls(&amp;_glfw.contextSlot, window);
}</span>

static void swapBuffersEGL(_GLFWwindow* window)
<span style = "background-color:#fdd">{
    if (window != _glfwPlatformGetTls(&amp;_glfw.contextSlot))</span>
    {
<span style = "background-color:#fdd">        _glfwInputError(GLFW_PLATFORM_ERROR,</span>
                        "EGL: The context must be current on the calling thread when swapping buffers");
<span style = "background-color:#fdd">        return;</span>
    }

<span style = "background-color:#fdd">    eglSwapBuffers(_glfw.egl.display, window-&gt;context.egl.surface);
}</span>

static void swapIntervalEGL(int interval)
<span style = "background-color:#fdd">{
    eglSwapInterval(_glfw.egl.display, interval);
}</span>

static int extensionSupportedEGL(const char* extension)
<span style = "background-color:#fdd">{
    const char* extensions = eglQueryString(_glfw.egl.display, EGL_EXTENSIONS);
    if (extensions)</span>
    {
<span style = "background-color:#fdd">        if (_glfwStringInExtensionString(extension, extensions))
            return GLFW_TRUE;</span>
    }

<span style = "background-color:#fdd">    return GLFW_FALSE;
}</span>

static GLFWglproc getProcAddressEGL(const char* procname)
<span style = "background-color:#fdd">{
    _GLFWwindow* window = _glfwPlatformGetTls(&amp;_glfw.contextSlot);</span>

<span style = "background-color:#fdd">    if (window-&gt;context.egl.client)</span>
    {
<span style = "background-color:#fdd">        GLFWglproc proc = (GLFWglproc) _glfw_dlsym(window-&gt;context.egl.client,</span>
                                                   procname);
<span style = "background-color:#fdd">        if (proc)
            return proc;</span>
    }

<span style = "background-color:#fdd">    return eglGetProcAddress(procname);
}</span>

static void destroyContextEGL(_GLFWwindow* window)
<span style = "background-color:#fdd">{</span>
#if defined(_GLFW_X11)
    // NOTE: Do not unload libGL.so.1 while the X11 display is still open,
    //       as it will make XCloseDisplay segfault
    if (window-&gt;context.client != GLFW_OPENGL_API)
#endif // _GLFW_X11
    {
<span style = "background-color:#fdd">        if (window-&gt;context.egl.client)</span>
        {
<span style = "background-color:#fdd">            _glfw_dlclose(window-&gt;context.egl.client);
            window-&gt;context.egl.client = NULL;</span>
        }
    }

<span style = "background-color:#fdd">    if (window-&gt;context.egl.surface)</span>
    {
<span style = "background-color:#fdd">        eglDestroySurface(_glfw.egl.display, window-&gt;context.egl.surface);
        window-&gt;context.egl.surface = EGL_NO_SURFACE;</span>
    }

<span style = "background-color:#fdd">    if (window-&gt;context.egl.handle)</span>
    {
<span style = "background-color:#fdd">        eglDestroyContext(_glfw.egl.display, window-&gt;context.egl.handle);
        window-&gt;context.egl.handle = EGL_NO_CONTEXT;</span>
    }
<span style = "background-color:#fdd">}</span>


//////////////////////////////////////////////////////////////////////////
//////                       GLFW internal API                      //////
//////////////////////////////////////////////////////////////////////////

// Initialize EGL
//
GLFWbool _glfwInitEGL(void)
<span style = "background-color:#fdd">{</span>
    int i;
<span style = "background-color:#fdd">    EGLint* attribs = NULL;</span>
    const char* extensions;
<span style = "background-color:#fdd">    const char* sonames[] =</span>
    {
#if defined(_GLFW_EGL_LIBRARY)
        _GLFW_EGL_LIBRARY,
#elif defined(_GLFW_WIN32)
        "libEGL.dll",
        "EGL.dll",
#elif defined(_GLFW_COCOA)
        "libEGL.dylib",
#elif defined(__CYGWIN__)
        "libEGL-1.so",
#else
        "libEGL.so.1",
#endif
        NULL
    };

<span style = "background-color:#fdd">    if (_glfw.egl.handle)
        return GLFW_TRUE;</span>

<span style = "background-color:#fdd">    for (i = 0;  sonames[i];  i++)</span>
    {
<span style = "background-color:#fdd">        _glfw.egl.handle = _glfw_dlopen(sonames[i]);
        if (_glfw.egl.handle)
            break;
    }</span>

<span style = "background-color:#fdd">    if (!_glfw.egl.handle)</span>
    {
<span style = "background-color:#fdd">        _glfwInputError(GLFW_API_UNAVAILABLE, "EGL: Library not found");
        return GLFW_FALSE;</span>
    }

<span style = "background-color:#fdd">    _glfw.egl.prefix = (strncmp(sonames[i], "lib", 3) == 0);</span>

<span style = "background-color:#fdd">    _glfw.egl.GetConfigAttrib = (PFN_eglGetConfigAttrib)</span>
        _glfw_dlsym(_glfw.egl.handle, "eglGetConfigAttrib");
<span style = "background-color:#fdd">    _glfw.egl.GetConfigs = (PFN_eglGetConfigs)</span>
        _glfw_dlsym(_glfw.egl.handle, "eglGetConfigs");
<span style = "background-color:#fdd">    _glfw.egl.GetDisplay = (PFN_eglGetDisplay)</span>
        _glfw_dlsym(_glfw.egl.handle, "eglGetDisplay");
<span style = "background-color:#fdd">    _glfw.egl.GetError = (PFN_eglGetError)</span>
        _glfw_dlsym(_glfw.egl.handle, "eglGetError");
<span style = "background-color:#fdd">    _glfw.egl.Initialize = (PFN_eglInitialize)</span>
        _glfw_dlsym(_glfw.egl.handle, "eglInitialize");
<span style = "background-color:#fdd">    _glfw.egl.Terminate = (PFN_eglTerminate)</span>
        _glfw_dlsym(_glfw.egl.handle, "eglTerminate");
<span style = "background-color:#fdd">    _glfw.egl.BindAPI = (PFN_eglBindAPI)</span>
        _glfw_dlsym(_glfw.egl.handle, "eglBindAPI");
<span style = "background-color:#fdd">    _glfw.egl.CreateContext = (PFN_eglCreateContext)</span>
        _glfw_dlsym(_glfw.egl.handle, "eglCreateContext");
<span style = "background-color:#fdd">    _glfw.egl.DestroySurface = (PFN_eglDestroySurface)</span>
        _glfw_dlsym(_glfw.egl.handle, "eglDestroySurface");
<span style = "background-color:#fdd">    _glfw.egl.DestroyContext = (PFN_eglDestroyContext)</span>
        _glfw_dlsym(_glfw.egl.handle, "eglDestroyContext");
<span style = "background-color:#fdd">    _glfw.egl.CreateWindowSurface = (PFN_eglCreateWindowSurface)</span>
        _glfw_dlsym(_glfw.egl.handle, "eglCreateWindowSurface");
<span style = "background-color:#fdd">    _glfw.egl.MakeCurrent = (PFN_eglMakeCurrent)</span>
        _glfw_dlsym(_glfw.egl.handle, "eglMakeCurrent");
<span style = "background-color:#fdd">    _glfw.egl.SwapBuffers = (PFN_eglSwapBuffers)</span>
        _glfw_dlsym(_glfw.egl.handle, "eglSwapBuffers");
<span style = "background-color:#fdd">    _glfw.egl.SwapInterval = (PFN_eglSwapInterval)</span>
        _glfw_dlsym(_glfw.egl.handle, "eglSwapInterval");
<span style = "background-color:#fdd">    _glfw.egl.QueryString = (PFN_eglQueryString)</span>
        _glfw_dlsym(_glfw.egl.handle, "eglQueryString");
<span style = "background-color:#fdd">    _glfw.egl.GetProcAddress = (PFN_eglGetProcAddress)</span>
        _glfw_dlsym(_glfw.egl.handle, "eglGetProcAddress");

    if (!_glfw.egl.GetConfigAttrib ||
        !_glfw.egl.GetConfigs ||
        !_glfw.egl.GetDisplay ||
        !_glfw.egl.GetError ||
        !_glfw.egl.Initialize ||
        !_glfw.egl.Terminate ||
        !_glfw.egl.BindAPI ||
        !_glfw.egl.CreateContext ||
        !_glfw.egl.DestroySurface ||
        !_glfw.egl.DestroyContext ||
        !_glfw.egl.CreateWindowSurface ||
        !_glfw.egl.MakeCurrent ||
        !_glfw.egl.SwapBuffers ||
        !_glfw.egl.SwapInterval ||
<span style = "background-color:#fdd">        !_glfw.egl.QueryString ||</span>
        !_glfw.egl.GetProcAddress)
    {
<span style = "background-color:#fdd">        _glfwInputError(GLFW_PLATFORM_ERROR,</span>
                        "EGL: Failed to load required entry points");

<span style = "background-color:#fdd">        _glfwTerminateEGL();
        return GLFW_FALSE;</span>
    }

<span style = "background-color:#fdd">    extensions = eglQueryString(EGL_NO_DISPLAY, EGL_EXTENSIONS);
    if (extensions &amp;&amp; eglGetError() == EGL_SUCCESS)
        _glfw.egl.EXT_client_extensions = GLFW_TRUE;</span>

<span style = "background-color:#fdd">    if (_glfw.egl.EXT_client_extensions)</span>
    {
<span style = "background-color:#fdd">        _glfw.egl.EXT_platform_base =</span>
            _glfwStringInExtensionString("EGL_EXT_platform_base", extensions);
<span style = "background-color:#fdd">        _glfw.egl.EXT_platform_x11 =</span>
            _glfwStringInExtensionString("EGL_EXT_platform_x11", extensions);
<span style = "background-color:#fdd">        _glfw.egl.EXT_platform_wayland =</span>
            _glfwStringInExtensionString("EGL_EXT_platform_wayland", extensions);
<span style = "background-color:#fdd">        _glfw.egl.ANGLE_platform_angle =</span>
            _glfwStringInExtensionString("EGL_ANGLE_platform_angle", extensions);
<span style = "background-color:#fdd">        _glfw.egl.ANGLE_platform_angle_opengl =</span>
            _glfwStringInExtensionString("EGL_ANGLE_platform_angle_opengl", extensions);
<span style = "background-color:#fdd">        _glfw.egl.ANGLE_platform_angle_d3d =</span>
            _glfwStringInExtensionString("EGL_ANGLE_platform_angle_d3d", extensions);
<span style = "background-color:#fdd">        _glfw.egl.ANGLE_platform_angle_vulkan =</span>
            _glfwStringInExtensionString("EGL_ANGLE_platform_angle_vulkan", extensions);
<span style = "background-color:#fdd">        _glfw.egl.ANGLE_platform_angle_metal =</span>
            _glfwStringInExtensionString("EGL_ANGLE_platform_angle_metal", extensions);
    }

<span style = "background-color:#fdd">    if (_glfw.egl.EXT_platform_base)</span>
    {
<span style = "background-color:#fdd">        _glfw.egl.GetPlatformDisplayEXT = (PFNEGLGETPLATFORMDISPLAYEXTPROC)</span>
            eglGetProcAddress("eglGetPlatformDisplayEXT");
<span style = "background-color:#fdd">        _glfw.egl.CreatePlatformWindowSurfaceEXT = (PFNEGLCREATEPLATFORMWINDOWSURFACEEXTPROC)</span>
            eglGetProcAddress("eglCreatePlatformWindowSurfaceEXT");
    }

<span style = "background-color:#fdd">    _glfw.egl.platform = _glfwPlatformGetEGLPlatform(&amp;attribs);
    if (_glfw.egl.platform)</span>
    {
<span style = "background-color:#fdd">        _glfw.egl.display =</span>
            eglGetPlatformDisplayEXT(_glfw.egl.platform,
                                     _glfwPlatformGetEGLNativeDisplay(),
                                     attribs);
<span style = "background-color:#fdd">    }</span>
    else
<span style = "background-color:#fdd">        _glfw.egl.display = eglGetDisplay(_glfwPlatformGetEGLNativeDisplay());</span>

<span style = "background-color:#fdd">    _glfw_free(attribs);</span>

<span style = "background-color:#fdd">    if (_glfw.egl.display == EGL_NO_DISPLAY)</span>
    {
<span style = "background-color:#fdd">        _glfwInputError(GLFW_API_UNAVAILABLE,</span>
                        "EGL: Failed to get EGL display: %s",
                        getEGLErrorString(eglGetError()));

<span style = "background-color:#fdd">        _glfwTerminateEGL();
        return GLFW_FALSE;</span>
    }

<span style = "background-color:#fdd">    if (!eglInitialize(_glfw.egl.display, &amp;_glfw.egl.major, &amp;_glfw.egl.minor))</span>
    {
<span style = "background-color:#fdd">        _glfwInputError(GLFW_API_UNAVAILABLE,</span>
                        "EGL: Failed to initialize EGL: %s",
                        getEGLErrorString(eglGetError()));

<span style = "background-color:#fdd">        _glfwTerminateEGL();
        return GLFW_FALSE;</span>
    }

<span style = "background-color:#fdd">    _glfw.egl.KHR_create_context =</span>
        extensionSupportedEGL("EGL_KHR_create_context");
<span style = "background-color:#fdd">    _glfw.egl.KHR_create_context_no_error =</span>
        extensionSupportedEGL("EGL_KHR_create_context_no_error");
<span style = "background-color:#fdd">    _glfw.egl.KHR_gl_colorspace =</span>
        extensionSupportedEGL("EGL_KHR_gl_colorspace");
<span style = "background-color:#fdd">    _glfw.egl.KHR_get_all_proc_addresses =</span>
        extensionSupportedEGL("EGL_KHR_get_all_proc_addresses");
<span style = "background-color:#fdd">    _glfw.egl.KHR_context_flush_control =</span>
        extensionSupportedEGL("EGL_KHR_context_flush_control");

<span style = "background-color:#fdd">    return GLFW_TRUE;
}</span>

// Terminate EGL
//
void _glfwTerminateEGL(void)
<span style = "background-color:#dfd">{
    if (_glfw.egl.display)</span>
    {
<span style = "background-color:#fdd">        eglTerminate(_glfw.egl.display);
        _glfw.egl.display = EGL_NO_DISPLAY;</span>
    }

<span style = "background-color:#dfd">    if (_glfw.egl.handle)</span>
    {
<span style = "background-color:#fdd">        _glfw_dlclose(_glfw.egl.handle);
        _glfw.egl.handle = NULL;</span>
    }
<span style = "background-color:#dfd">}</span>

#define setAttrib(a, v) \
{ \
    assert(((size_t) index + 1) &lt; sizeof(attribs) / sizeof(attribs[0])); \
    attribs[index++] = a; \
    attribs[index++] = v; \
}

// Create the OpenGL or OpenGL ES context
//
GLFWbool _glfwCreateContextEGL(_GLFWwindow* window,
                               const _GLFWctxconfig* ctxconfig,
                               const _GLFWfbconfig* fbconfig)
<span style = "background-color:#fdd">{</span>
    EGLint attribs[40];
    EGLConfig config;
<span style = "background-color:#fdd">    EGLContext share = NULL;</span>
    EGLNativeWindowType native;
<span style = "background-color:#fdd">    int index = 0;</span>

<span style = "background-color:#fdd">    if (!_glfw.egl.display)</span>
    {
<span style = "background-color:#fdd">        _glfwInputError(GLFW_API_UNAVAILABLE, "EGL: API not available");
        return GLFW_FALSE;</span>
    }

<span style = "background-color:#fdd">    if (ctxconfig-&gt;share)
        share = ctxconfig-&gt;share-&gt;context.egl.handle;</span>

<span style = "background-color:#fdd">    if (!chooseEGLConfig(ctxconfig, fbconfig, &amp;config))</span>
    {
<span style = "background-color:#fdd">        _glfwInputError(GLFW_FORMAT_UNAVAILABLE,</span>
                        "EGL: Failed to find a suitable EGLConfig");
<span style = "background-color:#fdd">        return GLFW_FALSE;</span>
    }

<span style = "background-color:#fdd">    if (ctxconfig-&gt;client == GLFW_OPENGL_ES_API)</span>
    {
<span style = "background-color:#fdd">        if (!eglBindAPI(EGL_OPENGL_ES_API))</span>
        {
<span style = "background-color:#fdd">            _glfwInputError(GLFW_API_UNAVAILABLE,</span>
                            "EGL: Failed to bind OpenGL ES: %s",
                            getEGLErrorString(eglGetError()));
<span style = "background-color:#fdd">            return GLFW_FALSE;</span>
        }
<span style = "background-color:#fdd">    }</span>
    else
    {
<span style = "background-color:#fdd">        if (!eglBindAPI(EGL_OPENGL_API))</span>
        {
<span style = "background-color:#fdd">            _glfwInputError(GLFW_API_UNAVAILABLE,</span>
                            "EGL: Failed to bind OpenGL: %s",
                            getEGLErrorString(eglGetError()));
<span style = "background-color:#fdd">            return GLFW_FALSE;</span>
        }
    }

<span style = "background-color:#fdd">    if (_glfw.egl.KHR_create_context)</span>
    {
<span style = "background-color:#fdd">        int mask = 0, flags = 0;</span>

<span style = "background-color:#fdd">        if (ctxconfig-&gt;client == GLFW_OPENGL_API)</span>
        {
<span style = "background-color:#fdd">            if (ctxconfig-&gt;forward)
                flags |= EGL_CONTEXT_OPENGL_FORWARD_COMPATIBLE_BIT_KHR;</span>

<span style = "background-color:#fdd">            if (ctxconfig-&gt;profile == GLFW_OPENGL_CORE_PROFILE)
                mask |= EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT_KHR;
            else if (ctxconfig-&gt;profile == GLFW_OPENGL_COMPAT_PROFILE)
                mask |= EGL_CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT_KHR;</span>
        }

<span style = "background-color:#fdd">        if (ctxconfig-&gt;debug)
            flags |= EGL_CONTEXT_OPENGL_DEBUG_BIT_KHR;</span>

<span style = "background-color:#fdd">        if (ctxconfig-&gt;robustness)</span>
        {
<span style = "background-color:#fdd">            if (ctxconfig-&gt;robustness == GLFW_NO_RESET_NOTIFICATION)</span>
            {
<span style = "background-color:#fdd">                setAttrib(EGL_CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_KHR,</span>
                          EGL_NO_RESET_NOTIFICATION_KHR);
<span style = "background-color:#fdd">            }
            else if (ctxconfig-&gt;robustness == GLFW_LOSE_CONTEXT_ON_RESET)</span>
            {
<span style = "background-color:#fdd">                setAttrib(EGL_CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_KHR,</span>
                          EGL_LOSE_CONTEXT_ON_RESET_KHR);
            }

<span style = "background-color:#fdd">            flags |= EGL_CONTEXT_OPENGL_ROBUST_ACCESS_BIT_KHR;</span>
        }

<span style = "background-color:#fdd">        if (ctxconfig-&gt;noerror)</span>
        {
<span style = "background-color:#fdd">            if (_glfw.egl.KHR_create_context_no_error)
                setAttrib(EGL_CONTEXT_OPENGL_NO_ERROR_KHR, GLFW_TRUE);</span>
        }

<span style = "background-color:#fdd">        if (ctxconfig-&gt;major != 1 || ctxconfig-&gt;minor != 0)</span>
        {
<span style = "background-color:#fdd">            setAttrib(EGL_CONTEXT_MAJOR_VERSION_KHR, ctxconfig-&gt;major);
            setAttrib(EGL_CONTEXT_MINOR_VERSION_KHR, ctxconfig-&gt;minor);</span>
        }

<span style = "background-color:#fdd">        if (mask)
            setAttrib(EGL_CONTEXT_OPENGL_PROFILE_MASK_KHR, mask);</span>

<span style = "background-color:#fdd">        if (flags)
            setAttrib(EGL_CONTEXT_FLAGS_KHR, flags);
    }</span>
    else
    {
<span style = "background-color:#fdd">        if (ctxconfig-&gt;client == GLFW_OPENGL_ES_API)
            setAttrib(EGL_CONTEXT_CLIENT_VERSION, ctxconfig-&gt;major);</span>
    }

<span style = "background-color:#fdd">    if (_glfw.egl.KHR_context_flush_control)</span>
    {
<span style = "background-color:#fdd">        if (ctxconfig-&gt;release == GLFW_RELEASE_BEHAVIOR_NONE)</span>
        {
<span style = "background-color:#fdd">            setAttrib(EGL_CONTEXT_RELEASE_BEHAVIOR_KHR,</span>
                      EGL_CONTEXT_RELEASE_BEHAVIOR_NONE_KHR);
<span style = "background-color:#fdd">        }
        else if (ctxconfig-&gt;release == GLFW_RELEASE_BEHAVIOR_FLUSH)</span>
        {
<span style = "background-color:#fdd">            setAttrib(EGL_CONTEXT_RELEASE_BEHAVIOR_KHR,</span>
                      EGL_CONTEXT_RELEASE_BEHAVIOR_FLUSH_KHR);
        }
    }

<span style = "background-color:#fdd">    setAttrib(EGL_NONE, EGL_NONE);</span>

<span style = "background-color:#fdd">    window-&gt;context.egl.handle = eglCreateContext(_glfw.egl.display,</span>
                                                  config, share, attribs);

<span style = "background-color:#fdd">    if (window-&gt;context.egl.handle == EGL_NO_CONTEXT)</span>
    {
<span style = "background-color:#fdd">        _glfwInputError(GLFW_VERSION_UNAVAILABLE,</span>
                        "EGL: Failed to create context: %s",
                        getEGLErrorString(eglGetError()));
<span style = "background-color:#fdd">        return GLFW_FALSE;</span>
    }

    // Set up attributes for surface creation
<span style = "background-color:#fdd">    index = 0;</span>

<span style = "background-color:#fdd">    if (fbconfig-&gt;sRGB)</span>
    {
<span style = "background-color:#fdd">        if (_glfw.egl.KHR_gl_colorspace)
            setAttrib(EGL_GL_COLORSPACE_KHR, EGL_GL_COLORSPACE_SRGB_KHR);</span>
    }

<span style = "background-color:#fdd">    if (!fbconfig-&gt;doublebuffer)
        setAttrib(EGL_RENDER_BUFFER, EGL_SINGLE_BUFFER);</span>

<span style = "background-color:#fdd">    setAttrib(EGL_NONE, EGL_NONE);</span>

<span style = "background-color:#fdd">    native = _glfwPlatformGetEGLNativeWindow(window);</span>
    // HACK: ANGLE does not implement eglCreatePlatformWindowSurfaceEXT
    //       despite reporting EGL_EXT_platform_base
<span style = "background-color:#fdd">    if (_glfw.egl.platform &amp;&amp; _glfw.egl.platform != EGL_PLATFORM_ANGLE_ANGLE)</span>
    {
<span style = "background-color:#fdd">        window-&gt;context.egl.surface =</span>
            eglCreatePlatformWindowSurfaceEXT(_glfw.egl.display, config, native, attribs);
<span style = "background-color:#fdd">    }</span>
    else
    {
<span style = "background-color:#fdd">        window-&gt;context.egl.surface =</span>
            eglCreateWindowSurface(_glfw.egl.display, config, native, attribs);
    }

<span style = "background-color:#fdd">    if (window-&gt;context.egl.surface == EGL_NO_SURFACE)</span>
    {
<span style = "background-color:#fdd">        _glfwInputError(GLFW_PLATFORM_ERROR,</span>
                        "EGL: Failed to create window surface: %s",
                        getEGLErrorString(eglGetError()));
<span style = "background-color:#fdd">        return GLFW_FALSE;</span>
    }

<span style = "background-color:#fdd">    window-&gt;context.egl.config = config;</span>

    // Load the appropriate client library
<span style = "background-color:#fdd">    if (!_glfw.egl.KHR_get_all_proc_addresses)</span>
    {
        int i;
        const char** sonames;
<span style = "background-color:#fdd">        const char* es1sonames[] =</span>
        {
#if defined(_GLFW_GLESV1_LIBRARY)
            _GLFW_GLESV1_LIBRARY,
#elif defined(_GLFW_WIN32)
            "GLESv1_CM.dll",
            "libGLES_CM.dll",
#elif defined(_GLFW_COCOA)
            "libGLESv1_CM.dylib",
#else
            "libGLESv1_CM.so.1",
            "libGLES_CM.so.1",
#endif
            NULL
        };
<span style = "background-color:#fdd">        const char* es2sonames[] =</span>
        {
#if defined(_GLFW_GLESV2_LIBRARY)
            _GLFW_GLESV2_LIBRARY,
#elif defined(_GLFW_WIN32)
            "GLESv2.dll",
            "libGLESv2.dll",
#elif defined(_GLFW_COCOA)
            "libGLESv2.dylib",
#elif defined(__CYGWIN__)
            "libGLESv2-2.so",
#else
            "libGLESv2.so.2",
#endif
            NULL
        };
<span style = "background-color:#fdd">        const char* glsonames[] =</span>
        {
#if defined(_GLFW_OPENGL_LIBRARY)
            _GLFW_OPENGL_LIBRARY,
#elif defined(_GLFW_WIN32)
#elif defined(_GLFW_COCOA)
#else
            "libGL.so.1",
#endif
            NULL
        };

<span style = "background-color:#fdd">        if (ctxconfig-&gt;client == GLFW_OPENGL_ES_API)</span>
        {
<span style = "background-color:#fdd">            if (ctxconfig-&gt;major == 1)
                sonames = es1sonames;</span>
            else
<span style = "background-color:#fdd">                sonames = es2sonames;
        }</span>
        else
<span style = "background-color:#fdd">            sonames = glsonames;</span>

<span style = "background-color:#fdd">        for (i = 0;  sonames[i];  i++)</span>
        {
            // HACK: Match presence of lib prefix to increase chance of finding
            //       a matching pair in the jungle that is Win32 EGL/GLES
<span style = "background-color:#fdd">            if (_glfw.egl.prefix != (strncmp(sonames[i], "lib", 3) == 0))
                continue;</span>

<span style = "background-color:#fdd">            window-&gt;context.egl.client = _glfw_dlopen(sonames[i]);
            if (window-&gt;context.egl.client)
                break;
        }</span>

<span style = "background-color:#fdd">        if (!window-&gt;context.egl.client)</span>
        {
<span style = "background-color:#fdd">            _glfwInputError(GLFW_API_UNAVAILABLE,</span>
                            "EGL: Failed to load client library");
<span style = "background-color:#fdd">            return GLFW_FALSE;</span>
        }
    }

<span style = "background-color:#fdd">    window-&gt;context.makeCurrent = makeContextCurrentEGL;
    window-&gt;context.swapBuffers = swapBuffersEGL;
    window-&gt;context.swapInterval = swapIntervalEGL;
    window-&gt;context.extensionSupported = extensionSupportedEGL;
    window-&gt;context.getProcAddress = getProcAddressEGL;
    window-&gt;context.destroy = destroyContextEGL;</span>

<span style = "background-color:#fdd">    return GLFW_TRUE;
}</span>

#undef setAttrib

// Returns the Visual and depth of the chosen EGLConfig
//
#if defined(_GLFW_X11)
GLFWbool _glfwChooseVisualEGL(const _GLFWwndconfig* wndconfig,
                              const _GLFWctxconfig* ctxconfig,
                              const _GLFWfbconfig* fbconfig,
                              Visual** visual, int* depth)
{
    XVisualInfo* result;
    XVisualInfo desired;
    EGLConfig native;
    EGLint visualID = 0, count = 0;
    const long vimask = VisualScreenMask | VisualIDMask;

    if (!chooseEGLConfig(ctxconfig, fbconfig, &amp;native))
    {
        _glfwInputError(GLFW_FORMAT_UNAVAILABLE,
                        "EGL: Failed to find a suitable EGLConfig");
        return GLFW_FALSE;
    }

    eglGetConfigAttrib(_glfw.egl.display, native,
                       EGL_NATIVE_VISUAL_ID, &amp;visualID);

    desired.screen = _glfw.x11.screen;
    desired.visualid = visualID;

    result = XGetVisualInfo(_glfw.x11.display, vimask, &amp;desired, &amp;count);
    if (!result)
    {
        _glfwInputError(GLFW_PLATFORM_ERROR,
                        "EGL: Failed to retrieve Visual for EGLConfig");
        return GLFW_FALSE;
    }

    *visual = result-&gt;visual;
    *depth = result-&gt;depth;

    XFree(result);
    return GLFW_TRUE;
}
#endif // _GLFW_X11


//////////////////////////////////////////////////////////////////////////
//////                        GLFW native API                       //////
//////////////////////////////////////////////////////////////////////////

GLFWAPI EGLDisplay glfwGetEGLDisplay(void)
<span style = "background-color:#fdd">{
    _GLFW_REQUIRE_INIT_OR_RETURN(EGL_NO_DISPLAY);
    return _glfw.egl.display;
}</span>

GLFWAPI EGLContext glfwGetEGLContext(GLFWwindow* handle)
<span style = "background-color:#fdd">{
    _GLFWwindow* window = (_GLFWwindow*) handle;
    _GLFW_REQUIRE_INIT_OR_RETURN(EGL_NO_CONTEXT);</span>

<span style = "background-color:#fdd">    if (window-&gt;context.client == GLFW_NO_API)</span>
    {
<span style = "background-color:#fdd">        _glfwInputError(GLFW_NO_WINDOW_CONTEXT, NULL);
        return EGL_NO_CONTEXT;</span>
    }

<span style = "background-color:#fdd">    return window-&gt;context.egl.handle;
}</span>

GLFWAPI EGLSurface glfwGetEGLSurface(GLFWwindow* handle)
<span style = "background-color:#fdd">{
    _GLFWwindow* window = (_GLFWwindow*) handle;
    _GLFW_REQUIRE_INIT_OR_RETURN(EGL_NO_SURFACE);</span>

<span style = "background-color:#fdd">    if (window-&gt;context.client == GLFW_NO_API)</span>
    {
<span style = "background-color:#fdd">        _glfwInputError(GLFW_NO_WINDOW_CONTEXT, NULL);
        return EGL_NO_SURFACE;</span>
    }

<span style = "background-color:#fdd">    return window-&gt;context.egl.surface;
}</span>
</pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>