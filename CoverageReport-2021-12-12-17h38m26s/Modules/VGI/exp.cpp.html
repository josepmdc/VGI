<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>exp.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
#include &lt;sstream&gt;

#include "exp.h"
#include "stream.h"
#include "yaml-cpp/exceptions.h"  // IWYU pragma: keep

namespace YAML {
struct Mark;
}  // namespace YAML

namespace YAML {
namespace Exp {
<span style = "background-color:#fdd">unsigned ParseHex(const std::string&amp; str, const Mark&amp; mark) {
  unsigned value = 0;
  for (char ch : str) {
    int digit = 0;
    if ('a' &lt;= ch &amp;&amp; ch &lt;= 'f')
      digit = ch - 'a' + 10;
    else if ('A' &lt;= ch &amp;&amp; ch &lt;= 'F')
      digit = ch - 'A' + 10;
    else if ('0' &lt;= ch &amp;&amp; ch &lt;= '9')
      digit = ch - '0';</span>
    else
<span style = "background-color:#fdd">      throw ParserException(mark, ErrorMsg::INVALID_HEX);</span>

<span style = "background-color:#fdd">    value = (value &lt;&lt; 4) + digit;
  }</span>

<span style = "background-color:#fdd">  return value;
}</span>

<span style = "background-color:#fdd">std::string Str(unsigned ch) { return std::string(1, static_cast&lt;char&gt;(ch)); }</span>

// Escape
// . Translates the next 'codeLength' characters into a hex number and returns
// the result.
// . Throws if it's not actually hex.
<span style = "background-color:#fdd">std::string Escape(Stream&amp; in, int codeLength) {</span>
  // grab string
<span style = "background-color:#fdd">  std::string str;
  for (int i = 0; i &lt; codeLength; i++)
    str += in.get();</span>

  // get the value
<span style = "background-color:#fdd">  unsigned value = ParseHex(str, in.mark());</span>

  // legal unicode?
<span style = "background-color:#fdd">  if ((value &gt;= 0xD800 &amp;&amp; value &lt;= 0xDFFF) || value &gt; 0x10FFFF) {
    std::stringstream msg;
    msg &lt;&lt; ErrorMsg::INVALID_UNICODE &lt;&lt; value;
    throw ParserException(in.mark(), msg.str());
  }</span>

  // now break it up into chars
<span style = "background-color:#fdd">  if (value &lt;= 0x7F)
    return Str(value);</span>

<span style = "background-color:#fdd">  if (value &lt;= 0x7FF)
    return Str(0xC0 + (value &gt;&gt; 6)) + Str(0x80 + (value &amp; 0x3F));</span>

<span style = "background-color:#fdd">  if (value &lt;= 0xFFFF)
    return Str(0xE0 + (value &gt;&gt; 12)) + Str(0x80 + ((value &gt;&gt; 6) &amp; 0x3F)) +</span>
           Str(0x80 + (value &amp; 0x3F));

<span style = "background-color:#fdd">  return Str(0xF0 + (value &gt;&gt; 18)) + Str(0x80 + ((value &gt;&gt; 12) &amp; 0x3F)) +</span>
         Str(0x80 + ((value &gt;&gt; 6) &amp; 0x3F)) + Str(0x80 + (value &amp; 0x3F));
<span style = "background-color:#fdd">}</span>

// Escape
// . Escapes the sequence starting 'in' (it must begin with a '\' or single
// quote)
//   and returns the result.
// . Throws if it's an unknown escape character.
<span style = "background-color:#fdd">std::string Escape(Stream&amp; in) {</span>
  // eat slash
<span style = "background-color:#fdd">  char escape = in.get();</span>

  // switch on escape character
<span style = "background-color:#fdd">  char ch = in.get();</span>

  // first do single quote, since it's easier
<span style = "background-color:#fdd">  if (escape == '\'' &amp;&amp; ch == '\'')
    return "\'";</span>

  // now do the slash (we're not gonna check if it's a slash - you better pass
  // one!)
<span style = "background-color:#fdd">  switch (ch) {</span>
    case '0':
<span style = "background-color:#fdd">      return std::string(1, '\x00');</span>
    case 'a':
<span style = "background-color:#fdd">      return "\x07";</span>
    case 'b':
<span style = "background-color:#fdd">      return "\x08";</span>
    case 't':
    case '\t':
<span style = "background-color:#fdd">      return "\x09";</span>
    case 'n':
<span style = "background-color:#fdd">      return "\x0A";</span>
    case 'v':
<span style = "background-color:#fdd">      return "\x0B";</span>
    case 'f':
<span style = "background-color:#fdd">      return "\x0C";</span>
    case 'r':
<span style = "background-color:#fdd">      return "\x0D";</span>
    case 'e':
<span style = "background-color:#fdd">      return "\x1B";</span>
    case ' ':
<span style = "background-color:#fdd">      return R"( )";</span>
    case '\"':
<span style = "background-color:#fdd">      return "\"";</span>
    case '\'':
<span style = "background-color:#fdd">      return "\'";</span>
    case '\\':
<span style = "background-color:#fdd">      return "\\";</span>
    case '/':
<span style = "background-color:#fdd">      return "/";</span>
    case 'N':
<span style = "background-color:#fdd">      return "\x85";</span>
    case '_':
<span style = "background-color:#fdd">      return "\xA0";</span>
    case 'L':
<span style = "background-color:#fdd">      return "\xE2\x80\xA8";  // LS (#x2028)</span>
    case 'P':
<span style = "background-color:#fdd">      return "\xE2\x80\xA9";  // PS (#x2029)</span>
    case 'x':
<span style = "background-color:#fdd">      return Escape(in, 2);</span>
    case 'u':
<span style = "background-color:#fdd">      return Escape(in, 4);</span>
    case 'U':
<span style = "background-color:#fdd">      return Escape(in, 8);</span>
  }

<span style = "background-color:#fdd">  std::stringstream msg;
  throw ParserException(in.mark(), std::string(ErrorMsg::INVALID_ESCAPE) + ch);
}</span>
}  // namespace Exp
}  // namespace YAML</pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>