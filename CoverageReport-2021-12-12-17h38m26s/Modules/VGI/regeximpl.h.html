<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>regeximpl.h</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
#ifndef REGEXIMPL_H_62B23520_7C8E_11DE_8A39_0800200C9A66
#define REGEXIMPL_H_62B23520_7C8E_11DE_8A39_0800200C9A66

#if defined(_MSC_VER) ||                                            \
    (defined(__GNUC__) &amp;&amp; (__GNUC__ == 3 &amp;&amp; __GNUC_MINOR__ &gt;= 4) || \
     (__GNUC__ &gt;= 4))  // GCC supports "pragma once" correctly since 3.4
#pragma once
#endif

#include "stream.h"
#include "streamcharsource.h"
#include "stringsource.h"

namespace YAML {
// query matches
<span style = "background-color:#fdd">inline bool RegEx::Matches(char ch) const {
  std::string str;
  str += ch;
  return Matches(str);
}</span>

<span style = "background-color:#fdd">inline bool RegEx::Matches(const std::string&amp; str) const {
  return Match(str) &gt;= 0;
}</span>

<span style = "background-color:#dfd">inline bool RegEx::Matches(const Stream&amp; in) const { return Match(in) &gt;= 0; }</span>

template &lt;typename Source&gt;
inline bool RegEx::Matches(const Source&amp; source) const {
  return Match(source) &gt;= 0;
}

// Match
// . Matches the given string against this regular expression.
// . Returns the number of characters matched.
// . Returns -1 if no characters were matched (the reason for
//   not returning zero is that we may have an empty regex
//   which is ALWAYS successful at matching zero characters).
// . REMEMBER that we only match from the start of the buffer!
<span style = "background-color:#fdd">inline int RegEx::Match(const std::string&amp; str) const {
  StringCharSource source(str.c_str(), str.size());
  return Match(source);
}</span>

<span style = "background-color:#dfd">inline int RegEx::Match(const Stream&amp; in) const {
  StreamCharSource source(in);
  return Match(source);
}</span>

template &lt;typename Source&gt;
<span style = "background-color:#dfd">inline bool RegEx::IsValidSource(const Source&amp; source) const {
  return source;
}</span>

template &lt;&gt;
inline bool RegEx::IsValidSource&lt;StringCharSource&gt;(
<span style = "background-color:#fdd">    const StringCharSource&amp; source) const {
  switch (m_op) {</span>
    case REGEX_MATCH:
    case REGEX_RANGE:
<span style = "background-color:#fdd">      return source;</span>
    default:
<span style = "background-color:#fdd">      return true;</span>
  }
<span style = "background-color:#fdd">}</span>

template &lt;typename Source&gt;
<span style = "background-color:#dfd">inline int RegEx::Match(const Source&amp; source) const {
  return IsValidSource(source) ? MatchUnchecked(source) : -1;
}</span>

template &lt;typename Source&gt;
<span style = "background-color:#dfd">inline int RegEx::MatchUnchecked(const Source&amp; source) const {
  switch (m_op) {</span>
    case REGEX_EMPTY:
<span style = "background-color:#fdd">      return MatchOpEmpty(source);</span>
    case REGEX_MATCH:
<span style = "background-color:#dfd">      return MatchOpMatch(source);</span>
    case REGEX_RANGE:
<span style = "background-color:#fdd">      return MatchOpRange(source);</span>
    case REGEX_OR:
<span style = "background-color:#dfd">      return MatchOpOr(source);</span>
    case REGEX_AND:
<span style = "background-color:#fdd">      return MatchOpAnd(source);</span>
    case REGEX_NOT:
<span style = "background-color:#dfd">      return MatchOpNot(source);</span>
    case REGEX_SEQ:
<span style = "background-color:#dfd">      return MatchOpSeq(source);</span>
  }

<span style = "background-color:#fdd">  return -1;</span>
<span style = "background-color:#dfd">}</span>

//////////////////////////////////////////////////////////////////////////////
// Operators
// Note: the convention MatchOp*&lt;Source&gt; is that we can assume
// IsSourceValid(source).
//       So we do all our checks *before* we call these functions

// EmptyOperator
template &lt;typename Source&gt;
<span style = "background-color:#fdd">inline int RegEx::MatchOpEmpty(const Source&amp; source) const {
  return source[0] == Stream::eof() ? 0 : -1;
}</span>

template &lt;&gt;
inline int RegEx::MatchOpEmpty&lt;StringCharSource&gt;(
<span style = "background-color:#fdd">    const StringCharSource&amp; source) const {
  return !source ? 0 : -1;  // the empty regex only is successful on the empty</span>
                            // string
<span style = "background-color:#fdd">}</span>

// MatchOperator
template &lt;typename Source&gt;
<span style = "background-color:#dfd">inline int RegEx::MatchOpMatch(const Source&amp; source) const {
  if (source[0] != m_a)
    return -1;
  return 1;
}</span>

// RangeOperator
template &lt;typename Source&gt;
<span style = "background-color:#fdd">inline int RegEx::MatchOpRange(const Source&amp; source) const {
  if (m_a &gt; source[0] || m_z &lt; source[0])
    return -1;
  return 1;
}</span>

// OrOperator
template &lt;typename Source&gt;
<span style = "background-color:#dfd">inline int RegEx::MatchOpOr(const Source&amp; source) const {
  for (const RegEx&amp; param : m_params) {
    int n = param.MatchUnchecked(source);
    if (n &gt;= 0)
      return n;
  }
  return -1;
}</span>

// AndOperator
// Note: 'AND' is a little funny, since we may be required to match things
//       of different lengths. If we find a match, we return the length of
//       the FIRST entry on the list.
template &lt;typename Source&gt;
<span style = "background-color:#fdd">inline int RegEx::MatchOpAnd(const Source&amp; source) const {
  int first = -1;
  for (std::size_t i = 0; i &lt; m_params.size(); i++) {
    int n = m_params[i].MatchUnchecked(source);
    if (n == -1)
      return -1;
    if (i == 0)
      first = n;
  }
  return first;
}</span>

// NotOperator
template &lt;typename Source&gt;
<span style = "background-color:#dfd">inline int RegEx::MatchOpNot(const Source&amp; source) const {
  if (m_params.empty())</span>
<span style = "background-color:#fdd">    return -1;</span>
<span style = "background-color:#dfd">  if (m_params[0].MatchUnchecked(source) &gt;= 0)</span>
<span style = "background-color:#fdd">    return -1;</span>
<span style = "background-color:#dfd">  return 1;
}</span>

// SeqOperator
template &lt;typename Source&gt;
<span style = "background-color:#dfd">inline int RegEx::MatchOpSeq(const Source&amp; source) const {
  int offset = 0;
  for (const RegEx&amp; param : m_params) {
    int n = param.Match(source + offset);  // note Match, not</span>
                                           // MatchUnchecked because we
                                           // need to check validity after
                                           // the offset
<span style = "background-color:#dfd">    if (n == -1)
      return -1;
    offset += n;
  }</span>

<span style = "background-color:#dfd">  return offset;
}</span>
}  // namespace YAML

#endif  // REGEXIMPL_H_62B23520_7C8E_11DE_8A39_0800200C9A66</pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>