<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>imgui_widgets.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="">
        <h4>Syntax highlighting has been disabled for performance reasons.</h4>
        <pre class="prettyprint lang-cpp linenums">
// dear imgui, v1.86 WIP
// (widgets code)

/*

Index of this file:

// [SECTION] Forward Declarations
// [SECTION] Widgets: Text, etc.
// [SECTION] Widgets: Main (Button, Image, Checkbox, RadioButton, ProgressBar, Bullet, etc.)
// [SECTION] Widgets: Low-level Layout helpers (Spacing, Dummy, NewLine, Separator, etc.)
// [SECTION] Widgets: ComboBox
// [SECTION] Data Type and Data Formatting Helpers
// [SECTION] Widgets: DragScalar, DragFloat, DragInt, etc.
// [SECTION] Widgets: SliderScalar, SliderFloat, SliderInt, etc.
// [SECTION] Widgets: InputScalar, InputFloat, InputInt, etc.
// [SECTION] Widgets: InputText, InputTextMultiline
// [SECTION] Widgets: ColorEdit, ColorPicker, ColorButton, etc.
// [SECTION] Widgets: TreeNode, CollapsingHeader, etc.
// [SECTION] Widgets: Selectable
// [SECTION] Widgets: ListBox
// [SECTION] Widgets: PlotLines, PlotHistogram
// [SECTION] Widgets: Value helpers
// [SECTION] Widgets: MenuItem, BeginMenu, EndMenu, etc.
// [SECTION] Widgets: BeginTabBar, EndTabBar, etc.
// [SECTION] Widgets: BeginTabItem, EndTabItem, etc.
// [SECTION] Widgets: Columns, BeginColumns, EndColumns, etc.

*/

#if defined(_MSC_VER) &amp;&amp; !defined(_CRT_SECURE_NO_WARNINGS)
#define _CRT_SECURE_NO_WARNINGS
#endif

#include "imgui.h"
#ifndef IMGUI_DISABLE

#ifndef IMGUI_DEFINE_MATH_OPERATORS
#define IMGUI_DEFINE_MATH_OPERATORS
#endif
#include "imgui_internal.h"

// System includes
#include &lt;ctype.h&gt;      // toupper
#if defined(_MSC_VER) &amp;&amp; _MSC_VER &lt;= 1500 // MSVC 2008 or earlier
#include &lt;stddef.h&gt;     // intptr_t
#else
#include &lt;stdint.h&gt;     // intptr_t
#endif

//-------------------------------------------------------------------------
// Warnings
//-------------------------------------------------------------------------

// Visual Studio warnings
#ifdef _MSC_VER
#pragma warning (disable: 4127)     // condition expression is constant
#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen
#if defined(_MSC_VER) &amp;&amp; _MSC_VER &gt;= 1922 // MSVC 2019 16.2 or later
#pragma warning (disable: 5054)     // operator '|': deprecated between enumerations of different types
#endif
#pragma warning (disable: 26451)    // [Static Analyzer] Arithmetic overflow : Using operator 'xxx' on a 4 byte value and then casting the result to a 8 byte value. Cast the value to the wider type before calling operator 'xxx' to avoid overflow(io.2).
#pragma warning (disable: 26812)    // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3).
#endif

// Clang/GCC warnings with -Weverything
#if defined(__clang__)
#if __has_warning("-Wunknown-warning-option")
#pragma clang diagnostic ignored "-Wunknown-warning-option"         // warning: unknown warning group 'xxx'                      // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"                // warning: unknown warning group 'xxx'
#pragma clang diagnostic ignored "-Wold-style-cast"                 // warning: use of old-style cast                            // yes, they are more terse.
#pragma clang diagnostic ignored "-Wfloat-equal"                    // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants (typically 0.0f) is ok.
#pragma clang diagnostic ignored "-Wformat-nonliteral"              // warning: format string is not a string literal            // passing non-literal to vsnformat(). yes, user passing incorrect format strings can crash the code.
#pragma clang diagnostic ignored "-Wsign-conversion"                // warning: implicit conversion changes signedness
#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"  // warning: zero as null pointer constant                    // some standard header variations use #define NULL 0
#pragma clang diagnostic ignored "-Wdouble-promotion"               // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.
#pragma clang diagnostic ignored "-Wenum-enum-conversion"           // warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_')
#pragma clang diagnostic ignored "-Wdeprecated-enum-enum-conversion"// warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_') is deprecated
#pragma clang diagnostic ignored "-Wimplicit-int-float-conversion"  // warning: implicit conversion from 'xxx' to 'float' may lose precision
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wpragmas"                          // warning: unknown option after '#pragma GCC diagnostic' kind
#pragma GCC diagnostic ignored "-Wformat-nonliteral"                // warning: format not a string literal, format string not checked
#pragma GCC diagnostic ignored "-Wclass-memaccess"                  // [__GNUC__ &gt;= 8] warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead
#endif

//-------------------------------------------------------------------------
// Data
//-------------------------------------------------------------------------

// Widgets
static const float          DRAGDROP_HOLD_TO_OPEN_TIMER = 0.70f;    // Time for drag-hold to activate items accepting the ImGuiButtonFlags_PressedOnDragDropHold button behavior.
static const float          DRAG_MOUSE_THRESHOLD_FACTOR = 0.50f;    // Multiplier for the default value of io.MouseDragThreshold to make DragFloat/DragInt react faster to mouse drags.

// Those MIN/MAX values are not define because we need to point to them
static const signed char    IM_S8_MIN  = -128;
static const signed char    IM_S8_MAX  = 127;
static const unsigned char  IM_U8_MIN  = 0;
static const unsigned char  IM_U8_MAX  = 0xFF;
static const signed short   IM_S16_MIN = -32768;
static const signed short   IM_S16_MAX = 32767;
static const unsigned short IM_U16_MIN = 0;
static const unsigned short IM_U16_MAX = 0xFFFF;
static const ImS32          IM_S32_MIN = INT_MIN;    // (-2147483647 - 1), (0x80000000);
static const ImS32          IM_S32_MAX = INT_MAX;    // (2147483647), (0x7FFFFFFF)
static const ImU32          IM_U32_MIN = 0;
static const ImU32          IM_U32_MAX = UINT_MAX;   // (0xFFFFFFFF)
#ifdef LLONG_MIN
static const ImS64          IM_S64_MIN = LLONG_MIN;  // (-9223372036854775807ll - 1ll);
static const ImS64          IM_S64_MAX = LLONG_MAX;  // (9223372036854775807ll);
#else
static const ImS64          IM_S64_MIN = -9223372036854775807LL - 1;
static const ImS64          IM_S64_MAX = 9223372036854775807LL;
#endif
static const ImU64          IM_U64_MIN = 0;
#ifdef ULLONG_MAX
static const ImU64          IM_U64_MAX = ULLONG_MAX; // (0xFFFFFFFFFFFFFFFFull);
#else
static const ImU64          IM_U64_MAX = (2ULL * 9223372036854775807LL + 1);
#endif

//-------------------------------------------------------------------------
// [SECTION] Forward Declarations
//-------------------------------------------------------------------------

// For InputTextEx()
static bool             InputTextFilterCharacter(unsigned int* p_char, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data, ImGuiInputSource input_source);
static int              InputTextCalcTextLenAndLineCount(const char* text_begin, const char** out_text_end);
static ImVec2           InputTextCalcTextSizeW(const ImWchar* text_begin, const ImWchar* text_end, const ImWchar** remaining = NULL, ImVec2* out_offset = NULL, bool stop_on_new_line = false);

//-------------------------------------------------------------------------
// [SECTION] Widgets: Text, etc.
//-------------------------------------------------------------------------
// - TextEx() [Internal]
// - TextUnformatted()
// - Text()
// - TextV()
// - TextColored()
// - TextColoredV()
// - TextDisabled()
// - TextDisabledV()
// - TextWrapped()
// - TextWrappedV()
// - LabelText()
// - LabelTextV()
// - BulletText()
// - BulletTextV()
//-------------------------------------------------------------------------

void ImGui::TextEx(const char* text, const char* text_end, ImGuiTextFlags flags)
<span style = "background-color:#dfd">{
    ImGuiWindow* window = GetCurrentWindow();
    if (window-&gt;SkipItems)</span>
<span style = "background-color:#fdd">        return;</span>
<span style = "background-color:#dfd">    ImGuiContext&amp; g = *GImGui;</span>

    // Accept null ranges
<span style = "background-color:#dfd">    if (text == text_end)</span>
<span style = "background-color:#fdd">        text = text_end = "";</span>

    // Calculate length
<span style = "background-color:#dfd">    const char* text_begin = text;
    if (text_end == NULL)</span>
<span style = "background-color:#fdd">        text_end = text + strlen(text); // FIXME-OPT</span>

<span style = "background-color:#dfd">    const ImVec2 text_pos(window-&gt;DC.CursorPos.x, window-&gt;DC.CursorPos.y + window-&gt;DC.CurrLineTextBaseOffset);
    const float wrap_pos_x = window-&gt;DC.TextWrapPos;
    const bool wrap_enabled = (wrap_pos_x &gt;= 0.0f);
    if (text_end - text &gt; 2000 &amp;&amp; !wrap_enabled)</span>
    {
        // Long text!
        // Perform manual coarse clipping to optimize for long multi-line text
        // - From this point we will only compute the width of lines that are visible. Optimization only available when word-wrapping is disabled.
        // - We also don't vertically center the text within the line full height, which is unlikely to matter because we are likely the biggest and only item on the line.
        // - We use memchr(), pay attention that well optimized versions of those str/mem functions are much faster than a casually written loop.
<span style = "background-color:#fdd">        const char* line = text;
        const float line_height = GetTextLineHeight();
        ImVec2 text_size(0, 0);</span>

        // Lines to skip (can't skip when logging text)
<span style = "background-color:#fdd">        ImVec2 pos = text_pos;
        if (!g.LogEnabled)</span>
        {
<span style = "background-color:#fdd">            int lines_skippable = (int)((window-&gt;ClipRect.Min.y - text_pos.y) / line_height);
            if (lines_skippable &gt; 0)</span>
            {
<span style = "background-color:#fdd">                int lines_skipped = 0;
                while (line &lt; text_end &amp;&amp; lines_skipped &lt; lines_skippable)</span>
                {
<span style = "background-color:#fdd">                    const char* line_end = (const char*)memchr(line, '\n', text_end - line);
                    if (!line_end)
                        line_end = text_end;
                    if ((flags &amp; ImGuiTextFlags_NoWidthForLargeClippedText) == 0)
                        text_size.x = ImMax(text_size.x, CalcTextSize(line, line_end).x);
                    line = line_end + 1;
                    lines_skipped++;
                }
                pos.y += lines_skipped * line_height;</span>
            }
        }

        // Lines to render
<span style = "background-color:#fdd">        if (line &lt; text_end)</span>
        {
<span style = "background-color:#fdd">            ImRect line_rect(pos, pos + ImVec2(FLT_MAX, line_height));
            while (line &lt; text_end)</span>
            {
<span style = "background-color:#fdd">                if (IsClippedEx(line_rect, 0))
                    break;</span>

<span style = "background-color:#fdd">                const char* line_end = (const char*)memchr(line, '\n', text_end - line);
                if (!line_end)
                    line_end = text_end;
                text_size.x = ImMax(text_size.x, CalcTextSize(line, line_end).x);
                RenderText(pos, line, line_end, false);
                line = line_end + 1;
                line_rect.Min.y += line_height;
                line_rect.Max.y += line_height;
                pos.y += line_height;
            }</span>

            // Count remaining lines
<span style = "background-color:#fdd">            int lines_skipped = 0;
            while (line &lt; text_end)</span>
            {
<span style = "background-color:#fdd">                const char* line_end = (const char*)memchr(line, '\n', text_end - line);
                if (!line_end)
                    line_end = text_end;
                if ((flags &amp; ImGuiTextFlags_NoWidthForLargeClippedText) == 0)
                    text_size.x = ImMax(text_size.x, CalcTextSize(line, line_end).x);
                line = line_end + 1;
                lines_skipped++;
            }
            pos.y += lines_skipped * line_height;</span>
        }
<span style = "background-color:#fdd">        text_size.y = (pos - text_pos).y;</span>

<span style = "background-color:#fdd">        ImRect bb(text_pos, text_pos + text_size);
        ItemSize(text_size, 0.0f);
        ItemAdd(bb, 0);
    }</span>
    else
    {
<span style = "background-color:#dfd">        const float wrap_width = wrap_enabled ? CalcWrapWidthForPos(window-&gt;DC.CursorPos, wrap_pos_x) : 0.0f;
        const ImVec2 text_size = CalcTextSize(text_begin, text_end, false, wrap_width);</span>

<span style = "background-color:#dfd">        ImRect bb(text_pos, text_pos + text_size);
        ItemSize(text_size, 0.0f);
        if (!ItemAdd(bb, 0))</span>
<span style = "background-color:#fdd">            return;</span>

        // Render (we don't hide text after ## in this end-user function)
<span style = "background-color:#dfd">        RenderTextWrapped(bb.Min, text_begin, text_end, wrap_width);</span>
    }
<span style = "background-color:#dfd">}</span>

void ImGui::TextUnformatted(const char* text, const char* text_end)
<span style = "background-color:#fdd">{
    TextEx(text, text_end, ImGuiTextFlags_NoWidthForLargeClippedText);
}</span>

void ImGui::Text(const char* fmt, ...)
<span style = "background-color:#dfd">{</span>
    va_list args;
<span style = "background-color:#dfd">    va_start(args, fmt);
    TextV(fmt, args);
    va_end(args);
}</span>

void ImGui::TextV(const char* fmt, va_list args)
<span style = "background-color:#dfd">{
    ImGuiWindow* window = GetCurrentWindow();
    if (window-&gt;SkipItems)</span>
<span style = "background-color:#fdd">        return;</span>

    // FIXME-OPT: Handle the %s shortcut?
<span style = "background-color:#dfd">    ImGuiContext&amp; g = *GImGui;
    const char* text_end = g.TempBuffer + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);
    TextEx(g.TempBuffer, text_end, ImGuiTextFlags_NoWidthForLargeClippedText);
}</span>

void ImGui::TextColored(const ImVec4&amp; col, const char* fmt, ...)
<span style = "background-color:#dfd">{</span>
    va_list args;
<span style = "background-color:#dfd">    va_start(args, fmt);
    TextColoredV(col, fmt, args);
    va_end(args);
}</span>

void ImGui::TextColoredV(const ImVec4&amp; col, const char* fmt, va_list args)
<span style = "background-color:#dfd">{
    PushStyleColor(ImGuiCol_Text, col);
    if (fmt[0] == '%' &amp;&amp; fmt[1] == 's' &amp;&amp; fmt[2] == 0)</span>
<span style = "background-color:#fdd">        TextEx(va_arg(args, const char*), NULL, ImGuiTextFlags_NoWidthForLargeClippedText); // Skip formatting</span>
    else
<span style = "background-color:#dfd">        TextV(fmt, args);
    PopStyleColor();
}</span>

void ImGui::TextDisabled(const char* fmt, ...)
<span style = "background-color:#fdd">{</span>
    va_list args;
<span style = "background-color:#fdd">    va_start(args, fmt);
    TextDisabledV(fmt, args);
    va_end(args);
}</span>

void ImGui::TextDisabledV(const char* fmt, va_list args)
<span style = "background-color:#fdd">{
    ImGuiContext&amp; g = *GImGui;
    PushStyleColor(ImGuiCol_Text, g.Style.Colors[ImGuiCol_TextDisabled]);
    if (fmt[0] == '%' &amp;&amp; fmt[1] == 's' &amp;&amp; fmt[2] == 0)
        TextEx(va_arg(args, const char*), NULL, ImGuiTextFlags_NoWidthForLargeClippedText); // Skip formatting</span>
    else
<span style = "background-color:#fdd">        TextV(fmt, args);
    PopStyleColor();
}</span>

void ImGui::TextWrapped(const char* fmt, ...)
<span style = "background-color:#fdd">{</span>
    va_list args;
<span style = "background-color:#fdd">    va_start(args, fmt);
    TextWrappedV(fmt, args);
    va_end(args);
}</span>

void ImGui::TextWrappedV(const char* fmt, va_list args)
<span style = "background-color:#fdd">{
    ImGuiContext&amp; g = *GImGui;
    bool need_backup = (g.CurrentWindow-&gt;DC.TextWrapPos &lt; 0.0f);  // Keep existing wrap position if one is already set
    if (need_backup)
        PushTextWrapPos(0.0f);
    if (fmt[0] == '%' &amp;&amp; fmt[1] == 's' &amp;&amp; fmt[2] == 0)
        TextEx(va_arg(args, const char*), NULL, ImGuiTextFlags_NoWidthForLargeClippedText); // Skip formatting</span>
    else
<span style = "background-color:#fdd">        TextV(fmt, args);
    if (need_backup)
        PopTextWrapPos();
}</span>

void ImGui::LabelText(const char* label, const char* fmt, ...)
<span style = "background-color:#fdd">{</span>
    va_list args;
<span style = "background-color:#fdd">    va_start(args, fmt);
    LabelTextV(label, fmt, args);
    va_end(args);
}</span>

// Add a label+text combo aligned to other label+value widgets
void ImGui::LabelTextV(const char* label, const char* fmt, va_list args)
<span style = "background-color:#fdd">{
    ImGuiWindow* window = GetCurrentWindow();
    if (window-&gt;SkipItems)
        return;</span>

<span style = "background-color:#fdd">    ImGuiContext&amp; g = *GImGui;
    const ImGuiStyle&amp; style = g.Style;
    const float w = CalcItemWidth();</span>

<span style = "background-color:#fdd">    const char* value_text_begin = &amp;g.TempBuffer[0];
    const char* value_text_end = value_text_begin + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);
    const ImVec2 value_size = CalcTextSize(value_text_begin, value_text_end, false);
    const ImVec2 label_size = CalcTextSize(label, NULL, true);</span>

<span style = "background-color:#fdd">    const ImVec2 pos = window-&gt;DC.CursorPos;
    const ImRect value_bb(pos, pos + ImVec2(w, value_size.y + style.FramePadding.y * 2));
    const ImRect total_bb(pos, pos + ImVec2(w + (label_size.x &gt; 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f), ImMax(value_size.y, label_size.y) + style.FramePadding.y * 2));
    ItemSize(total_bb, style.FramePadding.y);
    if (!ItemAdd(total_bb, 0))
        return;</span>

    // Render
<span style = "background-color:#fdd">    RenderTextClipped(value_bb.Min + style.FramePadding, value_bb.Max, value_text_begin, value_text_end, &amp;value_size, ImVec2(0.0f, 0.0f));
    if (label_size.x &gt; 0.0f)
        RenderText(ImVec2(value_bb.Max.x + style.ItemInnerSpacing.x, value_bb.Min.y + style.FramePadding.y), label);
}</span>

void ImGui::BulletText(const char* fmt, ...)
<span style = "background-color:#fdd">{</span>
    va_list args;
<span style = "background-color:#fdd">    va_start(args, fmt);
    BulletTextV(fmt, args);
    va_end(args);
}</span>

// Text with a little bullet aligned to the typical tree node.
void ImGui::BulletTextV(const char* fmt, va_list args)
<span style = "background-color:#fdd">{
    ImGuiWindow* window = GetCurrentWindow();
    if (window-&gt;SkipItems)
        return;</span>

<span style = "background-color:#fdd">    ImGuiContext&amp; g = *GImGui;
    const ImGuiStyle&amp; style = g.Style;</span>

<span style = "background-color:#fdd">    const char* text_begin = g.TempBuffer;
    const char* text_end = text_begin + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);
    const ImVec2 label_size = CalcTextSize(text_begin, text_end, false);
    const ImVec2 total_size = ImVec2(g.FontSize + (label_size.x &gt; 0.0f ? (label_size.x + style.FramePadding.x * 2) : 0.0f), label_size.y);  // Empty text doesn't add padding
    ImVec2 pos = window-&gt;DC.CursorPos;
    pos.y += window-&gt;DC.CurrLineTextBaseOffset;
    ItemSize(total_size, 0.0f);
    const ImRect bb(pos, pos + total_size);
    if (!ItemAdd(bb, 0))
        return;</span>

    // Render
<span style = "background-color:#fdd">    ImU32 text_col = GetColorU32(ImGuiCol_Text);
    RenderBullet(window-&gt;DrawList, bb.Min + ImVec2(style.FramePadding.x + g.FontSize * 0.5f, g.FontSize * 0.5f), text_col);
    RenderText(bb.Min + ImVec2(g.FontSize + style.FramePadding.x * 2, 0.0f), text_begin, text_end, false);
}</span>

//-------------------------------------------------------------------------
// [SECTION] Widgets: Main
//-------------------------------------------------------------------------
// - ButtonBehavior() [Internal]
// - Button()
// - SmallButton()
// - InvisibleButton()
// - ArrowButton()
// - CloseButton() [Internal]
// - CollapseButton() [Internal]
// - GetWindowScrollbarID() [Internal]
// - GetWindowScrollbarRect() [Internal]
// - Scrollbar() [Internal]
// - ScrollbarEx() [Internal]
// - Image()
// - ImageButton()
// - Checkbox()
// - CheckboxFlagsT() [Internal]
// - CheckboxFlags()
// - RadioButton()
// - ProgressBar()
// - Bullet()
//-------------------------------------------------------------------------

// The ButtonBehavior() function is key to many interactions and used by many/most widgets.
// Because we handle so many cases (keyboard/gamepad navigation, drag and drop) and many specific behavior (via ImGuiButtonFlags_),
// this code is a little complex.
// By far the most common path is interacting with the Mouse using the default ImGuiButtonFlags_PressedOnClickRelease button behavior.
// See the series of events below and the corresponding state reported by dear imgui:
//------------------------------------------------------------------------------------------------------------------------------------------------
// with PressedOnClickRelease:             return-value  IsItemHovered()  IsItemActive()  IsItemActivated()  IsItemDeactivated()  IsItemClicked()
//   Frame N+0 (mouse is outside bb)        -             -                -               -                  -                    -
//   Frame N+1 (mouse moves inside bb)      -             true             -               -                  -                    -
//   Frame N+2 (mouse button is down)       -             true             true            true               -                    true
//   Frame N+3 (mouse button is down)       -             true             true            -                  -                    -
//   Frame N+4 (mouse moves outside bb)     -             -                true            -                  -                    -
//   Frame N+5 (mouse moves inside bb)      -             true             true            -                  -                    -
//   Frame N+6 (mouse button is released)   true          true             -               -                  true                 -
//   Frame N+7 (mouse button is released)   -             true             -               -                  -                    -
//   Frame N+8 (mouse moves outside bb)     -             -                -               -                  -                    -
//------------------------------------------------------------------------------------------------------------------------------------------------
// with PressedOnClick:                    return-value  IsItemHovered()  IsItemActive()  IsItemActivated()  IsItemDeactivated()  IsItemClicked()
//   Frame N+2 (mouse button is down)       true          true             true            true               -                    true
//   Frame N+3 (mouse button is down)       -             true             true            -                  -                    -
//   Frame N+6 (mouse button is released)   -             true             -               -                  true                 -
//   Frame N+7 (mouse button is released)   -             true             -               -                  -                    -
//------------------------------------------------------------------------------------------------------------------------------------------------
// with PressedOnRelease:                  return-value  IsItemHovered()  IsItemActive()  IsItemActivated()  IsItemDeactivated()  IsItemClicked()
//   Frame N+2 (mouse button is down)       -             true             -               -                  -                    true
//   Frame N+3 (mouse button is down)       -             true             -               -                  -                    -
//   Frame N+6 (mouse button is released)   true          true             -               -                  -                    -
//   Frame N+7 (mouse button is released)   -             true             -               -                  -                    -
//------------------------------------------------------------------------------------------------------------------------------------------------
// with PressedOnDoubleClick:              return-value  IsItemHovered()  IsItemActive()  IsItemActivated()  IsItemDeactivated()  IsItemClicked()
//   Frame N+0 (mouse button is down)       -             true             -               -                  -                    true
//   Frame N+1 (mouse button is down)       -             true             -               -                  -                    -
//   Frame N+2 (mouse button is released)   -             true             -               -                  -                    -
//   Frame N+3 (mouse button is released)   -             true             -               -                  -                    -
//   Frame N+4 (mouse button is down)       true          true             true            true               -                    true
//   Frame N+5 (mouse button is down)       -             true             true            -                  -                    -
//   Frame N+6 (mouse button is released)   -             true             -               -                  true                 -
//   Frame N+7 (mouse button is released)   -             true             -               -                  -                    -
//------------------------------------------------------------------------------------------------------------------------------------------------
// Note that some combinations are supported,
// - PressedOnDragDropHold can generally be associated with any flag.
// - PressedOnDoubleClick can be associated by PressedOnClickRelease/PressedOnRelease, in which case the second release event won't be reported.
//------------------------------------------------------------------------------------------------------------------------------------------------
// The behavior of the return-value changes when ImGuiButtonFlags_Repeat is set:
//                                         Repeat+                  Repeat+           Repeat+             Repeat+
//                                         PressedOnClickRelease    PressedOnClick    PressedOnRelease    PressedOnDoubleClick
//-------------------------------------------------------------------------------------------------------------------------------------------------
//   Frame N+0 (mouse button is down)       -                        true              -                   true
//   ...                                    -                        -                 -                   -
//   Frame N + RepeatDelay                  true                     true              -                   true
//   ...                                    -                        -                 -                   -
//   Frame N + RepeatDelay + RepeatRate*N   true                     true              -                   true
//-------------------------------------------------------------------------------------------------------------------------------------------------

bool ImGui::ButtonBehavior(const ImRect&amp; bb, ImGuiID id, bool* out_hovered, bool* out_held, ImGuiButtonFlags flags)
<span style = "background-color:#dfd">{
    ImGuiContext&amp; g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();</span>

    // Default only reacts to left mouse button
<span style = "background-color:#dfd">    if ((flags &amp; ImGuiButtonFlags_MouseButtonMask_) == 0)
        flags |= ImGuiButtonFlags_MouseButtonDefault_;</span>

    // Default behavior requires click + release inside bounding box
<span style = "background-color:#dfd">    if ((flags &amp; ImGuiButtonFlags_PressedOnMask_) == 0)
        flags |= ImGuiButtonFlags_PressedOnDefault_;</span>

<span style = "background-color:#dfd">    ImGuiWindow* backup_hovered_window = g.HoveredWindow;
    const bool flatten_hovered_children = (flags &amp; ImGuiButtonFlags_FlattenChildren) &amp;&amp; g.HoveredWindow &amp;&amp; g.HoveredWindow-&gt;RootWindow == window;
    if (flatten_hovered_children)
        g.HoveredWindow = window;</span>

#ifdef IMGUI_ENABLE_TEST_ENGINE
    if (id != 0 &amp;&amp; g.LastItemData.ID != id)
        IMGUI_TEST_ENGINE_ITEM_ADD(bb, id);
#endif

<span style = "background-color:#dfd">    bool pressed = false;
    bool hovered = ItemHoverable(bb, id);</span>

    // Drag source doesn't report as hovered
<span style = "background-color:#dfd">    if (hovered &amp;&amp; g.DragDropActive &amp;&amp; g.DragDropPayload.SourceId == id &amp;&amp; !(g.DragDropSourceFlags &amp; ImGuiDragDropFlags_SourceNoDisableHover))</span>
<span style = "background-color:#fdd">        hovered = false;</span>

    // Special mode for Drag and Drop where holding button pressed for a long time while dragging another item triggers the button
<span style = "background-color:#dfd">    if (g.DragDropActive &amp;&amp; (flags &amp; ImGuiButtonFlags_PressedOnDragDropHold) &amp;&amp; !(g.DragDropSourceFlags &amp; ImGuiDragDropFlags_SourceNoHoldToOpenOthers))</span>
<span style = "background-color:#fdd">        if (IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))</span>
        {
<span style = "background-color:#fdd">            hovered = true;
            SetHoveredID(id);
            if (g.HoveredIdTimer - g.IO.DeltaTime &lt;= DRAGDROP_HOLD_TO_OPEN_TIMER &amp;&amp; g.HoveredIdTimer &gt;= DRAGDROP_HOLD_TO_OPEN_TIMER)</span>
            {
<span style = "background-color:#fdd">                pressed = true;
                g.DragDropHoldJustPressedId = id;
                FocusWindow(window);</span>
            }
        }

<span style = "background-color:#dfd">    if (flatten_hovered_children)
        g.HoveredWindow = backup_hovered_window;</span>

    // AllowOverlap mode (rarely used) requires previous frame HoveredId to be null or to match. This allows using patterns where a later submitted widget overlaps a previous one.
<span style = "background-color:#dfd">    if (hovered &amp;&amp; (flags &amp; ImGuiButtonFlags_AllowItemOverlap) &amp;&amp; (g.HoveredIdPreviousFrame != id &amp;&amp; g.HoveredIdPreviousFrame != 0))</span>
<span style = "background-color:#fdd">        hovered = false;</span>

    // Mouse handling
<span style = "background-color:#dfd">    if (hovered)</span>
    {
<span style = "background-color:#dfd">        if (!(flags &amp; ImGuiButtonFlags_NoKeyModifiers) || (!g.IO.KeyCtrl &amp;&amp; !g.IO.KeyShift &amp;&amp; !g.IO.KeyAlt))</span>
        {
            // Poll buttons
<span style = "background-color:#dfd">            int mouse_button_clicked = -1;
            int mouse_button_released = -1;
            if ((flags &amp; ImGuiButtonFlags_MouseButtonLeft) &amp;&amp; g.IO.MouseClicked[0])         { mouse_button_clicked = 0; }
            else if ((flags &amp; ImGuiButtonFlags_MouseButtonRight) &amp;&amp; g.IO.MouseClicked[1])   { mouse_button_clicked = 1; }
            else if ((flags &amp; ImGuiButtonFlags_MouseButtonMiddle) &amp;&amp; g.IO.MouseClicked[2])  { mouse_button_clicked = 2; }
            if ((flags &amp; ImGuiButtonFlags_MouseButtonLeft) &amp;&amp; g.IO.MouseReleased[0])        { mouse_button_released = 0; }
            else if ((flags &amp; ImGuiButtonFlags_MouseButtonRight) &amp;&amp; g.IO.MouseReleased[1])  { mouse_button_released = 1; }
            else if ((flags &amp; ImGuiButtonFlags_MouseButtonMiddle) &amp;&amp; g.IO.MouseReleased[2]) { mouse_button_released = 2; }</span>

<span style = "background-color:#dfd">            if (mouse_button_clicked != -1 &amp;&amp; g.ActiveId != id)</span>
            {
<span style = "background-color:#dfd">                if (flags &amp; (ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnClickReleaseAnywhere))</span>
                {
<span style = "background-color:#dfd">                    SetActiveID(id, window);
                    g.ActiveIdMouseButton = mouse_button_clicked;
                    if (!(flags &amp; ImGuiButtonFlags_NoNavFocus))
                        SetFocusID(id, window);
                    FocusWindow(window);</span>
                }
<span style = "background-color:#dfd">                if ((flags &amp; ImGuiButtonFlags_PressedOnClick) || ((flags &amp; ImGuiButtonFlags_PressedOnDoubleClick) &amp;&amp; g.IO.MouseClickedCount[mouse_button_clicked] == 2))</span>
                {
<span style = "background-color:#fdd">                    pressed = true;
                    if (flags &amp; ImGuiButtonFlags_NoHoldingActiveId)
                        ClearActiveID();</span>
                    else
<span style = "background-color:#fdd">                        SetActiveID(id, window); // Hold on ID
                    if (!(flags &amp; ImGuiButtonFlags_NoNavFocus))
                        SetFocusID(id, window);
                    g.ActiveIdMouseButton = mouse_button_clicked;
                    FocusWindow(window);</span>
                }
            }
<span style = "background-color:#dfd">            if ((flags &amp; ImGuiButtonFlags_PressedOnRelease) &amp;&amp; mouse_button_released != -1)</span>
            {
                // Repeat mode trumps on release behavior
<span style = "background-color:#fdd">                const bool has_repeated_at_least_once = (flags &amp; ImGuiButtonFlags_Repeat) &amp;&amp; g.IO.MouseDownDurationPrev[mouse_button_released] &gt;= g.IO.KeyRepeatDelay;
                if (!has_repeated_at_least_once)
                    pressed = true;
                if (!(flags &amp; ImGuiButtonFlags_NoNavFocus))
                    SetFocusID(id, window);
                ClearActiveID();</span>
            }

            // 'Repeat' mode acts when held regardless of _PressedOn flags (see table above).
            // Relies on repeat logic of IsMouseClicked() but we may as well do it ourselves if we end up exposing finer RepeatDelay/RepeatRate settings.
<span style = "background-color:#dfd">            if (g.ActiveId == id &amp;&amp; (flags &amp; ImGuiButtonFlags_Repeat))</span>
<span style = "background-color:#fdd">                if (g.IO.MouseDownDuration[g.ActiveIdMouseButton] &gt; 0.0f &amp;&amp; IsMouseClicked(g.ActiveIdMouseButton, true))
                    pressed = true;</span>
        }

<span style = "background-color:#dfd">        if (pressed)</span>
<span style = "background-color:#fdd">            g.NavDisableHighlight = true;</span>
    }

    // Gamepad/Keyboard navigation
    // We report navigated item as hovered but we don't set g.HoveredId to not interfere with mouse.
<span style = "background-color:#dfd">    if (g.NavId == id &amp;&amp; !g.NavDisableHighlight &amp;&amp; g.NavDisableMouseHover &amp;&amp; (g.ActiveId == 0 || g.ActiveId == id || g.ActiveId == window-&gt;MoveId))</span>
<span style = "background-color:#fdd">        if (!(flags &amp; ImGuiButtonFlags_NoHoveredOnFocus))
            hovered = true;</span>
<span style = "background-color:#dfd">    if (g.NavActivateDownId == id)</span>
    {
<span style = "background-color:#fdd">        bool nav_activated_by_code = (g.NavActivateId == id);
        bool nav_activated_by_inputs = IsNavInputTest(ImGuiNavInput_Activate, (flags &amp; ImGuiButtonFlags_Repeat) ? ImGuiInputReadMode_Repeat : ImGuiInputReadMode_Pressed);
        if (nav_activated_by_code || nav_activated_by_inputs)</span>
        {
            // Set active id so it can be queried by user via IsItemActive(), equivalent of holding the mouse button.
<span style = "background-color:#fdd">            pressed = true;
            SetActiveID(id, window);
            g.ActiveIdSource = ImGuiInputSource_Nav;
            if (!(flags &amp; ImGuiButtonFlags_NoNavFocus))
                SetFocusID(id, window);</span>
        }
    }

    // Process while held
<span style = "background-color:#dfd">    bool held = false;
    if (g.ActiveId == id)</span>
    {
<span style = "background-color:#dfd">        if (g.ActiveIdSource == ImGuiInputSource_Mouse)</span>
        {
<span style = "background-color:#dfd">            if (g.ActiveIdIsJustActivated)
                g.ActiveIdClickOffset = g.IO.MousePos - bb.Min;</span>

<span style = "background-color:#dfd">            const int mouse_button = g.ActiveIdMouseButton;
            IM_ASSERT(mouse_button &gt;= 0 &amp;&amp; mouse_button &lt; ImGuiMouseButton_COUNT);
            if (g.IO.MouseDown[mouse_button])</span>
            {
<span style = "background-color:#dfd">                held = true;
            }</span>
            else
            {
<span style = "background-color:#dfd">                bool release_in = hovered &amp;&amp; (flags &amp; ImGuiButtonFlags_PressedOnClickRelease) != 0;
                bool release_anywhere = (flags &amp; ImGuiButtonFlags_PressedOnClickReleaseAnywhere) != 0;
                if ((release_in || release_anywhere) &amp;&amp; !g.DragDropActive)</span>
                {
                    // Report as pressed when releasing the mouse (this is the most common path)
<span style = "background-color:#dfd">                    bool is_double_click_release = (flags &amp; ImGuiButtonFlags_PressedOnDoubleClick) &amp;&amp; g.IO.MouseReleased[mouse_button] &amp;&amp; g.IO.MouseClickedLastCount[mouse_button] == 2;
                    bool is_repeating_already = (flags &amp; ImGuiButtonFlags_Repeat) &amp;&amp; g.IO.MouseDownDurationPrev[mouse_button] &gt;= g.IO.KeyRepeatDelay; // Repeat mode trumps &lt;on release&gt;
                    if (!is_double_click_release &amp;&amp; !is_repeating_already)
                        pressed = true;</span>
                }
<span style = "background-color:#dfd">                ClearActiveID();</span>
            }
<span style = "background-color:#dfd">            if (!(flags &amp; ImGuiButtonFlags_NoNavFocus))
                g.NavDisableHighlight = true;
        }</span>
<span style = "background-color:#fdd">        else if (g.ActiveIdSource == ImGuiInputSource_Nav)</span>
        {
            // When activated using Nav, we hold on the ActiveID until activation button is released
<span style = "background-color:#fdd">            if (g.NavActivateDownId != id)
                ClearActiveID();</span>
        }
<span style = "background-color:#dfd">        if (pressed)
            g.ActiveIdHasBeenPressedBefore = true;</span>
    }

<span style = "background-color:#dfd">    if (out_hovered) *out_hovered = hovered;
    if (out_held) *out_held = held;</span>

<span style = "background-color:#dfd">    return pressed;
}</span>

bool ImGui::ButtonEx(const char* label, const ImVec2&amp; size_arg, ImGuiButtonFlags flags)
<span style = "background-color:#fdd">{
    ImGuiWindow* window = GetCurrentWindow();
    if (window-&gt;SkipItems)
        return false;</span>

<span style = "background-color:#fdd">    ImGuiContext&amp; g = *GImGui;
    const ImGuiStyle&amp; style = g.Style;
    const ImGuiID id = window-&gt;GetID(label);
    const ImVec2 label_size = CalcTextSize(label, NULL, true);</span>

<span style = "background-color:#fdd">    ImVec2 pos = window-&gt;DC.CursorPos;
    if ((flags &amp; ImGuiButtonFlags_AlignTextBaseLine) &amp;&amp; style.FramePadding.y &lt; window-&gt;DC.CurrLineTextBaseOffset) // Try to vertically align buttons that are smaller/have no padding so that text baseline matches (bit hacky, since it shouldn't be a flag)
        pos.y += window-&gt;DC.CurrLineTextBaseOffset - style.FramePadding.y;
    ImVec2 size = CalcItemSize(size_arg, label_size.x + style.FramePadding.x * 2.0f, label_size.y + style.FramePadding.y * 2.0f);</span>

<span style = "background-color:#fdd">    const ImRect bb(pos, pos + size);
    ItemSize(size, style.FramePadding.y);
    if (!ItemAdd(bb, id))
        return false;</span>

<span style = "background-color:#fdd">    if (g.LastItemData.InFlags &amp; ImGuiItemFlags_ButtonRepeat)
        flags |= ImGuiButtonFlags_Repeat;</span>

    bool hovered, held;
<span style = "background-color:#fdd">    bool pressed = ButtonBehavior(bb, id, &amp;hovered, &amp;held, flags);</span>

    // Render
<span style = "background-color:#fdd">    const ImU32 col = GetColorU32((held &amp;&amp; hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);
    RenderNavHighlight(bb, id);
    RenderFrame(bb.Min, bb.Max, col, true, style.FrameRounding);</span>

<span style = "background-color:#fdd">    if (g.LogEnabled)
        LogSetNextTextDecoration("[", "]");
    RenderTextClipped(bb.Min + style.FramePadding, bb.Max - style.FramePadding, label, NULL, &amp;label_size, style.ButtonTextAlign, &amp;bb);</span>

    // Automatically close popups
    //if (pressed &amp;&amp; !(flags &amp; ImGuiButtonFlags_DontClosePopups) &amp;&amp; (window-&gt;Flags &amp; ImGuiWindowFlags_Popup))
    //    CloseCurrentPopup();

    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags);
<span style = "background-color:#fdd">    return pressed;
}</span>

bool ImGui::Button(const char* label, const ImVec2&amp; size_arg)
<span style = "background-color:#fdd">{
    return ButtonEx(label, size_arg, ImGuiButtonFlags_None);
}</span>

// Small buttons fits within text without additional vertical spacing.
bool ImGui::SmallButton(const char* label)
<span style = "background-color:#fdd">{
    ImGuiContext&amp; g = *GImGui;
    float backup_padding_y = g.Style.FramePadding.y;
    g.Style.FramePadding.y = 0.0f;
    bool pressed = ButtonEx(label, ImVec2(0, 0), ImGuiButtonFlags_AlignTextBaseLine);
    g.Style.FramePadding.y = backup_padding_y;
    return pressed;
}</span>

// Tip: use ImGui::PushID()/PopID() to push indices or pointers in the ID stack.
// Then you can keep 'str_id' empty or the same for all your buttons (instead of creating a string based on a non-string id)
bool ImGui::InvisibleButton(const char* str_id, const ImVec2&amp; size_arg, ImGuiButtonFlags flags)
<span style = "background-color:#dfd">{
    ImGuiWindow* window = GetCurrentWindow();
    if (window-&gt;SkipItems)</span>
<span style = "background-color:#fdd">        return false;</span>

    // Cannot use zero-size for InvisibleButton(). Unlike Button() there is not way to fallback using the label size.
<span style = "background-color:#dfd">    IM_ASSERT(size_arg.x != 0.0f &amp;&amp; size_arg.y != 0.0f);</span>

<span style = "background-color:#dfd">    const ImGuiID id = window-&gt;GetID(str_id);
    ImVec2 size = CalcItemSize(size_arg, 0.0f, 0.0f);
    const ImRect bb(window-&gt;DC.CursorPos, window-&gt;DC.CursorPos + size);
    ItemSize(size);
    if (!ItemAdd(bb, id))</span>
<span style = "background-color:#fdd">        return false;</span>

    bool hovered, held;
<span style = "background-color:#dfd">    bool pressed = ButtonBehavior(bb, id, &amp;hovered, &amp;held, flags);</span>

<span style = "background-color:#dfd">    return pressed;
}</span>

bool ImGui::ArrowButtonEx(const char* str_id, ImGuiDir dir, ImVec2 size, ImGuiButtonFlags flags)
<span style = "background-color:#fdd">{
    ImGuiWindow* window = GetCurrentWindow();
    if (window-&gt;SkipItems)
        return false;</span>

<span style = "background-color:#fdd">    ImGuiContext&amp; g = *GImGui;
    const ImGuiID id = window-&gt;GetID(str_id);
    const ImRect bb(window-&gt;DC.CursorPos, window-&gt;DC.CursorPos + size);
    const float default_size = GetFrameHeight();
    ItemSize(size, (size.y &gt;= default_size) ? g.Style.FramePadding.y : -1.0f);
    if (!ItemAdd(bb, id))
        return false;</span>

<span style = "background-color:#fdd">    if (g.LastItemData.InFlags &amp; ImGuiItemFlags_ButtonRepeat)
        flags |= ImGuiButtonFlags_Repeat;</span>

    bool hovered, held;
<span style = "background-color:#fdd">    bool pressed = ButtonBehavior(bb, id, &amp;hovered, &amp;held, flags);</span>

    // Render
<span style = "background-color:#fdd">    const ImU32 bg_col = GetColorU32((held &amp;&amp; hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);
    const ImU32 text_col = GetColorU32(ImGuiCol_Text);
    RenderNavHighlight(bb, id);
    RenderFrame(bb.Min, bb.Max, bg_col, true, g.Style.FrameRounding);
    RenderArrow(window-&gt;DrawList, bb.Min + ImVec2(ImMax(0.0f, (size.x - g.FontSize) * 0.5f), ImMax(0.0f, (size.y - g.FontSize) * 0.5f)), text_col, dir);</span>

<span style = "background-color:#fdd">    return pressed;
}</span>

bool ImGui::ArrowButton(const char* str_id, ImGuiDir dir)
<span style = "background-color:#fdd">{
    float sz = GetFrameHeight();
    return ArrowButtonEx(str_id, dir, ImVec2(sz, sz), ImGuiButtonFlags_None);
}</span>

// Button to close a window
bool ImGui::CloseButton(ImGuiID id, const ImVec2&amp; pos)
<span style = "background-color:#fdd">{
    ImGuiContext&amp; g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;</span>

    // Tweak 1: Shrink hit-testing area if button covers an abnormally large proportion of the visible region. That's in order to facilitate moving the window away. (#3825)
    // This may better be applied as a general hit-rect reduction mechanism for all widgets to ensure the area to move window is always accessible?
<span style = "background-color:#fdd">    const ImRect bb(pos, pos + ImVec2(g.FontSize, g.FontSize) + g.Style.FramePadding * 2.0f);
    ImRect bb_interact = bb;
    const float area_to_visible_ratio = window-&gt;OuterRectClipped.GetArea() / bb.GetArea();
    if (area_to_visible_ratio &lt; 1.5f)
        bb_interact.Expand(ImFloor(bb_interact.GetSize() * -0.25f));</span>

    // Tweak 2: We intentionally allow interaction when clipped so that a mechanical Alt,Right,Activate sequence can always close a window.
    // (this isn't the regular behavior of buttons, but it doesn't affect the user much because navigation tends to keep items visible).
<span style = "background-color:#fdd">    bool is_clipped = !ItemAdd(bb_interact, id);</span>

    bool hovered, held;
<span style = "background-color:#fdd">    bool pressed = ButtonBehavior(bb_interact, id, &amp;hovered, &amp;held);
    if (is_clipped)
        return pressed;</span>

    // Render
    // FIXME: Clarify this mess
<span style = "background-color:#fdd">    ImU32 col = GetColorU32(held ? ImGuiCol_ButtonActive : ImGuiCol_ButtonHovered);
    ImVec2 center = bb.GetCenter();
    if (hovered)
        window-&gt;DrawList-&gt;AddCircleFilled(center, ImMax(2.0f, g.FontSize * 0.5f + 1.0f), col, 12);</span>

<span style = "background-color:#fdd">    float cross_extent = g.FontSize * 0.5f * 0.7071f - 1.0f;
    ImU32 cross_col = GetColorU32(ImGuiCol_Text);
    center -= ImVec2(0.5f, 0.5f);
    window-&gt;DrawList-&gt;AddLine(center + ImVec2(+cross_extent, +cross_extent), center + ImVec2(-cross_extent, -cross_extent), cross_col, 1.0f);
    window-&gt;DrawList-&gt;AddLine(center + ImVec2(+cross_extent, -cross_extent), center + ImVec2(-cross_extent, +cross_extent), cross_col, 1.0f);</span>

<span style = "background-color:#fdd">    return pressed;
}</span>

bool ImGui::CollapseButton(ImGuiID id, const ImVec2&amp; pos)
<span style = "background-color:#dfd">{
    ImGuiContext&amp; g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;</span>

<span style = "background-color:#dfd">    ImRect bb(pos, pos + ImVec2(g.FontSize, g.FontSize) + g.Style.FramePadding * 2.0f);
    ItemAdd(bb, id);</span>
    bool hovered, held;
<span style = "background-color:#dfd">    bool pressed = ButtonBehavior(bb, id, &amp;hovered, &amp;held, ImGuiButtonFlags_None);</span>

    // Render
<span style = "background-color:#dfd">    ImU32 bg_col = GetColorU32((held &amp;&amp; hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);
    ImU32 text_col = GetColorU32(ImGuiCol_Text);
    ImVec2 center = bb.GetCenter();
    if (hovered || held)</span>
<span style = "background-color:#fdd">        window-&gt;DrawList-&gt;AddCircleFilled(center/*+ ImVec2(0.0f, -0.5f)*/, g.FontSize * 0.5f + 1.0f, bg_col, 12);</span>
<span style = "background-color:#dfd">    RenderArrow(window-&gt;DrawList, bb.Min + g.Style.FramePadding, text_col, window-&gt;Collapsed ? ImGuiDir_Right : ImGuiDir_Down, 1.0f);</span>

    // Switch to moving the window after mouse is moved beyond the initial drag threshold
<span style = "background-color:#dfd">    if (IsItemActive() &amp;&amp; IsMouseDragging(0))</span>
<span style = "background-color:#fdd">        StartMouseMovingWindow(window);</span>

<span style = "background-color:#dfd">    return pressed;
}</span>

ImGuiID ImGui::GetWindowScrollbarID(ImGuiWindow* window, ImGuiAxis axis)
<span style = "background-color:#dfd">{
    return window-&gt;GetIDNoKeepAlive(axis == ImGuiAxis_X ? "#SCROLLX" : "#SCROLLY");
}</span>

// Return scrollbar rectangle, must only be called for corresponding axis if window-&gt;ScrollbarX/Y is set.
ImRect ImGui::GetWindowScrollbarRect(ImGuiWindow* window, ImGuiAxis axis)
<span style = "background-color:#dfd">{
    const ImRect outer_rect = window-&gt;Rect();
    const ImRect inner_rect = window-&gt;InnerRect;
    const float border_size = window-&gt;WindowBorderSize;
    const float scrollbar_size = window-&gt;ScrollbarSizes[axis ^ 1]; // (ScrollbarSizes.x = width of Y scrollbar; ScrollbarSizes.y = height of X scrollbar)
    IM_ASSERT(scrollbar_size &gt; 0.0f);
    if (axis == ImGuiAxis_X)</span>
<span style = "background-color:#fdd">        return ImRect(inner_rect.Min.x, ImMax(outer_rect.Min.y, outer_rect.Max.y - border_size - scrollbar_size), inner_rect.Max.x, outer_rect.Max.y);</span>
    else
<span style = "background-color:#dfd">        return ImRect(ImMax(outer_rect.Min.x, outer_rect.Max.x - border_size - scrollbar_size), inner_rect.Min.y, outer_rect.Max.x, inner_rect.Max.y);
}</span>

void ImGui::Scrollbar(ImGuiAxis axis)
<span style = "background-color:#dfd">{
    ImGuiContext&amp; g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;</span>

<span style = "background-color:#dfd">    const ImGuiID id = GetWindowScrollbarID(window, axis);
    KeepAliveID(id);</span>

    // Calculate scrollbar bounding box
<span style = "background-color:#dfd">    ImRect bb = GetWindowScrollbarRect(window, axis);
    ImDrawFlags rounding_corners = ImDrawFlags_RoundCornersNone;
    if (axis == ImGuiAxis_X)</span>
    {
<span style = "background-color:#fdd">        rounding_corners |= ImDrawFlags_RoundCornersBottomLeft;
        if (!window-&gt;ScrollbarY)
            rounding_corners |= ImDrawFlags_RoundCornersBottomRight;
    }</span>
    else
    {
<span style = "background-color:#dfd">        if ((window-&gt;Flags &amp; ImGuiWindowFlags_NoTitleBar) &amp;&amp; !(window-&gt;Flags &amp; ImGuiWindowFlags_MenuBar))
            rounding_corners |= ImDrawFlags_RoundCornersTopRight;
        if (!window-&gt;ScrollbarX)
            rounding_corners |= ImDrawFlags_RoundCornersBottomRight;</span>
    }
<span style = "background-color:#dfd">    float size_avail = window-&gt;InnerRect.Max[axis] - window-&gt;InnerRect.Min[axis];
    float size_contents = window-&gt;ContentSize[axis] + window-&gt;WindowPadding[axis] * 2.0f;
    ScrollbarEx(bb, id, axis, &amp;window-&gt;Scroll[axis], size_avail, size_contents, rounding_corners);
}</span>

// Vertical/Horizontal scrollbar
// The entire piece of code below is rather confusing because:
// - We handle absolute seeking (when first clicking outside the grab) and relative manipulation (afterward or when clicking inside the grab)
// - We store values as normalized ratio and in a form that allows the window content to change while we are holding on a scrollbar
// - We handle both horizontal and vertical scrollbars, which makes the terminology not ideal.
// Still, the code should probably be made simpler..
bool ImGui::ScrollbarEx(const ImRect&amp; bb_frame, ImGuiID id, ImGuiAxis axis, float* p_scroll_v, float size_avail_v, float size_contents_v, ImDrawFlags flags)
<span style = "background-color:#dfd">{
    ImGuiContext&amp; g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (window-&gt;SkipItems)</span>
<span style = "background-color:#fdd">        return false;</span>

<span style = "background-color:#dfd">    const float bb_frame_width = bb_frame.GetWidth();
    const float bb_frame_height = bb_frame.GetHeight();
    if (bb_frame_width &lt;= 0.0f || bb_frame_height &lt;= 0.0f)</span>
<span style = "background-color:#fdd">        return false;</span>

    // When we are too small, start hiding and disabling the grab (this reduce visual noise on very small window and facilitate using the window resize grab)
<span style = "background-color:#dfd">    float alpha = 1.0f;
    if ((axis == ImGuiAxis_Y) &amp;&amp; bb_frame_height &lt; g.FontSize + g.Style.FramePadding.y * 2.0f)</span>
<span style = "background-color:#fdd">        alpha = ImSaturate((bb_frame_height - g.FontSize) / (g.Style.FramePadding.y * 2.0f));</span>
<span style = "background-color:#dfd">    if (alpha &lt;= 0.0f)</span>
<span style = "background-color:#fdd">        return false;</span>

<span style = "background-color:#dfd">    const ImGuiStyle&amp; style = g.Style;
    const bool allow_interaction = (alpha &gt;= 1.0f);</span>

<span style = "background-color:#dfd">    ImRect bb = bb_frame;
    bb.Expand(ImVec2(-ImClamp(IM_FLOOR((bb_frame_width - 2.0f) * 0.5f), 0.0f, 3.0f), -ImClamp(IM_FLOOR((bb_frame_height - 2.0f) * 0.5f), 0.0f, 3.0f)));</span>

    // V denote the main, longer axis of the scrollbar (= height for a vertical scrollbar)
<span style = "background-color:#dfd">    const float scrollbar_size_v = (axis == ImGuiAxis_X) ? bb.GetWidth() : bb.GetHeight();</span>

    // Calculate the height of our grabbable box. It generally represent the amount visible (vs the total scrollable amount)
    // But we maintain a minimum size in pixel to allow for the user to still aim inside.
<span style = "background-color:#dfd">    IM_ASSERT(ImMax(size_contents_v, size_avail_v) &gt; 0.0f); // Adding this assert to check if the ImMax(XXX,1.0f) is still needed. PLEASE CONTACT ME if this triggers.
    const float win_size_v = ImMax(ImMax(size_contents_v, size_avail_v), 1.0f);
    const float grab_h_pixels = ImClamp(scrollbar_size_v * (size_avail_v / win_size_v), style.GrabMinSize, scrollbar_size_v);
    const float grab_h_norm = grab_h_pixels / scrollbar_size_v;</span>

    // Handle input right away. None of the code of Begin() is relying on scrolling position before calling Scrollbar().
<span style = "background-color:#dfd">    bool held = false;
    bool hovered = false;
    ButtonBehavior(bb, id, &amp;hovered, &amp;held, ImGuiButtonFlags_NoNavFocus);</span>

<span style = "background-color:#dfd">    float scroll_max = ImMax(1.0f, size_contents_v - size_avail_v);
    float scroll_ratio = ImSaturate(*p_scroll_v / scroll_max);
    float grab_v_norm = scroll_ratio * (scrollbar_size_v - grab_h_pixels) / scrollbar_size_v; // Grab position in normalized space
    if (held &amp;&amp; allow_interaction &amp;&amp; grab_h_norm &lt; 1.0f)</span>
    {
<span style = "background-color:#fdd">        float scrollbar_pos_v = bb.Min[axis];
        float mouse_pos_v = g.IO.MousePos[axis];</span>

        // Click position in scrollbar normalized space (0.0f-&gt;1.0f)
<span style = "background-color:#fdd">        const float clicked_v_norm = ImSaturate((mouse_pos_v - scrollbar_pos_v) / scrollbar_size_v);
        SetHoveredID(id);</span>

<span style = "background-color:#fdd">        bool seek_absolute = false;
        if (g.ActiveIdIsJustActivated)</span>
        {
            // On initial click calculate the distance between mouse and the center of the grab
<span style = "background-color:#fdd">            seek_absolute = (clicked_v_norm &lt; grab_v_norm || clicked_v_norm &gt; grab_v_norm + grab_h_norm);
            if (seek_absolute)
                g.ScrollbarClickDeltaToGrabCenter = 0.0f;</span>
            else
<span style = "background-color:#fdd">                g.ScrollbarClickDeltaToGrabCenter = clicked_v_norm - grab_v_norm - grab_h_norm * 0.5f;</span>
        }

        // Apply scroll (p_scroll_v will generally point on one member of window-&gt;Scroll)
        // It is ok to modify Scroll here because we are being called in Begin() after the calculation of ContentSize and before setting up our starting position
<span style = "background-color:#fdd">        const float scroll_v_norm = ImSaturate((clicked_v_norm - g.ScrollbarClickDeltaToGrabCenter - grab_h_norm * 0.5f) / (1.0f - grab_h_norm));
        *p_scroll_v = IM_ROUND(scroll_v_norm * scroll_max);//(win_size_contents_v - win_size_v));</span>

        // Update values for rendering
<span style = "background-color:#fdd">        scroll_ratio = ImSaturate(*p_scroll_v / scroll_max);
        grab_v_norm = scroll_ratio * (scrollbar_size_v - grab_h_pixels) / scrollbar_size_v;</span>

        // Update distance to grab now that we have seeked and saturated
<span style = "background-color:#fdd">        if (seek_absolute)
            g.ScrollbarClickDeltaToGrabCenter = clicked_v_norm - grab_v_norm - grab_h_norm * 0.5f;</span>
    }

    // Render
<span style = "background-color:#dfd">    const ImU32 bg_col = GetColorU32(ImGuiCol_ScrollbarBg);
    const ImU32 grab_col = GetColorU32(held ? ImGuiCol_ScrollbarGrabActive : hovered ? ImGuiCol_ScrollbarGrabHovered : ImGuiCol_ScrollbarGrab, alpha);
    window-&gt;DrawList-&gt;AddRectFilled(bb_frame.Min, bb_frame.Max, bg_col, window-&gt;WindowRounding, flags);
    ImRect grab_rect;
    if (axis == ImGuiAxis_X)</span>
<span style = "background-color:#fdd">        grab_rect = ImRect(ImLerp(bb.Min.x, bb.Max.x, grab_v_norm), bb.Min.y, ImLerp(bb.Min.x, bb.Max.x, grab_v_norm) + grab_h_pixels, bb.Max.y);</span>
    else
<span style = "background-color:#dfd">        grab_rect = ImRect(bb.Min.x, ImLerp(bb.Min.y, bb.Max.y, grab_v_norm), bb.Max.x, ImLerp(bb.Min.y, bb.Max.y, grab_v_norm) + grab_h_pixels);
    window-&gt;DrawList-&gt;AddRectFilled(grab_rect.Min, grab_rect.Max, grab_col, style.ScrollbarRounding);</span>

<span style = "background-color:#dfd">    return held;
}</span>

void ImGui::Image(ImTextureID user_texture_id, const ImVec2&amp; size, const ImVec2&amp; uv0, const ImVec2&amp; uv1, const ImVec4&amp; tint_col, const ImVec4&amp; border_col)
<span style = "background-color:#fdd">{
    ImGuiWindow* window = GetCurrentWindow();
    if (window-&gt;SkipItems)
        return;</span>

<span style = "background-color:#fdd">    ImRect bb(window-&gt;DC.CursorPos, window-&gt;DC.CursorPos + size);
    if (border_col.w &gt; 0.0f)
        bb.Max += ImVec2(2, 2);
    ItemSize(bb);
    if (!ItemAdd(bb, 0))
        return;</span>

<span style = "background-color:#fdd">    if (border_col.w &gt; 0.0f)</span>
    {
<span style = "background-color:#fdd">        window-&gt;DrawList-&gt;AddRect(bb.Min, bb.Max, GetColorU32(border_col), 0.0f);
        window-&gt;DrawList-&gt;AddImage(user_texture_id, bb.Min + ImVec2(1, 1), bb.Max - ImVec2(1, 1), uv0, uv1, GetColorU32(tint_col));
    }</span>
    else
    {
<span style = "background-color:#fdd">        window-&gt;DrawList-&gt;AddImage(user_texture_id, bb.Min, bb.Max, uv0, uv1, GetColorU32(tint_col));</span>
    }
<span style = "background-color:#fdd">}</span>

// ImageButton() is flawed as 'id' is always derived from 'texture_id' (see #2464 #1390)
// We provide this internal helper to write your own variant while we figure out how to redesign the public ImageButton() API.
bool ImGui::ImageButtonEx(ImGuiID id, ImTextureID texture_id, const ImVec2&amp; size, const ImVec2&amp; uv0, const ImVec2&amp; uv1, const ImVec2&amp; padding, const ImVec4&amp; bg_col, const ImVec4&amp; tint_col)
<span style = "background-color:#fdd">{
    ImGuiContext&amp; g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();
    if (window-&gt;SkipItems)
        return false;</span>

<span style = "background-color:#fdd">    const ImRect bb(window-&gt;DC.CursorPos, window-&gt;DC.CursorPos + size + padding * 2);
    ItemSize(bb);
    if (!ItemAdd(bb, id))
        return false;</span>

    bool hovered, held;
<span style = "background-color:#fdd">    bool pressed = ButtonBehavior(bb, id, &amp;hovered, &amp;held);</span>

    // Render
<span style = "background-color:#fdd">    const ImU32 col = GetColorU32((held &amp;&amp; hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);
    RenderNavHighlight(bb, id);
    RenderFrame(bb.Min, bb.Max, col, true, ImClamp((float)ImMin(padding.x, padding.y), 0.0f, g.Style.FrameRounding));
    if (bg_col.w &gt; 0.0f)
        window-&gt;DrawList-&gt;AddRectFilled(bb.Min + padding, bb.Max - padding, GetColorU32(bg_col));
    window-&gt;DrawList-&gt;AddImage(texture_id, bb.Min + padding, bb.Max - padding, uv0, uv1, GetColorU32(tint_col));</span>

<span style = "background-color:#fdd">    return pressed;
}</span>

// frame_padding &lt; 0: uses FramePadding from style (default)
// frame_padding = 0: no framing
// frame_padding &gt; 0: set framing size
bool ImGui::ImageButton(ImTextureID user_texture_id, const ImVec2&amp; size, const ImVec2&amp; uv0, const ImVec2&amp; uv1, int frame_padding, const ImVec4&amp; bg_col, const ImVec4&amp; tint_col)
<span style = "background-color:#fdd">{
    ImGuiContext&amp; g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (window-&gt;SkipItems)
        return false;</span>

    // Default to using texture ID as ID. User can still push string/integer prefixes.
<span style = "background-color:#fdd">    PushID((void*)(intptr_t)user_texture_id);
    const ImGuiID id = window-&gt;GetID("#image");
    PopID();</span>

<span style = "background-color:#fdd">    const ImVec2 padding = (frame_padding &gt;= 0) ? ImVec2((float)frame_padding, (float)frame_padding) : g.Style.FramePadding;
    return ImageButtonEx(id, user_texture_id, size, uv0, uv1, padding, bg_col, tint_col);
}</span>

bool ImGui::Checkbox(const char* label, bool* v)
<span style = "background-color:#fdd">{
    ImGuiWindow* window = GetCurrentWindow();
    if (window-&gt;SkipItems)
        return false;</span>

<span style = "background-color:#fdd">    ImGuiContext&amp; g = *GImGui;
    const ImGuiStyle&amp; style = g.Style;
    const ImGuiID id = window-&gt;GetID(label);
    const ImVec2 label_size = CalcTextSize(label, NULL, true);</span>

<span style = "background-color:#fdd">    const float square_sz = GetFrameHeight();
    const ImVec2 pos = window-&gt;DC.CursorPos;
    const ImRect total_bb(pos, pos + ImVec2(square_sz + (label_size.x &gt; 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f), label_size.y + style.FramePadding.y * 2.0f));
    ItemSize(total_bb, style.FramePadding.y);
    if (!ItemAdd(total_bb, id))</span>
    {
        IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags | ImGuiItemStatusFlags_Checkable | (*v ? ImGuiItemStatusFlags_Checked : 0));
<span style = "background-color:#fdd">        return false;</span>
    }

    bool hovered, held;
<span style = "background-color:#fdd">    bool pressed = ButtonBehavior(total_bb, id, &amp;hovered, &amp;held);
    if (pressed)</span>
    {
<span style = "background-color:#fdd">        *v = !(*v);
        MarkItemEdited(id);</span>
    }

<span style = "background-color:#fdd">    const ImRect check_bb(pos, pos + ImVec2(square_sz, square_sz));
    RenderNavHighlight(total_bb, id);
    RenderFrame(check_bb.Min, check_bb.Max, GetColorU32((held &amp;&amp; hovered) ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg), true, style.FrameRounding);
    ImU32 check_col = GetColorU32(ImGuiCol_CheckMark);
    bool mixed_value = (g.LastItemData.InFlags &amp; ImGuiItemFlags_MixedValue) != 0;
    if (mixed_value)</span>
    {
        // Undocumented tristate/mixed/indeterminate checkbox (#2644)
        // This may seem awkwardly designed because the aim is to make ImGuiItemFlags_MixedValue supported by all widgets (not just checkbox)
<span style = "background-color:#fdd">        ImVec2 pad(ImMax(1.0f, IM_FLOOR(square_sz / 3.6f)), ImMax(1.0f, IM_FLOOR(square_sz / 3.6f)));
        window-&gt;DrawList-&gt;AddRectFilled(check_bb.Min + pad, check_bb.Max - pad, check_col, style.FrameRounding);
    }
    else if (*v)</span>
    {
<span style = "background-color:#fdd">        const float pad = ImMax(1.0f, IM_FLOOR(square_sz / 6.0f));
        RenderCheckMark(window-&gt;DrawList, check_bb.Min + ImVec2(pad, pad), check_col, square_sz - pad * 2.0f);</span>
    }

<span style = "background-color:#fdd">    ImVec2 label_pos = ImVec2(check_bb.Max.x + style.ItemInnerSpacing.x, check_bb.Min.y + style.FramePadding.y);
    if (g.LogEnabled)
        LogRenderedText(&amp;label_pos, mixed_value ? "[~]" : *v ? "[x]" : "[ ]");
    if (label_size.x &gt; 0.0f)
        RenderText(label_pos, label);</span>

    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags | ImGuiItemStatusFlags_Checkable | (*v ? ImGuiItemStatusFlags_Checked : 0));
<span style = "background-color:#fdd">    return pressed;
}</span>

template&lt;typename T&gt;
bool ImGui::CheckboxFlagsT(const char* label, T* flags, T flags_value)
<span style = "background-color:#fdd">{
    bool all_on = (*flags &amp; flags_value) == flags_value;
    bool any_on = (*flags &amp; flags_value) != 0;</span>
    bool pressed;
<span style = "background-color:#fdd">    if (!all_on &amp;&amp; any_on)</span>
    {
<span style = "background-color:#fdd">        ImGuiContext&amp; g = *GImGui;
        ImGuiItemFlags backup_item_flags = g.CurrentItemFlags;
        g.CurrentItemFlags |= ImGuiItemFlags_MixedValue;
        pressed = Checkbox(label, &amp;all_on);
        g.CurrentItemFlags = backup_item_flags;
    }</span>
    else
    {
<span style = "background-color:#fdd">        pressed = Checkbox(label, &amp;all_on);</span>

    }
<span style = "background-color:#fdd">    if (pressed)</span>
    {
<span style = "background-color:#fdd">        if (all_on)
            *flags |= flags_value;</span>
        else
<span style = "background-color:#fdd">            *flags &amp;= ~flags_value;</span>
    }
<span style = "background-color:#fdd">    return pressed;
}</span>

bool ImGui::CheckboxFlags(const char* label, int* flags, int flags_value)
<span style = "background-color:#fdd">{
    return CheckboxFlagsT(label, flags, flags_value);
}</span>

bool ImGui::CheckboxFlags(const char* label, unsigned int* flags, unsigned int flags_value)
<span style = "background-color:#fdd">{
    return CheckboxFlagsT(label, flags, flags_value);
}</span>

bool ImGui::CheckboxFlags(const char* label, ImS64* flags, ImS64 flags_value)
<span style = "background-color:#fdd">{
    return CheckboxFlagsT(label, flags, flags_value);
}</span>

bool ImGui::CheckboxFlags(const char* label, ImU64* flags, ImU64 flags_value)
<span style = "background-color:#fdd">{
    return CheckboxFlagsT(label, flags, flags_value);
}</span>

bool ImGui::RadioButton(const char* label, bool active)
<span style = "background-color:#fdd">{
    ImGuiWindow* window = GetCurrentWindow();
    if (window-&gt;SkipItems)
        return false;</span>

<span style = "background-color:#fdd">    ImGuiContext&amp; g = *GImGui;
    const ImGuiStyle&amp; style = g.Style;
    const ImGuiID id = window-&gt;GetID(label);
    const ImVec2 label_size = CalcTextSize(label, NULL, true);</span>

<span style = "background-color:#fdd">    const float square_sz = GetFrameHeight();
    const ImVec2 pos = window-&gt;DC.CursorPos;
    const ImRect check_bb(pos, pos + ImVec2(square_sz, square_sz));
    const ImRect total_bb(pos, pos + ImVec2(square_sz + (label_size.x &gt; 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f), label_size.y + style.FramePadding.y * 2.0f));
    ItemSize(total_bb, style.FramePadding.y);
    if (!ItemAdd(total_bb, id))
        return false;</span>

<span style = "background-color:#fdd">    ImVec2 center = check_bb.GetCenter();
    center.x = IM_ROUND(center.x);
    center.y = IM_ROUND(center.y);
    const float radius = (square_sz - 1.0f) * 0.5f;</span>

    bool hovered, held;
<span style = "background-color:#fdd">    bool pressed = ButtonBehavior(total_bb, id, &amp;hovered, &amp;held);
    if (pressed)
        MarkItemEdited(id);</span>

<span style = "background-color:#fdd">    RenderNavHighlight(total_bb, id);
    window-&gt;DrawList-&gt;AddCircleFilled(center, radius, GetColorU32((held &amp;&amp; hovered) ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg), 16);
    if (active)</span>
    {
<span style = "background-color:#fdd">        const float pad = ImMax(1.0f, IM_FLOOR(square_sz / 6.0f));
        window-&gt;DrawList-&gt;AddCircleFilled(center, radius - pad, GetColorU32(ImGuiCol_CheckMark), 16);</span>
    }

<span style = "background-color:#fdd">    if (style.FrameBorderSize &gt; 0.0f)</span>
    {
<span style = "background-color:#fdd">        window-&gt;DrawList-&gt;AddCircle(center + ImVec2(1, 1), radius, GetColorU32(ImGuiCol_BorderShadow), 16, style.FrameBorderSize);
        window-&gt;DrawList-&gt;AddCircle(center, radius, GetColorU32(ImGuiCol_Border), 16, style.FrameBorderSize);</span>
    }

<span style = "background-color:#fdd">    ImVec2 label_pos = ImVec2(check_bb.Max.x + style.ItemInnerSpacing.x, check_bb.Min.y + style.FramePadding.y);
    if (g.LogEnabled)
        LogRenderedText(&amp;label_pos, active ? "(x)" : "( )");
    if (label_size.x &gt; 0.0f)
        RenderText(label_pos, label);</span>

    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags);
<span style = "background-color:#fdd">    return pressed;
}</span>

// FIXME: This would work nicely if it was a public template, e.g. 'template&lt;T&gt; RadioButton(const char* label, T* v, T v_button)', but I'm not sure how we would expose it..
bool ImGui::RadioButton(const char* label, int* v, int v_button)
<span style = "background-color:#fdd">{
    const bool pressed = RadioButton(label, *v == v_button);
    if (pressed)
        *v = v_button;
    return pressed;
}</span>

// size_arg (for each axis) &lt; 0.0f: align to end, 0.0f: auto, &gt; 0.0f: specified size
void ImGui::ProgressBar(float fraction, const ImVec2&amp; size_arg, const char* overlay)
<span style = "background-color:#fdd">{
    ImGuiWindow* window = GetCurrentWindow();
    if (window-&gt;SkipItems)
        return;</span>

<span style = "background-color:#fdd">    ImGuiContext&amp; g = *GImGui;
    const ImGuiStyle&amp; style = g.Style;</span>

<span style = "background-color:#fdd">    ImVec2 pos = window-&gt;DC.CursorPos;
    ImVec2 size = CalcItemSize(size_arg, CalcItemWidth(), g.FontSize + style.FramePadding.y * 2.0f);
    ImRect bb(pos, pos + size);
    ItemSize(size, style.FramePadding.y);
    if (!ItemAdd(bb, 0))
        return;</span>

    // Render
<span style = "background-color:#fdd">    fraction = ImSaturate(fraction);
    RenderFrame(bb.Min, bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);
    bb.Expand(ImVec2(-style.FrameBorderSize, -style.FrameBorderSize));
    const ImVec2 fill_br = ImVec2(ImLerp(bb.Min.x, bb.Max.x, fraction), bb.Max.y);
    RenderRectFilledRangeH(window-&gt;DrawList, bb, GetColorU32(ImGuiCol_PlotHistogram), 0.0f, fraction, style.FrameRounding);</span>

    // Default displaying the fraction as percentage string, but user can override it
    char overlay_buf[32];
<span style = "background-color:#fdd">    if (!overlay)</span>
    {
<span style = "background-color:#fdd">        ImFormatString(overlay_buf, IM_ARRAYSIZE(overlay_buf), "%.0f%%", fraction * 100 + 0.01f);
        overlay = overlay_buf;</span>
    }

<span style = "background-color:#fdd">    ImVec2 overlay_size = CalcTextSize(overlay, NULL);
    if (overlay_size.x &gt; 0.0f)
        RenderTextClipped(ImVec2(ImClamp(fill_br.x + style.ItemSpacing.x, bb.Min.x, bb.Max.x - overlay_size.x - style.ItemInnerSpacing.x), bb.Min.y), bb.Max, overlay, NULL, &amp;overlay_size, ImVec2(0.0f, 0.5f), &amp;bb);
}</span>

void ImGui::Bullet()
<span style = "background-color:#fdd">{
    ImGuiWindow* window = GetCurrentWindow();
    if (window-&gt;SkipItems)
        return;</span>

<span style = "background-color:#fdd">    ImGuiContext&amp; g = *GImGui;
    const ImGuiStyle&amp; style = g.Style;
    const float line_height = ImMax(ImMin(window-&gt;DC.CurrLineSize.y, g.FontSize + g.Style.FramePadding.y * 2), g.FontSize);
    const ImRect bb(window-&gt;DC.CursorPos, window-&gt;DC.CursorPos + ImVec2(g.FontSize, line_height));
    ItemSize(bb);
    if (!ItemAdd(bb, 0))</span>
    {
<span style = "background-color:#fdd">        SameLine(0, style.FramePadding.x * 2);
        return;</span>
    }

    // Render and stay on same line
<span style = "background-color:#fdd">    ImU32 text_col = GetColorU32(ImGuiCol_Text);
    RenderBullet(window-&gt;DrawList, bb.Min + ImVec2(style.FramePadding.x + g.FontSize * 0.5f, line_height * 0.5f), text_col);
    SameLine(0, style.FramePadding.x * 2.0f);
}</span>

//-------------------------------------------------------------------------
// [SECTION] Widgets: Low-level Layout helpers
//-------------------------------------------------------------------------
// - Spacing()
// - Dummy()
// - NewLine()
// - AlignTextToFramePadding()
// - SeparatorEx() [Internal]
// - Separator()
// - SplitterBehavior() [Internal]
// - ShrinkWidths() [Internal]
//-------------------------------------------------------------------------

void ImGui::Spacing()
<span style = "background-color:#fdd">{
    ImGuiWindow* window = GetCurrentWindow();
    if (window-&gt;SkipItems)
        return;
    ItemSize(ImVec2(0, 0));
}</span>

void ImGui::Dummy(const ImVec2&amp; size)
<span style = "background-color:#fdd">{
    ImGuiWindow* window = GetCurrentWindow();
    if (window-&gt;SkipItems)
        return;</span>

<span style = "background-color:#fdd">    const ImRect bb(window-&gt;DC.CursorPos, window-&gt;DC.CursorPos + size);
    ItemSize(size);
    ItemAdd(bb, 0);
}</span>

void ImGui::NewLine()
<span style = "background-color:#fdd">{
    ImGuiWindow* window = GetCurrentWindow();
    if (window-&gt;SkipItems)
        return;</span>

<span style = "background-color:#fdd">    ImGuiContext&amp; g = *GImGui;
    const ImGuiLayoutType backup_layout_type = window-&gt;DC.LayoutType;
    window-&gt;DC.LayoutType = ImGuiLayoutType_Vertical;
    if (window-&gt;DC.CurrLineSize.y &gt; 0.0f)     // In the event that we are on a line with items that is smaller that FontSize high, we will preserve its height.
        ItemSize(ImVec2(0, 0));</span>
    else
<span style = "background-color:#fdd">        ItemSize(ImVec2(0.0f, g.FontSize));
    window-&gt;DC.LayoutType = backup_layout_type;
}</span>

void ImGui::AlignTextToFramePadding()
<span style = "background-color:#fdd">{
    ImGuiWindow* window = GetCurrentWindow();
    if (window-&gt;SkipItems)
        return;</span>

<span style = "background-color:#fdd">    ImGuiContext&amp; g = *GImGui;
    window-&gt;DC.CurrLineSize.y = ImMax(window-&gt;DC.CurrLineSize.y, g.FontSize + g.Style.FramePadding.y * 2);
    window-&gt;DC.CurrLineTextBaseOffset = ImMax(window-&gt;DC.CurrLineTextBaseOffset, g.Style.FramePadding.y);
}</span>

// Horizontal/vertical separating line
void ImGui::SeparatorEx(ImGuiSeparatorFlags flags)
<span style = "background-color:#fdd">{
    ImGuiWindow* window = GetCurrentWindow();
    if (window-&gt;SkipItems)
        return;</span>

<span style = "background-color:#fdd">    ImGuiContext&amp; g = *GImGui;
    IM_ASSERT(ImIsPowerOfTwo(flags &amp; (ImGuiSeparatorFlags_Horizontal | ImGuiSeparatorFlags_Vertical)));   // Check that only 1 option is selected</span>

<span style = "background-color:#fdd">    float thickness_draw = 1.0f;
    float thickness_layout = 0.0f;
    if (flags &amp; ImGuiSeparatorFlags_Vertical)</span>
    {
        // Vertical separator, for menu bars (use current line height). Not exposed because it is misleading and it doesn't have an effect on regular layout.
<span style = "background-color:#fdd">        float y1 = window-&gt;DC.CursorPos.y;
        float y2 = window-&gt;DC.CursorPos.y + window-&gt;DC.CurrLineSize.y;
        const ImRect bb(ImVec2(window-&gt;DC.CursorPos.x, y1), ImVec2(window-&gt;DC.CursorPos.x + thickness_draw, y2));
        ItemSize(ImVec2(thickness_layout, 0.0f));
        if (!ItemAdd(bb, 0))
            return;</span>

        // Draw
<span style = "background-color:#fdd">        window-&gt;DrawList-&gt;AddLine(ImVec2(bb.Min.x, bb.Min.y), ImVec2(bb.Min.x, bb.Max.y), GetColorU32(ImGuiCol_Separator));
        if (g.LogEnabled)
            LogText(" |");
    }
    else if (flags &amp; ImGuiSeparatorFlags_Horizontal)</span>
    {
        // Horizontal Separator
<span style = "background-color:#fdd">        float x1 = window-&gt;Pos.x;
        float x2 = window-&gt;Pos.x + window-&gt;Size.x;</span>

        // FIXME-WORKRECT: old hack (#205) until we decide of consistent behavior with WorkRect/Indent and Separator
<span style = "background-color:#fdd">        if (g.GroupStack.Size &gt; 0 &amp;&amp; g.GroupStack.back().WindowID == window-&gt;ID)
            x1 += window-&gt;DC.Indent.x;</span>

<span style = "background-color:#fdd">        ImGuiOldColumns* columns = (flags &amp; ImGuiSeparatorFlags_SpanAllColumns) ? window-&gt;DC.CurrentColumns : NULL;
        if (columns)
            PushColumnsBackground();</span>

        // We don't provide our width to the layout so that it doesn't get feed back into AutoFit
<span style = "background-color:#fdd">        const ImRect bb(ImVec2(x1, window-&gt;DC.CursorPos.y), ImVec2(x2, window-&gt;DC.CursorPos.y + thickness_draw));
        ItemSize(ImVec2(0.0f, thickness_layout));
        const bool item_visible = ItemAdd(bb, 0);
        if (item_visible)</span>
        {
            // Draw
<span style = "background-color:#fdd">            window-&gt;DrawList-&gt;AddLine(bb.Min, ImVec2(bb.Max.x, bb.Min.y), GetColorU32(ImGuiCol_Separator));
            if (g.LogEnabled)
                LogRenderedText(&amp;bb.Min, "--------------------------------\n");</span>

        }
<span style = "background-color:#fdd">        if (columns)</span>
        {
<span style = "background-color:#fdd">            PopColumnsBackground();
            columns-&gt;LineMinY = window-&gt;DC.CursorPos.y;</span>
        }
    }
<span style = "background-color:#fdd">}</span>

void ImGui::Separator()
<span style = "background-color:#fdd">{
    ImGuiContext&amp; g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (window-&gt;SkipItems)
        return;</span>

    // Those flags should eventually be overridable by the user
<span style = "background-color:#fdd">    ImGuiSeparatorFlags flags = (window-&gt;DC.LayoutType == ImGuiLayoutType_Horizontal) ? ImGuiSeparatorFlags_Vertical : ImGuiSeparatorFlags_Horizontal;
    flags |= ImGuiSeparatorFlags_SpanAllColumns;
    SeparatorEx(flags);
}</span>

// Using 'hover_visibility_delay' allows us to hide the highlight and mouse cursor for a short time, which can be convenient to reduce visual noise.
bool ImGui::SplitterBehavior(const ImRect&amp; bb, ImGuiID id, ImGuiAxis axis, float* size1, float* size2, float min_size1, float min_size2, float hover_extend, float hover_visibility_delay)
<span style = "background-color:#fdd">{
    ImGuiContext&amp; g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;</span>

<span style = "background-color:#fdd">    const ImGuiItemFlags item_flags_backup = g.CurrentItemFlags;
    g.CurrentItemFlags |= ImGuiItemFlags_NoNav | ImGuiItemFlags_NoNavDefaultFocus;
    bool item_add = ItemAdd(bb, id);
    g.CurrentItemFlags = item_flags_backup;
    if (!item_add)
        return false;</span>

    bool hovered, held;
<span style = "background-color:#fdd">    ImRect bb_interact = bb;
    bb_interact.Expand(axis == ImGuiAxis_Y ? ImVec2(0.0f, hover_extend) : ImVec2(hover_extend, 0.0f));
    ButtonBehavior(bb_interact, id, &amp;hovered, &amp;held, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_AllowItemOverlap);
    if (hovered)
        g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HoveredRect; // for IsItemHovered(), because bb_interact is larger than bb
    if (g.ActiveId != id)
        SetItemAllowOverlap();</span>

<span style = "background-color:#fdd">    if (held || (hovered &amp;&amp; g.HoveredIdPreviousFrame == id &amp;&amp; g.HoveredIdTimer &gt;= hover_visibility_delay))
        SetMouseCursor(axis == ImGuiAxis_Y ? ImGuiMouseCursor_ResizeNS : ImGuiMouseCursor_ResizeEW);</span>

<span style = "background-color:#fdd">    ImRect bb_render = bb;
    if (held)</span>
    {
<span style = "background-color:#fdd">        ImVec2 mouse_delta_2d = g.IO.MousePos - g.ActiveIdClickOffset - bb_interact.Min;
        float mouse_delta = (axis == ImGuiAxis_Y) ? mouse_delta_2d.y : mouse_delta_2d.x;</span>

        // Minimum pane size
<span style = "background-color:#fdd">        float size_1_maximum_delta = ImMax(0.0f, *size1 - min_size1);
        float size_2_maximum_delta = ImMax(0.0f, *size2 - min_size2);
        if (mouse_delta &lt; -size_1_maximum_delta)
            mouse_delta = -size_1_maximum_delta;
        if (mouse_delta &gt; size_2_maximum_delta)
            mouse_delta = size_2_maximum_delta;</span>

        // Apply resize
<span style = "background-color:#fdd">        if (mouse_delta != 0.0f)</span>
        {
<span style = "background-color:#fdd">            if (mouse_delta &lt; 0.0f)
                IM_ASSERT(*size1 + mouse_delta &gt;= min_size1);
            if (mouse_delta &gt; 0.0f)
                IM_ASSERT(*size2 - mouse_delta &gt;= min_size2);
            *size1 += mouse_delta;
            *size2 -= mouse_delta;
            bb_render.Translate((axis == ImGuiAxis_X) ? ImVec2(mouse_delta, 0.0f) : ImVec2(0.0f, mouse_delta));
            MarkItemEdited(id);</span>
        }
    }

    // Render
<span style = "background-color:#fdd">    const ImU32 col = GetColorU32(held ? ImGuiCol_SeparatorActive : (hovered &amp;&amp; g.HoveredIdTimer &gt;= hover_visibility_delay) ? ImGuiCol_SeparatorHovered : ImGuiCol_Separator);
    window-&gt;DrawList-&gt;AddRectFilled(bb_render.Min, bb_render.Max, col, 0.0f);</span>

<span style = "background-color:#fdd">    return held;
}</span>

static int IMGUI_CDECL ShrinkWidthItemComparer(const void* lhs, const void* rhs)
<span style = "background-color:#fdd">{
    const ImGuiShrinkWidthItem* a = (const ImGuiShrinkWidthItem*)lhs;
    const ImGuiShrinkWidthItem* b = (const ImGuiShrinkWidthItem*)rhs;
    if (int d = (int)(b-&gt;Width - a-&gt;Width))
        return d;
    return (b-&gt;Index - a-&gt;Index);
}</span>

// Shrink excess width from a set of item, by removing width from the larger items first.
// Set items Width to -1.0f to disable shrinking this item.
void ImGui::ShrinkWidths(ImGuiShrinkWidthItem* items, int count, float width_excess)
<span style = "background-color:#fdd">{
    if (count == 1)</span>
    {
<span style = "background-color:#fdd">        if (items[0].Width &gt;= 0.0f)
            items[0].Width = ImMax(items[0].Width - width_excess, 1.0f);
        return;</span>
    }
<span style = "background-color:#fdd">    ImQsort(items, (size_t)count, sizeof(ImGuiShrinkWidthItem), ShrinkWidthItemComparer);
    int count_same_width = 1;
    while (width_excess &gt; 0.0f &amp;&amp; count_same_width &lt; count)</span>
    {
<span style = "background-color:#fdd">        while (count_same_width &lt; count &amp;&amp; items[0].Width &lt;= items[count_same_width].Width)
            count_same_width++;
        float max_width_to_remove_per_item = (count_same_width &lt; count &amp;&amp; items[count_same_width].Width &gt;= 0.0f) ? (items[0].Width - items[count_same_width].Width) : (items[0].Width - 1.0f);
        if (max_width_to_remove_per_item &lt;= 0.0f)
            break;
        float width_to_remove_per_item = ImMin(width_excess / count_same_width, max_width_to_remove_per_item);
        for (int item_n = 0; item_n &lt; count_same_width; item_n++)
            items[item_n].Width -= width_to_remove_per_item;
        width_excess -= width_to_remove_per_item * count_same_width;
    }</span>

    // Round width and redistribute remainder left-to-right (could make it an option of the function?)
    // Ensure that e.g. the right-most tab of a shrunk tab-bar always reaches exactly at the same distance from the right-most edge of the tab bar separator.
<span style = "background-color:#fdd">    width_excess = 0.0f;
    for (int n = 0; n &lt; count; n++)</span>
    {
<span style = "background-color:#fdd">        float width_rounded = ImFloor(items[n].Width);
        width_excess += items[n].Width - width_rounded;
        items[n].Width = width_rounded;
    }
    if (width_excess &gt; 0.0f)
        for (int n = 0; n &lt; count; n++)
            if (items[n].Index &lt; (int)(width_excess + 0.01f))
                items[n].Width += 1.0f;
}</span>

//-------------------------------------------------------------------------
// [SECTION] Widgets: ComboBox
//-------------------------------------------------------------------------
// - CalcMaxPopupHeightFromItemCount() [Internal]
// - BeginCombo()
// - BeginComboPopup() [Internal]
// - EndCombo()
// - BeginComboPreview() [Internal]
// - EndComboPreview() [Internal]
// - Combo()
//-------------------------------------------------------------------------

static float CalcMaxPopupHeightFromItemCount(int items_count)
<span style = "background-color:#dfd">{
    ImGuiContext&amp; g = *GImGui;
    if (items_count &lt;= 0)</span>
<span style = "background-color:#fdd">        return FLT_MAX;</span>
<span style = "background-color:#dfd">    return (g.FontSize + g.Style.ItemSpacing.y) * items_count - g.Style.ItemSpacing.y + (g.Style.WindowPadding.y * 2);
}</span>

bool ImGui::BeginCombo(const char* label, const char* preview_value, ImGuiComboFlags flags)
<span style = "background-color:#dfd">{
    ImGuiContext&amp; g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();</span>

<span style = "background-color:#dfd">    ImGuiNextWindowDataFlags backup_next_window_data_flags = g.NextWindowData.Flags;
    g.NextWindowData.ClearFlags(); // We behave like Begin() and need to consume those values
    if (window-&gt;SkipItems)</span>
<span style = "background-color:#fdd">        return false;</span>

<span style = "background-color:#dfd">    const ImGuiStyle&amp; style = g.Style;
    const ImGuiID id = window-&gt;GetID(label);
    IM_ASSERT((flags &amp; (ImGuiComboFlags_NoArrowButton | ImGuiComboFlags_NoPreview)) != (ImGuiComboFlags_NoArrowButton | ImGuiComboFlags_NoPreview)); // Can't use both flags together</span>

<span style = "background-color:#dfd">    const float arrow_size = (flags &amp; ImGuiComboFlags_NoArrowButton) ? 0.0f : GetFrameHeight();
    const ImVec2 label_size = CalcTextSize(label, NULL, true);
    const float w = (flags &amp; ImGuiComboFlags_NoPreview) ? arrow_size : CalcItemWidth();
    const ImRect bb(window-&gt;DC.CursorPos, window-&gt;DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y * 2.0f));
    const ImRect total_bb(bb.Min, bb.Max + ImVec2(label_size.x &gt; 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));
    ItemSize(total_bb, style.FramePadding.y);
    if (!ItemAdd(total_bb, id, &amp;bb))</span>
<span style = "background-color:#fdd">        return false;</span>

    // Open on click
    bool hovered, held;
<span style = "background-color:#dfd">    bool pressed = ButtonBehavior(bb, id, &amp;hovered, &amp;held);
    const ImGuiID popup_id = ImHashStr("##ComboPopup", 0, id);
    bool popup_open = IsPopupOpen(popup_id, ImGuiPopupFlags_None);
    if (pressed &amp;&amp; !popup_open)</span>
    {
<span style = "background-color:#dfd">        OpenPopupEx(popup_id, ImGuiPopupFlags_None);
        popup_open = true;</span>
    }

    // Render shape
<span style = "background-color:#dfd">    const ImU32 frame_col = GetColorU32(hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);
    const float value_x2 = ImMax(bb.Min.x, bb.Max.x - arrow_size);
    RenderNavHighlight(bb, id);
    if (!(flags &amp; ImGuiComboFlags_NoPreview))
        window-&gt;DrawList-&gt;AddRectFilled(bb.Min, ImVec2(value_x2, bb.Max.y), frame_col, style.FrameRounding, (flags &amp; ImGuiComboFlags_NoArrowButton) ? ImDrawFlags_RoundCornersAll : ImDrawFlags_RoundCornersLeft);
    if (!(flags &amp; ImGuiComboFlags_NoArrowButton))</span>
    {
<span style = "background-color:#dfd">        ImU32 bg_col = GetColorU32((popup_open || hovered) ? ImGuiCol_ButtonHovered : ImGuiCol_Button);
        ImU32 text_col = GetColorU32(ImGuiCol_Text);
        window-&gt;DrawList-&gt;AddRectFilled(ImVec2(value_x2, bb.Min.y), bb.Max, bg_col, style.FrameRounding, (w &lt;= arrow_size) ? ImDrawFlags_RoundCornersAll : ImDrawFlags_RoundCornersRight);
        if (value_x2 + arrow_size - style.FramePadding.x &lt;= bb.Max.x)
            RenderArrow(window-&gt;DrawList, ImVec2(value_x2 + style.FramePadding.y, bb.Min.y + style.FramePadding.y), text_col, ImGuiDir_Down, 1.0f);</span>
    }
<span style = "background-color:#dfd">    RenderFrameBorder(bb.Min, bb.Max, style.FrameRounding);</span>

    // Custom preview
<span style = "background-color:#dfd">    if (flags &amp; ImGuiComboFlags_CustomPreview)</span>
    {
<span style = "background-color:#fdd">        g.ComboPreviewData.PreviewRect = ImRect(bb.Min.x, bb.Min.y, value_x2, bb.Max.y);
        IM_ASSERT(preview_value == NULL || preview_value[0] == 0);
        preview_value = NULL;</span>
    }

    // Render preview and label
<span style = "background-color:#dfd">    if (preview_value != NULL &amp;&amp; !(flags &amp; ImGuiComboFlags_NoPreview))</span>
    {
<span style = "background-color:#dfd">        if (g.LogEnabled)</span>
<span style = "background-color:#fdd">            LogSetNextTextDecoration("{", "}");</span>
<span style = "background-color:#dfd">        RenderTextClipped(bb.Min + style.FramePadding, ImVec2(value_x2, bb.Max.y), preview_value, NULL, NULL);</span>
    }
<span style = "background-color:#dfd">    if (label_size.x &gt; 0)
        RenderText(ImVec2(bb.Max.x + style.ItemInnerSpacing.x, bb.Min.y + style.FramePadding.y), label);</span>

<span style = "background-color:#dfd">    if (!popup_open)
        return false;</span>

<span style = "background-color:#dfd">    g.NextWindowData.Flags = backup_next_window_data_flags;
    return BeginComboPopup(popup_id, bb, flags);
}</span>

bool ImGui::BeginComboPopup(ImGuiID popup_id, const ImRect&amp; bb, ImGuiComboFlags flags)
<span style = "background-color:#dfd">{
    ImGuiContext&amp; g = *GImGui;
    if (!IsPopupOpen(popup_id, ImGuiPopupFlags_None))</span>
    {
<span style = "background-color:#fdd">        g.NextWindowData.ClearFlags();
        return false;</span>
    }

    // Set popup size
<span style = "background-color:#dfd">    float w = bb.GetWidth();
    if (g.NextWindowData.Flags &amp; ImGuiNextWindowDataFlags_HasSizeConstraint)</span>
    {
<span style = "background-color:#fdd">        g.NextWindowData.SizeConstraintRect.Min.x = ImMax(g.NextWindowData.SizeConstraintRect.Min.x, w);
    }</span>
    else
    {
<span style = "background-color:#dfd">        if ((flags &amp; ImGuiComboFlags_HeightMask_) == 0)
            flags |= ImGuiComboFlags_HeightRegular;
        IM_ASSERT(ImIsPowerOfTwo(flags &amp; ImGuiComboFlags_HeightMask_)); // Only one
        int popup_max_height_in_items = -1;
        if (flags &amp; ImGuiComboFlags_HeightRegular)     popup_max_height_in_items = 8;</span>
<span style = "background-color:#fdd">        else if (flags &amp; ImGuiComboFlags_HeightSmall)  popup_max_height_in_items = 4;
        else if (flags &amp; ImGuiComboFlags_HeightLarge)  popup_max_height_in_items = 20;</span>
<span style = "background-color:#dfd">        SetNextWindowSizeConstraints(ImVec2(w, 0.0f), ImVec2(FLT_MAX, CalcMaxPopupHeightFromItemCount(popup_max_height_in_items)));</span>
    }

    // This is essentially a specialized version of BeginPopupEx()
    char name[16];
<span style = "background-color:#dfd">    ImFormatString(name, IM_ARRAYSIZE(name), "##Combo_%02d", g.BeginPopupStack.Size); // Recycle windows based on depth</span>

    // Set position given a custom constraint (peak into expected window size so we can position it)
    // FIXME: This might be easier to express with an hypothetical SetNextWindowPosConstraints() function?
    // FIXME: This might be moved to Begin() or at least around the same spot where Tooltips and other Popups are calling FindBestWindowPosForPopupEx()?
<span style = "background-color:#dfd">    if (ImGuiWindow* popup_window = FindWindowByName(name))
        if (popup_window-&gt;WasActive)</span>
        {
            // Always override 'AutoPosLastDirection' to not leave a chance for a past value to affect us.
<span style = "background-color:#dfd">            ImVec2 size_expected = CalcWindowNextAutoFitSize(popup_window);
            popup_window-&gt;AutoPosLastDirection = (flags &amp; ImGuiComboFlags_PopupAlignLeft) ? ImGuiDir_Left : ImGuiDir_Down; // Left = "Below, Toward Left", Down = "Below, Toward Right (default)"
            ImRect r_outer = GetPopupAllowedExtentRect(popup_window);
            ImVec2 pos = FindBestWindowPosForPopupEx(bb.GetBL(), size_expected, &amp;popup_window-&gt;AutoPosLastDirection, r_outer, bb, ImGuiPopupPositionPolicy_ComboBox);
            SetNextWindowPos(pos);</span>
        }

    // We don't use BeginPopupEx() solely because we have a custom name string, which we could make an argument to BeginPopupEx()
<span style = "background-color:#dfd">    ImGuiWindowFlags window_flags = ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_Popup | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoMove;
    PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(g.Style.FramePadding.x, g.Style.WindowPadding.y)); // Horizontally align ourselves with the framed text
    bool ret = Begin(name, NULL, window_flags);
    PopStyleVar();
    if (!ret)</span>
    {
<span style = "background-color:#fdd">        EndPopup();
        IM_ASSERT(0);   // This should never happen as we tested for IsPopupOpen() above
        return false;</span>
    }
<span style = "background-color:#dfd">    return true;
}</span>

void ImGui::EndCombo()
<span style = "background-color:#dfd">{
    EndPopup();
}</span>

// Call directly after the BeginCombo/EndCombo block. The preview is designed to only host non-interactive elements
// (Experimental, see GitHub issues: #1658, #4168)
bool ImGui::BeginComboPreview()
<span style = "background-color:#fdd">{
    ImGuiContext&amp; g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    ImGuiComboPreviewData* preview_data = &amp;g.ComboPreviewData;</span>

<span style = "background-color:#fdd">    if (window-&gt;SkipItems || !window-&gt;ClipRect.Overlaps(g.LastItemData.Rect)) // FIXME: Because we don't have a ImGuiItemStatusFlags_Visible flag to test last ItemAdd() result
        return false;
    IM_ASSERT(g.LastItemData.Rect.Min.x == preview_data-&gt;PreviewRect.Min.x &amp;&amp; g.LastItemData.Rect.Min.y == preview_data-&gt;PreviewRect.Min.y); // Didn't call after BeginCombo/EndCombo block or forgot to pass ImGuiComboFlags_CustomPreview flag?
    if (!window-&gt;ClipRect.Contains(preview_data-&gt;PreviewRect)) // Narrower test (optional)
        return false;</span>

    // FIXME: This could be contained in a PushWorkRect() api
<span style = "background-color:#fdd">    preview_data-&gt;BackupCursorPos = window-&gt;DC.CursorPos;
    preview_data-&gt;BackupCursorMaxPos = window-&gt;DC.CursorMaxPos;
    preview_data-&gt;BackupCursorPosPrevLine = window-&gt;DC.CursorPosPrevLine;
    preview_data-&gt;BackupPrevLineTextBaseOffset = window-&gt;DC.PrevLineTextBaseOffset;
    preview_data-&gt;BackupLayout = window-&gt;DC.LayoutType;
    window-&gt;DC.CursorPos = preview_data-&gt;PreviewRect.Min + g.Style.FramePadding;
    window-&gt;DC.CursorMaxPos = window-&gt;DC.CursorPos;
    window-&gt;DC.LayoutType = ImGuiLayoutType_Horizontal;
    PushClipRect(preview_data-&gt;PreviewRect.Min, preview_data-&gt;PreviewRect.Max, true);</span>

<span style = "background-color:#fdd">    return true;
}</span>

void ImGui::EndComboPreview()
<span style = "background-color:#fdd">{
    ImGuiContext&amp; g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    ImGuiComboPreviewData* preview_data = &amp;g.ComboPreviewData;</span>

    // FIXME: Using CursorMaxPos approximation instead of correct AABB which we will store in ImDrawCmd in the future
<span style = "background-color:#fdd">    ImDrawList* draw_list = window-&gt;DrawList;
    if (window-&gt;DC.CursorMaxPos.x &lt; preview_data-&gt;PreviewRect.Max.x &amp;&amp; window-&gt;DC.CursorMaxPos.y &lt; preview_data-&gt;PreviewRect.Max.y)
        if (draw_list-&gt;CmdBuffer.Size &gt; 1) // Unlikely case that the PushClipRect() didn't create a command</span>
        {
<span style = "background-color:#fdd">            draw_list-&gt;_CmdHeader.ClipRect = draw_list-&gt;CmdBuffer[draw_list-&gt;CmdBuffer.Size - 1].ClipRect = draw_list-&gt;CmdBuffer[draw_list-&gt;CmdBuffer.Size - 2].ClipRect;
            draw_list-&gt;_TryMergeDrawCmds();</span>
        }
<span style = "background-color:#fdd">    PopClipRect();
    window-&gt;DC.CursorPos = preview_data-&gt;BackupCursorPos;
    window-&gt;DC.CursorMaxPos = ImMax(window-&gt;DC.CursorMaxPos, preview_data-&gt;BackupCursorMaxPos);
    window-&gt;DC.CursorPosPrevLine = preview_data-&gt;BackupCursorPosPrevLine;
    window-&gt;DC.PrevLineTextBaseOffset = preview_data-&gt;BackupPrevLineTextBaseOffset;
    window-&gt;DC.LayoutType = preview_data-&gt;BackupLayout;
    preview_data-&gt;PreviewRect = ImRect();
}</span>

// Getter for the old Combo() API: const char*[]
static bool Items_ArrayGetter(void* data, int idx, const char** out_text)
<span style = "background-color:#fdd">{
    const char* const* items = (const char* const*)data;
    if (out_text)
        *out_text = items[idx];
    return true;
}</span>

// Getter for the old Combo() API: "item1\0item2\0item3\0"
static bool Items_SingleStringGetter(void* data, int idx, const char** out_text)
<span style = "background-color:#fdd">{</span>
    // FIXME-OPT: we could pre-compute the indices to fasten this. But only 1 active combo means the waste is limited.
<span style = "background-color:#fdd">    const char* items_separated_by_zeros = (const char*)data;
    int items_count = 0;
    const char* p = items_separated_by_zeros;
    while (*p)</span>
    {
<span style = "background-color:#fdd">        if (idx == items_count)
            break;
        p += strlen(p) + 1;
        items_count++;
    }
    if (!*p)
        return false;
    if (out_text)
        *out_text = p;
    return true;
}</span>

// Old API, prefer using BeginCombo() nowadays if you can.
bool ImGui::Combo(const char* label, int* current_item, bool (*items_getter)(void*, int, const char**), void* data, int items_count, int popup_max_height_in_items)
<span style = "background-color:#fdd">{
    ImGuiContext&amp; g = *GImGui;</span>

    // Call the getter to obtain the preview string which is a parameter to BeginCombo()
<span style = "background-color:#fdd">    const char* preview_value = NULL;
    if (*current_item &gt;= 0 &amp;&amp; *current_item &lt; items_count)
        items_getter(data, *current_item, &amp;preview_value);</span>

    // The old Combo() API exposed "popup_max_height_in_items". The new more general BeginCombo() API doesn't have/need it, but we emulate it here.
<span style = "background-color:#fdd">    if (popup_max_height_in_items != -1 &amp;&amp; !(g.NextWindowData.Flags &amp; ImGuiNextWindowDataFlags_HasSizeConstraint))
        SetNextWindowSizeConstraints(ImVec2(0, 0), ImVec2(FLT_MAX, CalcMaxPopupHeightFromItemCount(popup_max_height_in_items)));</span>

<span style = "background-color:#fdd">    if (!BeginCombo(label, preview_value, ImGuiComboFlags_None))
        return false;</span>

    // Display items
    // FIXME-OPT: Use clipper (but we need to disable it on the appearing frame to make sure our call to SetItemDefaultFocus() is processed)
<span style = "background-color:#fdd">    bool value_changed = false;
    for (int i = 0; i &lt; items_count; i++)</span>
    {
<span style = "background-color:#fdd">        PushID(i);
        const bool item_selected = (i == *current_item);</span>
        const char* item_text;
<span style = "background-color:#fdd">        if (!items_getter(data, i, &amp;item_text))
            item_text = "*Unknown item*";
        if (Selectable(item_text, item_selected))</span>
        {
<span style = "background-color:#fdd">            value_changed = true;
            *current_item = i;</span>
        }
<span style = "background-color:#fdd">        if (item_selected)
            SetItemDefaultFocus();
        PopID();
    }</span>

<span style = "background-color:#fdd">    EndCombo();</span>

<span style = "background-color:#fdd">    if (value_changed)
        MarkItemEdited(g.LastItemData.ID);</span>

<span style = "background-color:#fdd">    return value_changed;
}</span>

// Combo box helper allowing to pass an array of strings.
bool ImGui::Combo(const char* label, int* current_item, const char* const items[], int items_count, int height_in_items)
<span style = "background-color:#fdd">{
    const bool value_changed = Combo(label, current_item, Items_ArrayGetter, (void*)items, items_count, height_in_items);
    return value_changed;
}</span>

// Combo box helper allowing to pass all items in a single string literal holding multiple zero-terminated items "item1\0item2\0"
bool ImGui::Combo(const char* label, int* current_item, const char* items_separated_by_zeros, int height_in_items)
<span style = "background-color:#fdd">{
    int items_count = 0;
    const char* p = items_separated_by_zeros;       // FIXME-OPT: Avoid computing this, or at least only when combo is open
    while (*p)</span>
    {
<span style = "background-color:#fdd">        p += strlen(p) + 1;
        items_count++;
    }
    bool value_changed = Combo(label, current_item, Items_SingleStringGetter, (void*)items_separated_by_zeros, items_count, height_in_items);
    return value_changed;
}</span>

//-------------------------------------------------------------------------
// [SECTION] Data Type and Data Formatting Helpers [Internal]
//-------------------------------------------------------------------------
// - PatchFormatStringFloatToInt()
// - DataTypeGetInfo()
// - DataTypeFormatString()
// - DataTypeApplyOp()
// - DataTypeApplyOpFromText()
// - DataTypeClamp()
// - GetMinimumStepAtDecimalPrecision
// - RoundScalarWithFormat&lt;&gt;()
//-------------------------------------------------------------------------

static const ImGuiDataTypeInfo GDataTypeInfo[] =
{
    { sizeof(char),             "S8",   "%d",   "%d"    },  // ImGuiDataType_S8
    { sizeof(unsigned char),    "U8",   "%u",   "%u"    },
    { sizeof(short),            "S16",  "%d",   "%d"    },  // ImGuiDataType_S16
    { sizeof(unsigned short),   "U16",  "%u",   "%u"    },
    { sizeof(int),              "S32",  "%d",   "%d"    },  // ImGuiDataType_S32
    { sizeof(unsigned int),     "U32",  "%u",   "%u"    },
#ifdef _MSC_VER
    { sizeof(ImS64),            "S64",  "%I64d","%I64d" },  // ImGuiDataType_S64
    { sizeof(ImU64),            "U64",  "%I64u","%I64u" },
#else
    { sizeof(ImS64),            "S64",  "%lld", "%lld"  },  // ImGuiDataType_S64
    { sizeof(ImU64),            "U64",  "%llu", "%llu"  },
#endif
    { sizeof(float),            "float", "%.3f","%f"    },  // ImGuiDataType_Float (float are promoted to double in va_arg)
    { sizeof(double),           "double","%f",  "%lf"   },  // ImGuiDataType_Double
};
IM_STATIC_ASSERT(IM_ARRAYSIZE(GDataTypeInfo) == ImGuiDataType_COUNT);

// FIXME-LEGACY: Prior to 1.61 our DragInt() function internally used floats and because of this the compile-time default value for format was "%.0f".
// Even though we changed the compile-time default, we expect users to have carried %f around, which would break the display of DragInt() calls.
// To honor backward compatibility we are rewriting the format string, unless IMGUI_DISABLE_OBSOLETE_FUNCTIONS is enabled. What could possibly go wrong?!
static const char* PatchFormatStringFloatToInt(const char* fmt)
<span style = "background-color:#fdd">{
    if (fmt[0] == '%' &amp;&amp; fmt[1] == '.' &amp;&amp; fmt[2] == '0' &amp;&amp; fmt[3] == 'f' &amp;&amp; fmt[4] == 0) // Fast legacy path for "%.0f" which is expected to be the most common case.
        return "%d";
    const char* fmt_start = ImParseFormatFindStart(fmt);    // Find % (if any, and ignore %%)
    const char* fmt_end = ImParseFormatFindEnd(fmt_start);  // Find end of format specifier, which itself is an exercise of confidence/recklessness (because snprintf is dependent on libc or user).
    if (fmt_end &gt; fmt_start &amp;&amp; fmt_end[-1] == 'f')</span>
    {
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
<span style = "background-color:#fdd">        if (fmt_start == fmt &amp;&amp; fmt_end[0] == 0)
            return "%d";
        ImGuiContext&amp; g = *GImGui;
        ImFormatString(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), "%.*s%%d%s", (int)(fmt_start - fmt), fmt, fmt_end); // Honor leading and trailing decorations, but lose alignment/precision.
        return g.TempBuffer;</span>
#else
        IM_ASSERT(0 &amp;&amp; "DragInt(): Invalid format string!"); // Old versions used a default parameter of "%.0f", please replace with e.g. "%d"
#endif
    }
<span style = "background-color:#fdd">    return fmt;
}</span>

const ImGuiDataTypeInfo* ImGui::DataTypeGetInfo(ImGuiDataType data_type)
<span style = "background-color:#fdd">{
    IM_ASSERT(data_type &gt;= 0 &amp;&amp; data_type &lt; ImGuiDataType_COUNT);
    return &amp;GDataTypeInfo[data_type];
}</span>

int ImGui::DataTypeFormatString(char* buf, int buf_size, ImGuiDataType data_type, const void* p_data, const char* format)
<span style = "background-color:#dfd">{</span>
    // Signedness doesn't matter when pushing integer arguments
<span style = "background-color:#dfd">    if (data_type == ImGuiDataType_S32 || data_type == ImGuiDataType_U32)</span>
<span style = "background-color:#fdd">        return ImFormatString(buf, buf_size, format, *(const ImU32*)p_data);</span>
<span style = "background-color:#dfd">    if (data_type == ImGuiDataType_S64 || data_type == ImGuiDataType_U64)</span>
<span style = "background-color:#fdd">        return ImFormatString(buf, buf_size, format, *(const ImU64*)p_data);</span>
<span style = "background-color:#dfd">    if (data_type == ImGuiDataType_Float)
        return ImFormatString(buf, buf_size, format, *(const float*)p_data);</span>
<span style = "background-color:#fdd">    if (data_type == ImGuiDataType_Double)
        return ImFormatString(buf, buf_size, format, *(const double*)p_data);
    if (data_type == ImGuiDataType_S8)
        return ImFormatString(buf, buf_size, format, *(const ImS8*)p_data);
    if (data_type == ImGuiDataType_U8)
        return ImFormatString(buf, buf_size, format, *(const ImU8*)p_data);
    if (data_type == ImGuiDataType_S16)
        return ImFormatString(buf, buf_size, format, *(const ImS16*)p_data);
    if (data_type == ImGuiDataType_U16)
        return ImFormatString(buf, buf_size, format, *(const ImU16*)p_data);
    IM_ASSERT(0);
    return 0;</span>
<span style = "background-color:#dfd">}</span>

void ImGui::DataTypeApplyOp(ImGuiDataType data_type, int op, void* output, const void* arg1, const void* arg2)
<span style = "background-color:#fdd">{
    IM_ASSERT(op == '+' || op == '-');
    switch (data_type)</span>
    {
        case ImGuiDataType_S8:
<span style = "background-color:#fdd">            if (op == '+') { *(ImS8*)output  = ImAddClampOverflow(*(const ImS8*)arg1,  *(const ImS8*)arg2,  IM_S8_MIN,  IM_S8_MAX); }
            if (op == '-') { *(ImS8*)output  = ImSubClampOverflow(*(const ImS8*)arg1,  *(const ImS8*)arg2,  IM_S8_MIN,  IM_S8_MAX); }
            return;</span>
        case ImGuiDataType_U8:
<span style = "background-color:#fdd">            if (op == '+') { *(ImU8*)output  = ImAddClampOverflow(*(const ImU8*)arg1,  *(const ImU8*)arg2,  IM_U8_MIN,  IM_U8_MAX); }
            if (op == '-') { *(ImU8*)output  = ImSubClampOverflow(*(const ImU8*)arg1,  *(const ImU8*)arg2,  IM_U8_MIN,  IM_U8_MAX); }
            return;</span>
        case ImGuiDataType_S16:
<span style = "background-color:#fdd">            if (op == '+') { *(ImS16*)output = ImAddClampOverflow(*(const ImS16*)arg1, *(const ImS16*)arg2, IM_S16_MIN, IM_S16_MAX); }
            if (op == '-') { *(ImS16*)output = ImSubClampOverflow(*(const ImS16*)arg1, *(const ImS16*)arg2, IM_S16_MIN, IM_S16_MAX); }
            return;</span>
        case ImGuiDataType_U16:
<span style = "background-color:#fdd">            if (op == '+') { *(ImU16*)output = ImAddClampOverflow(*(const ImU16*)arg1, *(const ImU16*)arg2, IM_U16_MIN, IM_U16_MAX); }
            if (op == '-') { *(ImU16*)output = ImSubClampOverflow(*(const ImU16*)arg1, *(const ImU16*)arg2, IM_U16_MIN, IM_U16_MAX); }
            return;</span>
        case ImGuiDataType_S32:
<span style = "background-color:#fdd">            if (op == '+') { *(ImS32*)output = ImAddClampOverflow(*(const ImS32*)arg1, *(const ImS32*)arg2, IM_S32_MIN, IM_S32_MAX); }
            if (op == '-') { *(ImS32*)output = ImSubClampOverflow(*(const ImS32*)arg1, *(const ImS32*)arg2, IM_S32_MIN, IM_S32_MAX); }
            return;</span>
        case ImGuiDataType_U32:
<span style = "background-color:#fdd">            if (op == '+') { *(ImU32*)output = ImAddClampOverflow(*(const ImU32*)arg1, *(const ImU32*)arg2, IM_U32_MIN, IM_U32_MAX); }
            if (op == '-') { *(ImU32*)output = ImSubClampOverflow(*(const ImU32*)arg1, *(const ImU32*)arg2, IM_U32_MIN, IM_U32_MAX); }
            return;</span>
        case ImGuiDataType_S64:
<span style = "background-color:#fdd">            if (op == '+') { *(ImS64*)output = ImAddClampOverflow(*(const ImS64*)arg1, *(const ImS64*)arg2, IM_S64_MIN, IM_S64_MAX); }
            if (op == '-') { *(ImS64*)output = ImSubClampOverflow(*(const ImS64*)arg1, *(const ImS64*)arg2, IM_S64_MIN, IM_S64_MAX); }
            return;</span>
        case ImGuiDataType_U64:
<span style = "background-color:#fdd">            if (op == '+') { *(ImU64*)output = ImAddClampOverflow(*(const ImU64*)arg1, *(const ImU64*)arg2, IM_U64_MIN, IM_U64_MAX); }
            if (op == '-') { *(ImU64*)output = ImSubClampOverflow(*(const ImU64*)arg1, *(const ImU64*)arg2, IM_U64_MIN, IM_U64_MAX); }
            return;</span>
        case ImGuiDataType_Float:
<span style = "background-color:#fdd">            if (op == '+') { *(float*)output = *(const float*)arg1 + *(const float*)arg2; }
            if (op == '-') { *(float*)output = *(const float*)arg1 - *(const float*)arg2; }
            return;</span>
        case ImGuiDataType_Double:
<span style = "background-color:#fdd">            if (op == '+') { *(double*)output = *(const double*)arg1 + *(const double*)arg2; }
            if (op == '-') { *(double*)output = *(const double*)arg1 - *(const double*)arg2; }
            return;</span>
        case ImGuiDataType_COUNT: break;
    }
<span style = "background-color:#fdd">    IM_ASSERT(0);
}</span>

// User can input math operators (e.g. +100) to edit a numerical values.
// NB: This is _not_ a full expression evaluator. We should probably add one and replace this dumb mess..
bool ImGui::DataTypeApplyOpFromText(const char* buf, const char* initial_value_buf, ImGuiDataType data_type, void* p_data, const char* format)
<span style = "background-color:#fdd">{
    while (ImCharIsBlankA(*buf))
        buf++;</span>

    // We don't support '-' op because it would conflict with inputing negative value.
    // Instead you can use +-100 to subtract from an existing value
<span style = "background-color:#fdd">    char op = buf[0];
    if (op == '+' || op == '*' || op == '/')</span>
    {
<span style = "background-color:#fdd">        buf++;
        while (ImCharIsBlankA(*buf))
            buf++;
    }</span>
    else
    {
<span style = "background-color:#fdd">        op = 0;</span>
    }
<span style = "background-color:#fdd">    if (!buf[0])
        return false;</span>

    // Copy the value in an opaque buffer so we can compare at the end of the function if it changed at all.
<span style = "background-color:#fdd">    const ImGuiDataTypeInfo* type_info = DataTypeGetInfo(data_type);</span>
    ImGuiDataTypeTempStorage data_backup;
<span style = "background-color:#fdd">    memcpy(&amp;data_backup, p_data, type_info-&gt;Size);</span>

<span style = "background-color:#fdd">    if (format == NULL)
        format = type_info-&gt;ScanFmt;</span>

    // FIXME-LEGACY: The aim is to remove those operators and write a proper expression evaluator at some point..
<span style = "background-color:#fdd">    int arg1i = 0;
    if (data_type == ImGuiDataType_S32)</span>
    {
<span style = "background-color:#fdd">        int* v = (int*)p_data;
        int arg0i = *v;
        float arg1f = 0.0f;
        if (op &amp;&amp; sscanf(initial_value_buf, format, &amp;arg0i) &lt; 1)
            return false;</span>
        // Store operand in a float so we can use fractional value for multipliers (*1.1), but constant always parsed as integer so we can fit big integers (e.g. 2000000003) past float precision
<span style = "background-color:#fdd">        if (op == '+')      { if (sscanf(buf, "%d", &amp;arg1i)) *v = (int)(arg0i + arg1i); }                   // Add (use "+-" to subtract)
        else if (op == '*') { if (sscanf(buf, "%f", &amp;arg1f)) *v = (int)(arg0i * arg1f); }                   // Multiply
        else if (op == '/') { if (sscanf(buf, "%f", &amp;arg1f) &amp;&amp; arg1f != 0.0f) *v = (int)(arg0i / arg1f); }  // Divide
        else                { if (sscanf(buf, format, &amp;arg1i) == 1) *v = arg1i; }                           // Assign constant
    }
    else if (data_type == ImGuiDataType_Float)</span>
    {
        // For floats we have to ignore format with precision (e.g. "%.2f") because sscanf doesn't take them in
<span style = "background-color:#fdd">        format = "%f";
        float* v = (float*)p_data;
        float arg0f = *v, arg1f = 0.0f;
        if (op &amp;&amp; sscanf(initial_value_buf, format, &amp;arg0f) &lt; 1)
            return false;
        if (sscanf(buf, format, &amp;arg1f) &lt; 1)
            return false;
        if (op == '+')      { *v = arg0f + arg1f; }                    // Add (use "+-" to subtract)
        else if (op == '*') { *v = arg0f * arg1f; }                    // Multiply
        else if (op == '/') { if (arg1f != 0.0f) *v = arg0f / arg1f; } // Divide
        else                { *v = arg1f; }                            // Assign constant
    }
    else if (data_type == ImGuiDataType_Double)</span>
    {
<span style = "background-color:#fdd">        format = "%lf"; // scanf differentiate float/double unlike printf which forces everything to double because of ellipsis
        double* v = (double*)p_data;
        double arg0f = *v, arg1f = 0.0;
        if (op &amp;&amp; sscanf(initial_value_buf, format, &amp;arg0f) &lt; 1)
            return false;
        if (sscanf(buf, format, &amp;arg1f) &lt; 1)
            return false;
        if (op == '+')      { *v = arg0f + arg1f; }                    // Add (use "+-" to subtract)
        else if (op == '*') { *v = arg0f * arg1f; }                    // Multiply
        else if (op == '/') { if (arg1f != 0.0f) *v = arg0f / arg1f; } // Divide
        else                { *v = arg1f; }                            // Assign constant
    }
    else if (data_type == ImGuiDataType_U32 || data_type == ImGuiDataType_S64 || data_type == ImGuiDataType_U64)</span>
    {
        // All other types assign constant
        // We don't bother handling support for legacy operators since they are a little too crappy. Instead we will later implement a proper expression evaluator in the future.
<span style = "background-color:#fdd">        if (sscanf(buf, format, p_data) &lt; 1)
            return false;
    }</span>
    else
    {
        // Small types need a 32-bit buffer to receive the result from scanf()
        int v32;
<span style = "background-color:#fdd">        if (sscanf(buf, format, &amp;v32) &lt; 1)
            return false;
        if (data_type == ImGuiDataType_S8)
            *(ImS8*)p_data = (ImS8)ImClamp(v32, (int)IM_S8_MIN, (int)IM_S8_MAX);
        else if (data_type == ImGuiDataType_U8)
            *(ImU8*)p_data = (ImU8)ImClamp(v32, (int)IM_U8_MIN, (int)IM_U8_MAX);
        else if (data_type == ImGuiDataType_S16)
            *(ImS16*)p_data = (ImS16)ImClamp(v32, (int)IM_S16_MIN, (int)IM_S16_MAX);
        else if (data_type == ImGuiDataType_U16)
            *(ImU16*)p_data = (ImU16)ImClamp(v32, (int)IM_U16_MIN, (int)IM_U16_MAX);</span>
        else
<span style = "background-color:#fdd">            IM_ASSERT(0);</span>
    }

<span style = "background-color:#fdd">    return memcmp(&amp;data_backup, p_data, type_info-&gt;Size) != 0;
}</span>

template&lt;typename T&gt;
static int DataTypeCompareT(const T* lhs, const T* rhs)
<span style = "background-color:#fdd">{
    if (*lhs &lt; *rhs) return -1;
    if (*lhs &gt; *rhs) return +1;
    return 0;
}</span>

int ImGui::DataTypeCompare(ImGuiDataType data_type, const void* arg_1, const void* arg_2)
<span style = "background-color:#fdd">{
    switch (data_type)</span>
    {
<span style = "background-color:#fdd">    case ImGuiDataType_S8:     return DataTypeCompareT&lt;ImS8  &gt;((const ImS8*  )arg_1, (const ImS8*  )arg_2);
    case ImGuiDataType_U8:     return DataTypeCompareT&lt;ImU8  &gt;((const ImU8*  )arg_1, (const ImU8*  )arg_2);
    case ImGuiDataType_S16:    return DataTypeCompareT&lt;ImS16 &gt;((const ImS16* )arg_1, (const ImS16* )arg_2);
    case ImGuiDataType_U16:    return DataTypeCompareT&lt;ImU16 &gt;((const ImU16* )arg_1, (const ImU16* )arg_2);
    case ImGuiDataType_S32:    return DataTypeCompareT&lt;ImS32 &gt;((const ImS32* )arg_1, (const ImS32* )arg_2);
    case ImGuiDataType_U32:    return DataTypeCompareT&lt;ImU32 &gt;((const ImU32* )arg_1, (const ImU32* )arg_2);
    case ImGuiDataType_S64:    return DataTypeCompareT&lt;ImS64 &gt;((const ImS64* )arg_1, (const ImS64* )arg_2);
    case ImGuiDataType_U64:    return DataTypeCompareT&lt;ImU64 &gt;((const ImU64* )arg_1, (const ImU64* )arg_2);
    case ImGuiDataType_Float:  return DataTypeCompareT&lt;float &gt;((const float* )arg_1, (const float* )arg_2);
    case ImGuiDataType_Double: return DataTypeCompareT&lt;double&gt;((const double*)arg_1, (const double*)arg_2);</span>
    case ImGuiDataType_COUNT:  break;
    }
<span style = "background-color:#fdd">    IM_ASSERT(0);
    return 0;
}</span>

template&lt;typename T&gt;
static bool DataTypeClampT(T* v, const T* v_min, const T* v_max)
<span style = "background-color:#fdd">{</span>
    // Clamp, both sides are optional, return true if modified
<span style = "background-color:#fdd">    if (v_min &amp;&amp; *v &lt; *v_min) { *v = *v_min; return true; }
    if (v_max &amp;&amp; *v &gt; *v_max) { *v = *v_max; return true; }
    return false;
}</span>

bool ImGui::DataTypeClamp(ImGuiDataType data_type, void* p_data, const void* p_min, const void* p_max)
<span style = "background-color:#fdd">{
    switch (data_type)</span>
    {
<span style = "background-color:#fdd">    case ImGuiDataType_S8:     return DataTypeClampT&lt;ImS8  &gt;((ImS8*  )p_data, (const ImS8*  )p_min, (const ImS8*  )p_max);
    case ImGuiDataType_U8:     return DataTypeClampT&lt;ImU8  &gt;((ImU8*  )p_data, (const ImU8*  )p_min, (const ImU8*  )p_max);
    case ImGuiDataType_S16:    return DataTypeClampT&lt;ImS16 &gt;((ImS16* )p_data, (const ImS16* )p_min, (const ImS16* )p_max);
    case ImGuiDataType_U16:    return DataTypeClampT&lt;ImU16 &gt;((ImU16* )p_data, (const ImU16* )p_min, (const ImU16* )p_max);
    case ImGuiDataType_S32:    return DataTypeClampT&lt;ImS32 &gt;((ImS32* )p_data, (const ImS32* )p_min, (const ImS32* )p_max);
    case ImGuiDataType_U32:    return DataTypeClampT&lt;ImU32 &gt;((ImU32* )p_data, (const ImU32* )p_min, (const ImU32* )p_max);
    case ImGuiDataType_S64:    return DataTypeClampT&lt;ImS64 &gt;((ImS64* )p_data, (const ImS64* )p_min, (const ImS64* )p_max);
    case ImGuiDataType_U64:    return DataTypeClampT&lt;ImU64 &gt;((ImU64* )p_data, (const ImU64* )p_min, (const ImU64* )p_max);
    case ImGuiDataType_Float:  return DataTypeClampT&lt;float &gt;((float* )p_data, (const float* )p_min, (const float* )p_max);
    case ImGuiDataType_Double: return DataTypeClampT&lt;double&gt;((double*)p_data, (const double*)p_min, (const double*)p_max);</span>
    case ImGuiDataType_COUNT:  break;
    }
<span style = "background-color:#fdd">    IM_ASSERT(0);
    return false;
}</span>

static float GetMinimumStepAtDecimalPrecision(int decimal_precision)
<span style = "background-color:#fdd">{</span>
    static const float min_steps[10] = { 1.0f, 0.1f, 0.01f, 0.001f, 0.0001f, 0.00001f, 0.000001f, 0.0000001f, 0.00000001f, 0.000000001f };
<span style = "background-color:#fdd">    if (decimal_precision &lt; 0)
        return FLT_MIN;
    return (decimal_precision &lt; IM_ARRAYSIZE(min_steps)) ? min_steps[decimal_precision] : ImPow(10.0f, (float)-decimal_precision);
}</span>

template&lt;typename TYPE&gt;
static const char* ImAtoi(const char* src, TYPE* output)
<span style = "background-color:#fdd">{
    int negative = 0;
    if (*src == '-') { negative = 1; src++; }
    if (*src == '+') { src++; }
    TYPE v = 0;
    while (*src &gt;= '0' &amp;&amp; *src &lt;= '9')
        v = (v * 10) + (*src++ - '0');
    *output = negative ? -v : v;
    return src;
}</span>

// Sanitize format
// - Zero terminate so extra characters after format (e.g. "%f123") don't confuse atof/atoi
// - stb_sprintf.h supports several new modifiers which format numbers in a way that also makes them incompatible atof/atoi.
static void SanitizeFormatString(const char* fmt, char* fmt_out, size_t fmt_out_size)
<span style = "background-color:#dfd">{</span>
    IM_UNUSED(fmt_out_size);
<span style = "background-color:#dfd">    const char* fmt_end = ImParseFormatFindEnd(fmt);
    IM_ASSERT((size_t)(fmt_end - fmt + 1) &lt; fmt_out_size); // Format is too long, let us know if this happens to you!
    while (fmt &lt; fmt_end)</span>
    {
<span style = "background-color:#dfd">        char c = *(fmt++);
        if (c != '\'' &amp;&amp; c != '$' &amp;&amp; c != '_') // Custom flags provided by stb_sprintf.h. POSIX 2008 also supports '.
            *(fmt_out++) = c;
    }
    *fmt_out = 0; // Zero-terminate
}</span>

template&lt;typename TYPE, typename SIGNEDTYPE&gt;
TYPE ImGui::RoundScalarWithFormatT(const char* format, ImGuiDataType data_type, TYPE v)
<span style = "background-color:#dfd">{
    const char* fmt_start = ImParseFormatFindStart(format);
    if (fmt_start[0] != '%' || fmt_start[1] == '%') // Don't apply if the value is not visible in the format string</span>
<span style = "background-color:#fdd">        return v;</span>

    // Sanitize format
    char fmt_sanitized[32];
<span style = "background-color:#dfd">    SanitizeFormatString(fmt_start, fmt_sanitized, IM_ARRAYSIZE(fmt_sanitized));
    fmt_start = fmt_sanitized;</span>

    // Format value with our rounding, and read back
    char v_str[64];
<span style = "background-color:#dfd">    ImFormatString(v_str, IM_ARRAYSIZE(v_str), fmt_start, v);
    const char* p = v_str;
    while (*p == ' ')</span>
<span style = "background-color:#fdd">        p++;</span>
<span style = "background-color:#dfd">    if (data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double)
        v = (TYPE)ImAtof(p);</span>
    else
<span style = "background-color:#fdd">        ImAtoi(p, (SIGNEDTYPE*)&amp;v);</span>
<span style = "background-color:#dfd">    return v;
}</span>

//-------------------------------------------------------------------------
// [SECTION] Widgets: DragScalar, DragFloat, DragInt, etc.
//-------------------------------------------------------------------------
// - DragBehaviorT&lt;&gt;() [Internal]
// - DragBehavior() [Internal]
// - DragScalar()
// - DragScalarN()
// - DragFloat()
// - DragFloat2()
// - DragFloat3()
// - DragFloat4()
// - DragFloatRange2()
// - DragInt()
// - DragInt2()
// - DragInt3()
// - DragInt4()
// - DragIntRange2()
//-------------------------------------------------------------------------

// This is called by DragBehavior() when the widget is active (held by mouse or being manipulated with Nav controls)
template&lt;typename TYPE, typename SIGNEDTYPE, typename FLOATTYPE&gt;
bool ImGui::DragBehaviorT(ImGuiDataType data_type, TYPE* v, float v_speed, const TYPE v_min, const TYPE v_max, const char* format, ImGuiSliderFlags flags)
<span style = "background-color:#fdd">{
    ImGuiContext&amp; g = *GImGui;
    const ImGuiAxis axis = (flags &amp; ImGuiSliderFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;
    const bool is_clamped = (v_min &lt; v_max);
    const bool is_logarithmic = (flags &amp; ImGuiSliderFlags_Logarithmic) != 0;
    const bool is_floating_point = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);</span>

    // Default tweak speed
<span style = "background-color:#fdd">    if (v_speed == 0.0f &amp;&amp; is_clamped &amp;&amp; (v_max - v_min &lt; FLT_MAX))
        v_speed = (float)((v_max - v_min) * g.DragSpeedDefaultRatio);</span>

    // Inputs accumulates into g.DragCurrentAccum, which is flushed into the current value as soon as it makes a difference with our precision settings
<span style = "background-color:#fdd">    float adjust_delta = 0.0f;
    if (g.ActiveIdSource == ImGuiInputSource_Mouse &amp;&amp; IsMousePosValid() &amp;&amp; IsMouseDragPastThreshold(0, g.IO.MouseDragThreshold * DRAG_MOUSE_THRESHOLD_FACTOR))</span>
    {
<span style = "background-color:#fdd">        adjust_delta = g.IO.MouseDelta[axis];
        if (g.IO.KeyAlt)
            adjust_delta *= 1.0f / 100.0f;
        if (g.IO.KeyShift)
            adjust_delta *= 10.0f;
    }
    else if (g.ActiveIdSource == ImGuiInputSource_Nav)</span>
    {
<span style = "background-color:#fdd">        const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 0;
        adjust_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard | ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_RepeatFast, 1.0f / 10.0f, 10.0f)[axis];
        v_speed = ImMax(v_speed, GetMinimumStepAtDecimalPrecision(decimal_precision));</span>
    }
<span style = "background-color:#fdd">    adjust_delta *= v_speed;</span>

    // For vertical drag we currently assume that Up=higher value (like we do with vertical sliders). This may become a parameter.
<span style = "background-color:#fdd">    if (axis == ImGuiAxis_Y)
        adjust_delta = -adjust_delta;</span>

    // For logarithmic use our range is effectively 0..1 so scale the delta into that range
<span style = "background-color:#fdd">    if (is_logarithmic &amp;&amp; (v_max - v_min &lt; FLT_MAX) &amp;&amp; ((v_max - v_min) &gt; 0.000001f)) // Epsilon to avoid /0
        adjust_delta /= (float)(v_max - v_min);</span>

    // Clear current value on activation
    // Avoid altering values and clamping when we are _already_ past the limits and heading in the same direction, so e.g. if range is 0..255, current value is 300 and we are pushing to the right side, keep the 300.
<span style = "background-color:#fdd">    bool is_just_activated = g.ActiveIdIsJustActivated;
    bool is_already_past_limits_and_pushing_outward = is_clamped &amp;&amp; ((*v &gt;= v_max &amp;&amp; adjust_delta &gt; 0.0f) || (*v &lt;= v_min &amp;&amp; adjust_delta &lt; 0.0f));
    if (is_just_activated || is_already_past_limits_and_pushing_outward)</span>
    {
<span style = "background-color:#fdd">        g.DragCurrentAccum = 0.0f;
        g.DragCurrentAccumDirty = false;
    }
    else if (adjust_delta != 0.0f)</span>
    {
<span style = "background-color:#fdd">        g.DragCurrentAccum += adjust_delta;
        g.DragCurrentAccumDirty = true;</span>
    }

<span style = "background-color:#fdd">    if (!g.DragCurrentAccumDirty)
        return false;</span>

<span style = "background-color:#fdd">    TYPE v_cur = *v;
    FLOATTYPE v_old_ref_for_accum_remainder = (FLOATTYPE)0.0f;</span>

<span style = "background-color:#fdd">    float logarithmic_zero_epsilon = 0.0f; // Only valid when is_logarithmic is true
    const float zero_deadzone_halfsize = 0.0f; // Drag widgets have no deadzone (as it doesn't make sense)
    if (is_logarithmic)</span>
    {
        // When using logarithmic sliders, we need to clamp to avoid hitting zero, but our choice of clamp value greatly affects slider precision. We attempt to use the specified precision to estimate a good lower bound.
<span style = "background-color:#fdd">        const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 1;
        logarithmic_zero_epsilon = ImPow(0.1f, (float)decimal_precision);</span>

        // Convert to parametric space, apply delta, convert back
<span style = "background-color:#fdd">        float v_old_parametric = ScaleRatioFromValueT&lt;TYPE, SIGNEDTYPE, FLOATTYPE&gt;(data_type, v_cur, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
        float v_new_parametric = v_old_parametric + g.DragCurrentAccum;
        v_cur = ScaleValueFromRatioT&lt;TYPE, SIGNEDTYPE, FLOATTYPE&gt;(data_type, v_new_parametric, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
        v_old_ref_for_accum_remainder = v_old_parametric;
    }</span>
    else
    {
<span style = "background-color:#fdd">        v_cur += (SIGNEDTYPE)g.DragCurrentAccum;</span>
    }

    // Round to user desired precision based on format string
<span style = "background-color:#fdd">    if (!(flags &amp; ImGuiSliderFlags_NoRoundToFormat))
        v_cur = RoundScalarWithFormatT&lt;TYPE, SIGNEDTYPE&gt;(format, data_type, v_cur);</span>

    // Preserve remainder after rounding has been applied. This also allow slow tweaking of values.
<span style = "background-color:#fdd">    g.DragCurrentAccumDirty = false;
    if (is_logarithmic)</span>
    {
        // Convert to parametric space, apply delta, convert back
<span style = "background-color:#fdd">        float v_new_parametric = ScaleRatioFromValueT&lt;TYPE, SIGNEDTYPE, FLOATTYPE&gt;(data_type, v_cur, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
        g.DragCurrentAccum -= (float)(v_new_parametric - v_old_ref_for_accum_remainder);
    }</span>
    else
    {
<span style = "background-color:#fdd">        g.DragCurrentAccum -= (float)((SIGNEDTYPE)v_cur - (SIGNEDTYPE)*v);</span>
    }

    // Lose zero sign for float/double
<span style = "background-color:#fdd">    if (v_cur == (TYPE)-0)
        v_cur = (TYPE)0;</span>

    // Clamp values (+ handle overflow/wrap-around for integer types)
<span style = "background-color:#fdd">    if (*v != v_cur &amp;&amp; is_clamped)</span>
    {
<span style = "background-color:#fdd">        if (v_cur &lt; v_min || (v_cur &gt; *v &amp;&amp; adjust_delta &lt; 0.0f &amp;&amp; !is_floating_point))
            v_cur = v_min;
        if (v_cur &gt; v_max || (v_cur &lt; *v &amp;&amp; adjust_delta &gt; 0.0f &amp;&amp; !is_floating_point))
            v_cur = v_max;</span>
    }

    // Apply result
<span style = "background-color:#fdd">    if (*v == v_cur)
        return false;
    *v = v_cur;
    return true;
}</span>

bool ImGui::DragBehavior(ImGuiID id, ImGuiDataType data_type, void* p_v, float v_speed, const void* p_min, const void* p_max, const char* format, ImGuiSliderFlags flags)
<span style = "background-color:#fdd">{</span>
    // Read imgui.cpp "API BREAKING CHANGES" section for 1.78 if you hit this assert.
<span style = "background-color:#fdd">    IM_ASSERT((flags == 1 || (flags &amp; ImGuiSliderFlags_InvalidMask_) == 0) &amp;&amp; "Invalid ImGuiSliderFlags flags! Has the 'float power' argument been mistakenly cast to flags? Call function with ImGuiSliderFlags_Logarithmic flags instead.");</span>

<span style = "background-color:#fdd">    ImGuiContext&amp; g = *GImGui;
    if (g.ActiveId == id)</span>
    {
<span style = "background-color:#fdd">        if (g.ActiveIdSource == ImGuiInputSource_Mouse &amp;&amp; !g.IO.MouseDown[0])
            ClearActiveID();
        else if (g.ActiveIdSource == ImGuiInputSource_Nav &amp;&amp; g.NavActivatePressedId == id &amp;&amp; !g.ActiveIdIsJustActivated)
            ClearActiveID();</span>
    }
<span style = "background-color:#fdd">    if (g.ActiveId != id)
        return false;
    if ((g.LastItemData.InFlags &amp; ImGuiItemFlags_ReadOnly) || (flags &amp; ImGuiSliderFlags_ReadOnly))
        return false;</span>

<span style = "background-color:#fdd">    switch (data_type)</span>
    {
<span style = "background-color:#fdd">    case ImGuiDataType_S8:     { ImS32 v32 = (ImS32)*(ImS8*)p_v;  bool r = DragBehaviorT&lt;ImS32, ImS32, float&gt;(ImGuiDataType_S32, &amp;v32, v_speed, p_min ? *(const ImS8*) p_min : IM_S8_MIN,  p_max ? *(const ImS8*)p_max  : IM_S8_MAX,  format, flags); if (r) *(ImS8*)p_v = (ImS8)v32; return r; }
    case ImGuiDataType_U8:     { ImU32 v32 = (ImU32)*(ImU8*)p_v;  bool r = DragBehaviorT&lt;ImU32, ImS32, float&gt;(ImGuiDataType_U32, &amp;v32, v_speed, p_min ? *(const ImU8*) p_min : IM_U8_MIN,  p_max ? *(const ImU8*)p_max  : IM_U8_MAX,  format, flags); if (r) *(ImU8*)p_v = (ImU8)v32; return r; }
    case ImGuiDataType_S16:    { ImS32 v32 = (ImS32)*(ImS16*)p_v; bool r = DragBehaviorT&lt;ImS32, ImS32, float&gt;(ImGuiDataType_S32, &amp;v32, v_speed, p_min ? *(const ImS16*)p_min : IM_S16_MIN, p_max ? *(const ImS16*)p_max : IM_S16_MAX, format, flags); if (r) *(ImS16*)p_v = (ImS16)v32; return r; }
    case ImGuiDataType_U16:    { ImU32 v32 = (ImU32)*(ImU16*)p_v; bool r = DragBehaviorT&lt;ImU32, ImS32, float&gt;(ImGuiDataType_U32, &amp;v32, v_speed, p_min ? *(const ImU16*)p_min : IM_U16_MIN, p_max ? *(const ImU16*)p_max : IM_U16_MAX, format, flags); if (r) *(ImU16*)p_v = (ImU16)v32; return r; }
    case ImGuiDataType_S32:    return DragBehaviorT&lt;ImS32, ImS32, float &gt;(data_type, (ImS32*)p_v,  v_speed, p_min ? *(const ImS32* )p_min : IM_S32_MIN, p_max ? *(const ImS32* )p_max : IM_S32_MAX, format, flags);
    case ImGuiDataType_U32:    return DragBehaviorT&lt;ImU32, ImS32, float &gt;(data_type, (ImU32*)p_v,  v_speed, p_min ? *(const ImU32* )p_min : IM_U32_MIN, p_max ? *(const ImU32* )p_max : IM_U32_MAX, format, flags);
    case ImGuiDataType_S64:    return DragBehaviorT&lt;ImS64, ImS64, double&gt;(data_type, (ImS64*)p_v,  v_speed, p_min ? *(const ImS64* )p_min : IM_S64_MIN, p_max ? *(const ImS64* )p_max : IM_S64_MAX, format, flags);
    case ImGuiDataType_U64:    return DragBehaviorT&lt;ImU64, ImS64, double&gt;(data_type, (ImU64*)p_v,  v_speed, p_min ? *(const ImU64* )p_min : IM_U64_MIN, p_max ? *(const ImU64* )p_max : IM_U64_MAX, format, flags);
    case ImGuiDataType_Float:  return DragBehaviorT&lt;float, float, float &gt;(data_type, (float*)p_v,  v_speed, p_min ? *(const float* )p_min : -FLT_MAX,   p_max ? *(const float* )p_max : FLT_MAX,    format, flags);
    case ImGuiDataType_Double: return DragBehaviorT&lt;double,double,double&gt;(data_type, (double*)p_v, v_speed, p_min ? *(const double*)p_min : -DBL_MAX,   p_max ? *(const double*)p_max : DBL_MAX,    format, flags);</span>
    case ImGuiDataType_COUNT:  break;
    }
<span style = "background-color:#fdd">    IM_ASSERT(0);
    return false;
}</span>

// Note: p_data, p_min and p_max are _pointers_ to a memory address holding the data. For a Drag widget, p_min and p_max are optional.
// Read code of e.g. DragFloat(), DragInt() etc. or examples in 'Demo-&gt;Widgets-&gt;Data Types' to understand how to use this function directly.
bool ImGui::DragScalar(const char* label, ImGuiDataType data_type, void* p_data, float v_speed, const void* p_min, const void* p_max, const char* format, ImGuiSliderFlags flags)
<span style = "background-color:#fdd">{
    ImGuiWindow* window = GetCurrentWindow();
    if (window-&gt;SkipItems)
        return false;</span>

<span style = "background-color:#fdd">    ImGuiContext&amp; g = *GImGui;
    const ImGuiStyle&amp; style = g.Style;
    const ImGuiID id = window-&gt;GetID(label);
    const float w = CalcItemWidth();</span>

<span style = "background-color:#fdd">    const ImVec2 label_size = CalcTextSize(label, NULL, true);
    const ImRect frame_bb(window-&gt;DC.CursorPos, window-&gt;DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y * 2.0f));
    const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x &gt; 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));</span>

<span style = "background-color:#fdd">    const bool temp_input_allowed = (flags &amp; ImGuiSliderFlags_NoInput) == 0;
    ItemSize(total_bb, style.FramePadding.y);
    if (!ItemAdd(total_bb, id, &amp;frame_bb, temp_input_allowed ? ImGuiItemFlags_Inputable : 0))
        return false;</span>

    // Default format string when passing NULL
<span style = "background-color:#fdd">    if (format == NULL)
        format = DataTypeGetInfo(data_type)-&gt;PrintFmt;
    else if (data_type == ImGuiDataType_S32 &amp;&amp; strcmp(format, "%d") != 0) // (FIXME-LEGACY: Patch old "%.0f" format string to use "%d", read function more details.)
        format = PatchFormatStringFloatToInt(format);</span>

    // Tabbing or CTRL-clicking on Drag turns it into an InputText
<span style = "background-color:#fdd">    const bool hovered = ItemHoverable(frame_bb, id);
    bool temp_input_is_active = temp_input_allowed &amp;&amp; TempInputIsActive(id);
    if (!temp_input_is_active)</span>
    {
<span style = "background-color:#fdd">        const bool input_requested_by_tabbing = temp_input_allowed &amp;&amp; (g.LastItemData.StatusFlags &amp; ImGuiItemStatusFlags_FocusedByTabbing) != 0;
        const bool clicked = (hovered &amp;&amp; g.IO.MouseClicked[0]);
        const bool double_clicked = (hovered &amp;&amp; g.IO.MouseClickedCount[0] == 2);
        if (input_requested_by_tabbing || clicked || double_clicked || g.NavActivateId == id || g.NavActivateInputId == id)</span>
        {
<span style = "background-color:#fdd">            SetActiveID(id, window);
            SetFocusID(id, window);
            FocusWindow(window);
            g.ActiveIdUsingNavDirMask = (1 &lt;&lt; ImGuiDir_Left) | (1 &lt;&lt; ImGuiDir_Right);
            if (temp_input_allowed)
                if (input_requested_by_tabbing || (clicked &amp;&amp; g.IO.KeyCtrl) || double_clicked || g.NavActivateInputId == id)
                    temp_input_is_active = true;</span>
        }

        // Experimental: simple click (without moving) turns Drag into an InputText
<span style = "background-color:#fdd">        if (g.IO.ConfigDragClickToInputText &amp;&amp; temp_input_allowed &amp;&amp; !temp_input_is_active)
            if (g.ActiveId == id &amp;&amp; hovered &amp;&amp; g.IO.MouseReleased[0] &amp;&amp; !IsMouseDragPastThreshold(0, g.IO.MouseDragThreshold * DRAG_MOUSE_THRESHOLD_FACTOR))</span>
            {
<span style = "background-color:#fdd">                g.NavActivateId = g.NavActivateInputId = id;
                g.NavActivateFlags = ImGuiActivateFlags_PreferInput;
                temp_input_is_active = true;</span>
            }
    }

<span style = "background-color:#fdd">    if (temp_input_is_active)</span>
    {
        // Only clamp CTRL+Click input when ImGuiSliderFlags_AlwaysClamp is set
<span style = "background-color:#fdd">        const bool is_clamp_input = (flags &amp; ImGuiSliderFlags_AlwaysClamp) != 0 &amp;&amp; (p_min == NULL || p_max == NULL || DataTypeCompare(data_type, p_min, p_max) &lt; 0);
        return TempInputScalar(frame_bb, id, label, data_type, p_data, format, is_clamp_input ? p_min : NULL, is_clamp_input ? p_max : NULL);</span>
    }

    // Draw frame
<span style = "background-color:#fdd">    const ImU32 frame_col = GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);
    RenderNavHighlight(frame_bb, id);
    RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, style.FrameRounding);</span>

    // Drag behavior
<span style = "background-color:#fdd">    const bool value_changed = DragBehavior(id, data_type, p_data, v_speed, p_min, p_max, format, flags);
    if (value_changed)
        MarkItemEdited(id);</span>

    // Display value using user-provided display format so user can add prefix/suffix/decorations to the value.
    char value_buf[64];
<span style = "background-color:#fdd">    const char* value_buf_end = value_buf + DataTypeFormatString(value_buf, IM_ARRAYSIZE(value_buf), data_type, p_data, format);
    if (g.LogEnabled)
        LogSetNextTextDecoration("{", "}");
    RenderTextClipped(frame_bb.Min, frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f, 0.5f));</span>

<span style = "background-color:#fdd">    if (label_size.x &gt; 0.0f)
        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);</span>

    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags);
<span style = "background-color:#fdd">    return value_changed;
}</span>

bool ImGui::DragScalarN(const char* label, ImGuiDataType data_type, void* p_data, int components, float v_speed, const void* p_min, const void* p_max, const char* format, ImGuiSliderFlags flags)
<span style = "background-color:#fdd">{
    ImGuiWindow* window = GetCurrentWindow();
    if (window-&gt;SkipItems)
        return false;</span>

<span style = "background-color:#fdd">    ImGuiContext&amp; g = *GImGui;
    bool value_changed = false;
    BeginGroup();
    PushID(label);
    PushMultiItemsWidths(components, CalcItemWidth());
    size_t type_size = GDataTypeInfo[data_type].Size;
    for (int i = 0; i &lt; components; i++)</span>
    {
<span style = "background-color:#fdd">        PushID(i);
        if (i &gt; 0)
            SameLine(0, g.Style.ItemInnerSpacing.x);
        value_changed |= DragScalar("", data_type, p_data, v_speed, p_min, p_max, format, flags);
        PopID();
        PopItemWidth();
        p_data = (void*)((char*)p_data + type_size);
    }
    PopID();</span>

<span style = "background-color:#fdd">    const char* label_end = FindRenderedTextEnd(label);
    if (label != label_end)</span>
    {
<span style = "background-color:#fdd">        SameLine(0, g.Style.ItemInnerSpacing.x);
        TextEx(label, label_end);</span>
    }

<span style = "background-color:#fdd">    EndGroup();
    return value_changed;
}</span>

bool ImGui::DragFloat(const char* label, float* v, float v_speed, float v_min, float v_max, const char* format, ImGuiSliderFlags flags)
<span style = "background-color:#fdd">{
    return DragScalar(label, ImGuiDataType_Float, v, v_speed, &amp;v_min, &amp;v_max, format, flags);
}</span>

bool ImGui::DragFloat2(const char* label, float v[2], float v_speed, float v_min, float v_max, const char* format, ImGuiSliderFlags flags)
<span style = "background-color:#fdd">{
    return DragScalarN(label, ImGuiDataType_Float, v, 2, v_speed, &amp;v_min, &amp;v_max, format, flags);
}</span>

bool ImGui::DragFloat3(const char* label, float v[3], float v_speed, float v_min, float v_max, const char* format, ImGuiSliderFlags flags)
<span style = "background-color:#fdd">{
    return DragScalarN(label, ImGuiDataType_Float, v, 3, v_speed, &amp;v_min, &amp;v_max, format, flags);
}</span>

bool ImGui::DragFloat4(const char* label, float v[4], float v_speed, float v_min, float v_max, const char* format, ImGuiSliderFlags flags)
<span style = "background-color:#fdd">{
    return DragScalarN(label, ImGuiDataType_Float, v, 4, v_speed, &amp;v_min, &amp;v_max, format, flags);
}</span>

// NB: You likely want to specify the ImGuiSliderFlags_AlwaysClamp when using this.
bool ImGui::DragFloatRange2(const char* label, float* v_current_min, float* v_current_max, float v_speed, float v_min, float v_max, const char* format, const char* format_max, ImGuiSliderFlags flags)
<span style = "background-color:#fdd">{
    ImGuiWindow* window = GetCurrentWindow();
    if (window-&gt;SkipItems)
        return false;</span>

<span style = "background-color:#fdd">    ImGuiContext&amp; g = *GImGui;
    PushID(label);
    BeginGroup();
    PushMultiItemsWidths(2, CalcItemWidth());</span>

<span style = "background-color:#fdd">    float min_min = (v_min &gt;= v_max) ? -FLT_MAX : v_min;
    float min_max = (v_min &gt;= v_max) ? *v_current_max : ImMin(v_max, *v_current_max);
    ImGuiSliderFlags min_flags = flags | ((min_min == min_max) ? ImGuiSliderFlags_ReadOnly : 0);
    bool value_changed = DragScalar("##min", ImGuiDataType_Float, v_current_min, v_speed, &amp;min_min, &amp;min_max, format, min_flags);
    PopItemWidth();
    SameLine(0, g.Style.ItemInnerSpacing.x);</span>

<span style = "background-color:#fdd">    float max_min = (v_min &gt;= v_max) ? *v_current_min : ImMax(v_min, *v_current_min);
    float max_max = (v_min &gt;= v_max) ? FLT_MAX : v_max;
    ImGuiSliderFlags max_flags = flags | ((max_min == max_max) ? ImGuiSliderFlags_ReadOnly : 0);
    value_changed |= DragScalar("##max", ImGuiDataType_Float, v_current_max, v_speed, &amp;max_min, &amp;max_max, format_max ? format_max : format, max_flags);
    PopItemWidth();
    SameLine(0, g.Style.ItemInnerSpacing.x);</span>

<span style = "background-color:#fdd">    TextEx(label, FindRenderedTextEnd(label));
    EndGroup();
    PopID();</span>

<span style = "background-color:#fdd">    return value_changed;
}</span>

// NB: v_speed is float to allow adjusting the drag speed with more precision
bool ImGui::DragInt(const char* label, int* v, float v_speed, int v_min, int v_max, const char* format, ImGuiSliderFlags flags)
<span style = "background-color:#fdd">{
    return DragScalar(label, ImGuiDataType_S32, v, v_speed, &amp;v_min, &amp;v_max, format, flags);
}</span>

bool ImGui::DragInt2(const char* label, int v[2], float v_speed, int v_min, int v_max, const char* format, ImGuiSliderFlags flags)
<span style = "background-color:#fdd">{
    return DragScalarN(label, ImGuiDataType_S32, v, 2, v_speed, &amp;v_min, &amp;v_max, format, flags);
}</span>

bool ImGui::DragInt3(const char* label, int v[3], float v_speed, int v_min, int v_max, const char* format, ImGuiSliderFlags flags)
<span style = "background-color:#fdd">{
    return DragScalarN(label, ImGuiDataType_S32, v, 3, v_speed, &amp;v_min, &amp;v_max, format, flags);
}</span>

bool ImGui::DragInt4(const char* label, int v[4], float v_speed, int v_min, int v_max, const char* format, ImGuiSliderFlags flags)
<span style = "background-color:#fdd">{
    return DragScalarN(label, ImGuiDataType_S32, v, 4, v_speed, &amp;v_min, &amp;v_max, format, flags);
}</span>

// NB: You likely want to specify the ImGuiSliderFlags_AlwaysClamp when using this.
bool ImGui::DragIntRange2(const char* label, int* v_current_min, int* v_current_max, float v_speed, int v_min, int v_max, const char* format, const char* format_max, ImGuiSliderFlags flags)
<span style = "background-color:#fdd">{
    ImGuiWindow* window = GetCurrentWindow();
    if (window-&gt;SkipItems)
        return false;</span>

<span style = "background-color:#fdd">    ImGuiContext&amp; g = *GImGui;
    PushID(label);
    BeginGroup();
    PushMultiItemsWidths(2, CalcItemWidth());</span>

<span style = "background-color:#fdd">    int min_min = (v_min &gt;= v_max) ? INT_MIN : v_min;
    int min_max = (v_min &gt;= v_max) ? *v_current_max : ImMin(v_max, *v_current_max);
    ImGuiSliderFlags min_flags = flags | ((min_min == min_max) ? ImGuiSliderFlags_ReadOnly : 0);
    bool value_changed = DragInt("##min", v_current_min, v_speed, min_min, min_max, format, min_flags);
    PopItemWidth();
    SameLine(0, g.Style.ItemInnerSpacing.x);</span>

<span style = "background-color:#fdd">    int max_min = (v_min &gt;= v_max) ? *v_current_min : ImMax(v_min, *v_current_min);
    int max_max = (v_min &gt;= v_max) ? INT_MAX : v_max;
    ImGuiSliderFlags max_flags = flags | ((max_min == max_max) ? ImGuiSliderFlags_ReadOnly : 0);
    value_changed |= DragInt("##max", v_current_max, v_speed, max_min, max_max, format_max ? format_max : format, max_flags);
    PopItemWidth();
    SameLine(0, g.Style.ItemInnerSpacing.x);</span>

<span style = "background-color:#fdd">    TextEx(label, FindRenderedTextEnd(label));
    EndGroup();
    PopID();</span>

<span style = "background-color:#fdd">    return value_changed;
}</span>

#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS

// Obsolete versions with power parameter. See https://github.com/ocornut/imgui/issues/3361 for details.
bool ImGui::DragScalar(const char* label, ImGuiDataType data_type, void* p_data, float v_speed, const void* p_min, const void* p_max, const char* format, float power)
<span style = "background-color:#fdd">{
    ImGuiSliderFlags drag_flags = ImGuiSliderFlags_None;
    if (power != 1.0f)</span>
    {
<span style = "background-color:#fdd">        IM_ASSERT(power == 1.0f &amp;&amp; "Call function with ImGuiSliderFlags_Logarithmic flags instead of using the old 'float power' function!");
        IM_ASSERT(p_min != NULL &amp;&amp; p_max != NULL);  // When using a power curve the drag needs to have known bounds
        drag_flags |= ImGuiSliderFlags_Logarithmic;   // Fallback for non-asserting paths</span>
    }
<span style = "background-color:#fdd">    return DragScalar(label, data_type, p_data, v_speed, p_min, p_max, format, drag_flags);
}</span>

bool ImGui::DragScalarN(const char* label, ImGuiDataType data_type, void* p_data, int components, float v_speed, const void* p_min, const void* p_max, const char* format, float power)
<span style = "background-color:#fdd">{
    ImGuiSliderFlags drag_flags = ImGuiSliderFlags_None;
    if (power != 1.0f)</span>
    {
<span style = "background-color:#fdd">        IM_ASSERT(power == 1.0f &amp;&amp; "Call function with ImGuiSliderFlags_Logarithmic flags instead of using the old 'float power' function!");
        IM_ASSERT(p_min != NULL &amp;&amp; p_max != NULL);  // When using a power curve the drag needs to have known bounds
        drag_flags |= ImGuiSliderFlags_Logarithmic;   // Fallback for non-asserting paths</span>
    }
<span style = "background-color:#fdd">    return DragScalarN(label, data_type, p_data, components, v_speed, p_min, p_max, format, drag_flags);
}</span>

#endif // IMGUI_DISABLE_OBSOLETE_FUNCTIONS

//-------------------------------------------------------------------------
// [SECTION] Widgets: SliderScalar, SliderFloat, SliderInt, etc.
//-------------------------------------------------------------------------
// - ScaleRatioFromValueT&lt;&gt; [Internal]
// - ScaleValueFromRatioT&lt;&gt; [Internal]
// - SliderBehaviorT&lt;&gt;() [Internal]
// - SliderBehavior() [Internal]
// - SliderScalar()
// - SliderScalarN()
// - SliderFloat()
// - SliderFloat2()
// - SliderFloat3()
// - SliderFloat4()
// - SliderAngle()
// - SliderInt()
// - SliderInt2()
// - SliderInt3()
// - SliderInt4()
// - VSliderScalar()
// - VSliderFloat()
// - VSliderInt()
//-------------------------------------------------------------------------

// Convert a value v in the output space of a slider into a parametric position on the slider itself (the logical opposite of ScaleValueFromRatioT)
template&lt;typename TYPE, typename SIGNEDTYPE, typename FLOATTYPE&gt;
float ImGui::ScaleRatioFromValueT(ImGuiDataType data_type, TYPE v, TYPE v_min, TYPE v_max, bool is_logarithmic, float logarithmic_zero_epsilon, float zero_deadzone_halfsize)
<span style = "background-color:#dfd">{
    if (v_min == v_max)</span>
<span style = "background-color:#fdd">        return 0.0f;</span>
    IM_UNUSED(data_type);

<span style = "background-color:#dfd">    const TYPE v_clamped = (v_min &lt; v_max) ? ImClamp(v, v_min, v_max) : ImClamp(v, v_max, v_min);
    if (is_logarithmic)</span>
    {
<span style = "background-color:#fdd">        bool flipped = v_max &lt; v_min;</span>

<span style = "background-color:#fdd">        if (flipped) // Handle the case where the range is backwards
            ImSwap(v_min, v_max);</span>

        // Fudge min/max to avoid getting close to log(0)
<span style = "background-color:#fdd">        FLOATTYPE v_min_fudged = (ImAbs((FLOATTYPE)v_min) &lt; logarithmic_zero_epsilon) ? ((v_min &lt; 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_min;
        FLOATTYPE v_max_fudged = (ImAbs((FLOATTYPE)v_max) &lt; logarithmic_zero_epsilon) ? ((v_max &lt; 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_max;</span>

        // Awkward special cases - we need ranges of the form (-100 .. 0) to convert to (-100 .. -epsilon), not (-100 .. epsilon)
<span style = "background-color:#fdd">        if ((v_min == 0.0f) &amp;&amp; (v_max &lt; 0.0f))
            v_min_fudged = -logarithmic_zero_epsilon;
        else if ((v_max == 0.0f) &amp;&amp; (v_min &lt; 0.0f))
            v_max_fudged = -logarithmic_zero_epsilon;</span>

        float result;

<span style = "background-color:#fdd">        if (v_clamped &lt;= v_min_fudged)
            result = 0.0f; // Workaround for values that are in-range but below our fudge
        else if (v_clamped &gt;= v_max_fudged)
            result = 1.0f; // Workaround for values that are in-range but above our fudge
        else if ((v_min * v_max) &lt; 0.0f) // Range crosses zero, so split into two portions</span>
        {
<span style = "background-color:#fdd">            float zero_point_center = (-(float)v_min) / ((float)v_max - (float)v_min); // The zero point in parametric space.  There's an argument we should take the logarithmic nature into account when calculating this, but for now this should do (and the most common case of a symmetrical range works fine)
            float zero_point_snap_L = zero_point_center - zero_deadzone_halfsize;
            float zero_point_snap_R = zero_point_center + zero_deadzone_halfsize;
            if (v == 0.0f)
                result = zero_point_center; // Special case for exactly zero
            else if (v &lt; 0.0f)
                result = (1.0f - (float)(ImLog(-(FLOATTYPE)v_clamped / logarithmic_zero_epsilon) / ImLog(-v_min_fudged / logarithmic_zero_epsilon))) * zero_point_snap_L;</span>
            else
<span style = "background-color:#fdd">                result = zero_point_snap_R + ((float)(ImLog((FLOATTYPE)v_clamped / logarithmic_zero_epsilon) / ImLog(v_max_fudged / logarithmic_zero_epsilon)) * (1.0f - zero_point_snap_R));
        }
        else if ((v_min &lt; 0.0f) || (v_max &lt; 0.0f)) // Entirely negative slider
            result = 1.0f - (float)(ImLog(-(FLOATTYPE)v_clamped / -v_max_fudged) / ImLog(-v_min_fudged / -v_max_fudged));</span>
        else
<span style = "background-color:#fdd">            result = (float)(ImLog((FLOATTYPE)v_clamped / v_min_fudged) / ImLog(v_max_fudged / v_min_fudged));</span>

<span style = "background-color:#fdd">        return flipped ? (1.0f - result) : result;</span>
    }

    // Linear slider
<span style = "background-color:#dfd">    return (float)((FLOATTYPE)(SIGNEDTYPE)(v_clamped - v_min) / (FLOATTYPE)(SIGNEDTYPE)(v_max - v_min));
}</span>

// Convert a parametric position on a slider into a value v in the output space (the logical opposite of ScaleRatioFromValueT)
template&lt;typename TYPE, typename SIGNEDTYPE, typename FLOATTYPE&gt;
TYPE ImGui::ScaleValueFromRatioT(ImGuiDataType data_type, float t, TYPE v_min, TYPE v_max, bool is_logarithmic, float logarithmic_zero_epsilon, float zero_deadzone_halfsize)
<span style = "background-color:#dfd">{
    if (v_min == v_max)</span>
<span style = "background-color:#fdd">        return v_min;</span>
<span style = "background-color:#dfd">    const bool is_floating_point = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);</span>

    TYPE result;
<span style = "background-color:#dfd">    if (is_logarithmic)</span>
    {
        // We special-case the extents because otherwise our fudging can lead to "mathematically correct" but non-intuitive behaviors like a fully-left slider not actually reaching the minimum value
<span style = "background-color:#fdd">        if (t &lt;= 0.0f)
            result = v_min;
        else if (t &gt;= 1.0f)
            result = v_max;</span>
        else
        {
<span style = "background-color:#fdd">            bool flipped = v_max &lt; v_min; // Check if range is "backwards"</span>

            // Fudge min/max to avoid getting silly results close to zero
<span style = "background-color:#fdd">            FLOATTYPE v_min_fudged = (ImAbs((FLOATTYPE)v_min) &lt; logarithmic_zero_epsilon) ? ((v_min &lt; 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_min;
            FLOATTYPE v_max_fudged = (ImAbs((FLOATTYPE)v_max) &lt; logarithmic_zero_epsilon) ? ((v_max &lt; 0.0f) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : (FLOATTYPE)v_max;</span>

<span style = "background-color:#fdd">            if (flipped)
                ImSwap(v_min_fudged, v_max_fudged);</span>

            // Awkward special case - we need ranges of the form (-100 .. 0) to convert to (-100 .. -epsilon), not (-100 .. epsilon)
<span style = "background-color:#fdd">            if ((v_max == 0.0f) &amp;&amp; (v_min &lt; 0.0f))
                v_max_fudged = -logarithmic_zero_epsilon;</span>

<span style = "background-color:#fdd">            float t_with_flip = flipped ? (1.0f - t) : t; // t, but flipped if necessary to account for us flipping the range</span>

<span style = "background-color:#fdd">            if ((v_min * v_max) &lt; 0.0f) // Range crosses zero, so we have to do this in two parts</span>
            {
<span style = "background-color:#fdd">                float zero_point_center = (-(float)ImMin(v_min, v_max)) / ImAbs((float)v_max - (float)v_min); // The zero point in parametric space
                float zero_point_snap_L = zero_point_center - zero_deadzone_halfsize;
                float zero_point_snap_R = zero_point_center + zero_deadzone_halfsize;
                if (t_with_flip &gt;= zero_point_snap_L &amp;&amp; t_with_flip &lt;= zero_point_snap_R)
                    result = (TYPE)0.0f; // Special case to make getting exactly zero possible (the epsilon prevents it otherwise)
                else if (t_with_flip &lt; zero_point_center)
                    result = (TYPE)-(logarithmic_zero_epsilon * ImPow(-v_min_fudged / logarithmic_zero_epsilon, (FLOATTYPE)(1.0f - (t_with_flip / zero_point_snap_L))));</span>
                else
<span style = "background-color:#fdd">                    result = (TYPE)(logarithmic_zero_epsilon * ImPow(v_max_fudged / logarithmic_zero_epsilon, (FLOATTYPE)((t_with_flip - zero_point_snap_R) / (1.0f - zero_point_snap_R))));
            }
            else if ((v_min &lt; 0.0f) || (v_max &lt; 0.0f)) // Entirely negative slider
                result = (TYPE)-(-v_max_fudged * ImPow(-v_min_fudged / -v_max_fudged, (FLOATTYPE)(1.0f - t_with_flip)));</span>
            else
<span style = "background-color:#fdd">                result = (TYPE)(v_min_fudged * ImPow(v_max_fudged / v_min_fudged, (FLOATTYPE)t_with_flip));</span>
        }
<span style = "background-color:#fdd">    }</span>
    else
    {
        // Linear slider
<span style = "background-color:#dfd">        if (is_floating_point)</span>
        {
<span style = "background-color:#dfd">            result = ImLerp(v_min, v_max, t);
        }</span>
        else
        {
            // - For integer values we want the clicking position to match the grab box so we round above
            //   This code is carefully tuned to work with large values (e.g. high ranges of U64) while preserving this property..
            // - Not doing a *1.0 multiply at the end of a range as it tends to be lossy. While absolute aiming at a large s64/u64
            //   range is going to be imprecise anyway, with this check we at least make the edge values matches expected limits.
<span style = "background-color:#fdd">            if (t &lt; 1.0)</span>
            {
<span style = "background-color:#fdd">                FLOATTYPE v_new_off_f = (SIGNEDTYPE)(v_max - v_min) * t;
                result = (TYPE)((SIGNEDTYPE)v_min + (SIGNEDTYPE)(v_new_off_f + (FLOATTYPE)(v_min &gt; v_max ? -0.5 : 0.5)));
            }</span>
            else
            {
<span style = "background-color:#fdd">                result = v_max;</span>
            }
        }
    }

<span style = "background-color:#dfd">    return result;
}</span>

// FIXME: Move more of the code into SliderBehavior()
template&lt;typename TYPE, typename SIGNEDTYPE, typename FLOATTYPE&gt;
bool ImGui::SliderBehaviorT(const ImRect&amp; bb, ImGuiID id, ImGuiDataType data_type, TYPE* v, const TYPE v_min, const TYPE v_max, const char* format, ImGuiSliderFlags flags, ImRect* out_grab_bb)
<span style = "background-color:#dfd">{
    ImGuiContext&amp; g = *GImGui;
    const ImGuiStyle&amp; style = g.Style;</span>

<span style = "background-color:#dfd">    const ImGuiAxis axis = (flags &amp; ImGuiSliderFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X;
    const bool is_logarithmic = (flags &amp; ImGuiSliderFlags_Logarithmic) != 0;
    const bool is_floating_point = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);</span>

<span style = "background-color:#dfd">    const float grab_padding = 2.0f;
    const float slider_sz = (bb.Max[axis] - bb.Min[axis]) - grab_padding * 2.0f;
    float grab_sz = style.GrabMinSize;
    SIGNEDTYPE v_range = (v_min &lt; v_max ? v_max - v_min : v_min - v_max);
    if (!is_floating_point &amp;&amp; v_range &gt;= 0)                                             // v_range &lt; 0 may happen on integer overflows</span>
<span style = "background-color:#fdd">        grab_sz = ImMax((float)(slider_sz / (v_range + 1)), style.GrabMinSize);  // For integer sliders: if possible have the grab size represent 1 unit</span>
<span style = "background-color:#dfd">    grab_sz = ImMin(grab_sz, slider_sz);
    const float slider_usable_sz = slider_sz - grab_sz;
    const float slider_usable_pos_min = bb.Min[axis] + grab_padding + grab_sz * 0.5f;
    const float slider_usable_pos_max = bb.Max[axis] - grab_padding - grab_sz * 0.5f;</span>

<span style = "background-color:#dfd">    float logarithmic_zero_epsilon = 0.0f; // Only valid when is_logarithmic is true
    float zero_deadzone_halfsize = 0.0f; // Only valid when is_logarithmic is true
    if (is_logarithmic)</span>
    {
        // When using logarithmic sliders, we need to clamp to avoid hitting zero, but our choice of clamp value greatly affects slider precision. We attempt to use the specified precision to estimate a good lower bound.
<span style = "background-color:#fdd">        const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 1;
        logarithmic_zero_epsilon = ImPow(0.1f, (float)decimal_precision);
        zero_deadzone_halfsize = (style.LogSliderDeadzone * 0.5f) / ImMax(slider_usable_sz, 1.0f);</span>
    }

    // Process interacting with the slider
<span style = "background-color:#dfd">    bool value_changed = false;
    if (g.ActiveId == id)</span>
    {
<span style = "background-color:#dfd">        bool set_new_value = false;
        float clicked_t = 0.0f;
        if (g.ActiveIdSource == ImGuiInputSource_Mouse)</span>
        {
<span style = "background-color:#dfd">            if (!g.IO.MouseDown[0])</span>
            {
<span style = "background-color:#dfd">                ClearActiveID();
            }</span>
            else
            {
<span style = "background-color:#dfd">                const float mouse_abs_pos = g.IO.MousePos[axis];
                clicked_t = (slider_usable_sz &gt; 0.0f) ? ImClamp((mouse_abs_pos - slider_usable_pos_min) / slider_usable_sz, 0.0f, 1.0f) : 0.0f;
                if (axis == ImGuiAxis_Y)</span>
<span style = "background-color:#fdd">                    clicked_t = 1.0f - clicked_t;</span>
<span style = "background-color:#dfd">                set_new_value = true;</span>
            }
<span style = "background-color:#dfd">        }</span>
<span style = "background-color:#fdd">        else if (g.ActiveIdSource == ImGuiInputSource_Nav)</span>
        {
<span style = "background-color:#fdd">            if (g.ActiveIdIsJustActivated)</span>
            {
<span style = "background-color:#fdd">                g.SliderCurrentAccum = 0.0f; // Reset any stored nav delta upon activation
                g.SliderCurrentAccumDirty = false;</span>
            }

<span style = "background-color:#fdd">            const ImVec2 input_delta2 = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard | ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_RepeatFast, 0.0f, 0.0f);
            float input_delta = (axis == ImGuiAxis_X) ? input_delta2.x : -input_delta2.y;
            if (input_delta != 0.0f)</span>
            {
<span style = "background-color:#fdd">                const int decimal_precision = is_floating_point ? ImParseFormatPrecision(format, 3) : 0;
                if (decimal_precision &gt; 0)</span>
                {
<span style = "background-color:#fdd">                    input_delta /= 100.0f;    // Gamepad/keyboard tweak speeds in % of slider bounds
                    if (IsNavInputDown(ImGuiNavInput_TweakSlow))
                        input_delta /= 10.0f;
                }</span>
                else
                {
<span style = "background-color:#fdd">                    if ((v_range &gt;= -100.0f &amp;&amp; v_range &lt;= 100.0f) || IsNavInputDown(ImGuiNavInput_TweakSlow))
                        input_delta = ((input_delta &lt; 0.0f) ? -1.0f : +1.0f) / (float)v_range; // Gamepad/keyboard tweak speeds in integer steps</span>
                    else
<span style = "background-color:#fdd">                        input_delta /= 100.0f;</span>
                }
<span style = "background-color:#fdd">                if (IsNavInputDown(ImGuiNavInput_TweakFast))
                    input_delta *= 10.0f;</span>

<span style = "background-color:#fdd">                g.SliderCurrentAccum += input_delta;
                g.SliderCurrentAccumDirty = true;</span>
            }

<span style = "background-color:#fdd">            float delta = g.SliderCurrentAccum;
            if (g.NavActivatePressedId == id &amp;&amp; !g.ActiveIdIsJustActivated)</span>
            {
<span style = "background-color:#fdd">                ClearActiveID();
            }
            else if (g.SliderCurrentAccumDirty)</span>
            {
<span style = "background-color:#fdd">                clicked_t = ScaleRatioFromValueT&lt;TYPE, SIGNEDTYPE, FLOATTYPE&gt;(data_type, *v, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);</span>

<span style = "background-color:#fdd">                if ((clicked_t &gt;= 1.0f &amp;&amp; delta &gt; 0.0f) || (clicked_t &lt;= 0.0f &amp;&amp; delta &lt; 0.0f)) // This is to avoid applying the saturation when already past the limits</span>
                {
<span style = "background-color:#fdd">                    set_new_value = false;
                    g.SliderCurrentAccum = 0.0f; // If pushing up against the limits, don't continue to accumulate
                }</span>
                else
                {
<span style = "background-color:#fdd">                    set_new_value = true;
                    float old_clicked_t = clicked_t;
                    clicked_t = ImSaturate(clicked_t + delta);</span>

                    // Calculate what our "new" clicked_t will be, and thus how far we actually moved the slider, and subtract this from the accumulator
<span style = "background-color:#fdd">                    TYPE v_new = ScaleValueFromRatioT&lt;TYPE, SIGNEDTYPE, FLOATTYPE&gt;(data_type, clicked_t, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
                    if (!(flags &amp; ImGuiSliderFlags_NoRoundToFormat))
                        v_new = RoundScalarWithFormatT&lt;TYPE, SIGNEDTYPE&gt;(format, data_type, v_new);
                    float new_clicked_t = ScaleRatioFromValueT&lt;TYPE, SIGNEDTYPE, FLOATTYPE&gt;(data_type, v_new, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);</span>

<span style = "background-color:#fdd">                    if (delta &gt; 0)
                        g.SliderCurrentAccum -= ImMin(new_clicked_t - old_clicked_t, delta);</span>
                    else
<span style = "background-color:#fdd">                        g.SliderCurrentAccum -= ImMax(new_clicked_t - old_clicked_t, delta);</span>
                }

<span style = "background-color:#fdd">                g.SliderCurrentAccumDirty = false;</span>
            }
        }

<span style = "background-color:#dfd">        if (set_new_value)</span>
        {
<span style = "background-color:#dfd">            TYPE v_new = ScaleValueFromRatioT&lt;TYPE, SIGNEDTYPE, FLOATTYPE&gt;(data_type, clicked_t, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);</span>

            // Round to user desired precision based on format string
<span style = "background-color:#dfd">            if (!(flags &amp; ImGuiSliderFlags_NoRoundToFormat))
                v_new = RoundScalarWithFormatT&lt;TYPE, SIGNEDTYPE&gt;(format, data_type, v_new);</span>

            // Apply result
<span style = "background-color:#dfd">            if (*v != v_new)</span>
            {
<span style = "background-color:#dfd">                *v = v_new;
                value_changed = true;</span>
            }
        }
    }

<span style = "background-color:#dfd">    if (slider_sz &lt; 1.0f)</span>
    {
<span style = "background-color:#fdd">        *out_grab_bb = ImRect(bb.Min, bb.Min);
    }</span>
    else
    {
        // Output grab position so it can be displayed by the caller
<span style = "background-color:#dfd">        float grab_t = ScaleRatioFromValueT&lt;TYPE, SIGNEDTYPE, FLOATTYPE&gt;(data_type, *v, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize);
        if (axis == ImGuiAxis_Y)</span>
<span style = "background-color:#fdd">            grab_t = 1.0f - grab_t;</span>
<span style = "background-color:#dfd">        const float grab_pos = ImLerp(slider_usable_pos_min, slider_usable_pos_max, grab_t);
        if (axis == ImGuiAxis_X)
            *out_grab_bb = ImRect(grab_pos - grab_sz * 0.5f, bb.Min.y + grab_padding, grab_pos + grab_sz * 0.5f, bb.Max.y - grab_padding);</span>
        else
<span style = "background-color:#fdd">            *out_grab_bb = ImRect(bb.Min.x + grab_padding, grab_pos - grab_sz * 0.5f, bb.Max.x - grab_padding, grab_pos + grab_sz * 0.5f);</span>
    }

<span style = "background-color:#dfd">    return value_changed;
}</span>

// For 32-bit and larger types, slider bounds are limited to half the natural type range.
// So e.g. an integer Slider between INT_MAX-10 and INT_MAX will fail, but an integer Slider between INT_MAX/2-10 and INT_MAX/2 will be ok.
// It would be possible to lift that limitation with some work but it doesn't seem to be worth it for sliders.
bool ImGui::SliderBehavior(const ImRect&amp; bb, ImGuiID id, ImGuiDataType data_type, void* p_v, const void* p_min, const void* p_max, const char* format, ImGuiSliderFlags flags, ImRect* out_grab_bb)
<span style = "background-color:#dfd">{</span>
    // Read imgui.cpp "API BREAKING CHANGES" section for 1.78 if you hit this assert.
<span style = "background-color:#dfd">    IM_ASSERT((flags == 1 || (flags &amp; ImGuiSliderFlags_InvalidMask_) == 0) &amp;&amp; "Invalid ImGuiSliderFlags flag!  Has the 'float power' argument been mistakenly cast to flags? Call function with ImGuiSliderFlags_Logarithmic flags instead.");</span>

<span style = "background-color:#dfd">    ImGuiContext&amp; g = *GImGui;
    if ((g.LastItemData.InFlags &amp; ImGuiItemFlags_ReadOnly) || (flags &amp; ImGuiSliderFlags_ReadOnly))</span>
<span style = "background-color:#fdd">        return false;</span>

<span style = "background-color:#dfd">    switch (data_type)</span>
    {
<span style = "background-color:#fdd">    case ImGuiDataType_S8:  { ImS32 v32 = (ImS32)*(ImS8*)p_v;  bool r = SliderBehaviorT&lt;ImS32, ImS32, float&gt;(bb, id, ImGuiDataType_S32, &amp;v32, *(const ImS8*)p_min,  *(const ImS8*)p_max,  format, flags, out_grab_bb); if (r) *(ImS8*)p_v  = (ImS8)v32;  return r; }
    case ImGuiDataType_U8:  { ImU32 v32 = (ImU32)*(ImU8*)p_v;  bool r = SliderBehaviorT&lt;ImU32, ImS32, float&gt;(bb, id, ImGuiDataType_U32, &amp;v32, *(const ImU8*)p_min,  *(const ImU8*)p_max,  format, flags, out_grab_bb); if (r) *(ImU8*)p_v  = (ImU8)v32;  return r; }
    case ImGuiDataType_S16: { ImS32 v32 = (ImS32)*(ImS16*)p_v; bool r = SliderBehaviorT&lt;ImS32, ImS32, float&gt;(bb, id, ImGuiDataType_S32, &amp;v32, *(const ImS16*)p_min, *(const ImS16*)p_max, format, flags, out_grab_bb); if (r) *(ImS16*)p_v = (ImS16)v32; return r; }
    case ImGuiDataType_U16: { ImU32 v32 = (ImU32)*(ImU16*)p_v; bool r = SliderBehaviorT&lt;ImU32, ImS32, float&gt;(bb, id, ImGuiDataType_U32, &amp;v32, *(const ImU16*)p_min, *(const ImU16*)p_max, format, flags, out_grab_bb); if (r) *(ImU16*)p_v = (ImU16)v32; return r; }</span>
    case ImGuiDataType_S32:
<span style = "background-color:#fdd">        IM_ASSERT(*(const ImS32*)p_min &gt;= IM_S32_MIN / 2 &amp;&amp; *(const ImS32*)p_max &lt;= IM_S32_MAX / 2);
        return SliderBehaviorT&lt;ImS32, ImS32, float &gt;(bb, id, data_type, (ImS32*)p_v,  *(const ImS32*)p_min,  *(const ImS32*)p_max,  format, flags, out_grab_bb);</span>
    case ImGuiDataType_U32:
<span style = "background-color:#fdd">        IM_ASSERT(*(const ImU32*)p_max &lt;= IM_U32_MAX / 2);
        return SliderBehaviorT&lt;ImU32, ImS32, float &gt;(bb, id, data_type, (ImU32*)p_v,  *(const ImU32*)p_min,  *(const ImU32*)p_max,  format, flags, out_grab_bb);</span>
    case ImGuiDataType_S64:
<span style = "background-color:#fdd">        IM_ASSERT(*(const ImS64*)p_min &gt;= IM_S64_MIN / 2 &amp;&amp; *(const ImS64*)p_max &lt;= IM_S64_MAX / 2);
        return SliderBehaviorT&lt;ImS64, ImS64, double&gt;(bb, id, data_type, (ImS64*)p_v,  *(const ImS64*)p_min,  *(const ImS64*)p_max,  format, flags, out_grab_bb);</span>
    case ImGuiDataType_U64:
<span style = "background-color:#fdd">        IM_ASSERT(*(const ImU64*)p_max &lt;= IM_U64_MAX / 2);
        return SliderBehaviorT&lt;ImU64, ImS64, double&gt;(bb, id, data_type, (ImU64*)p_v,  *(const ImU64*)p_min,  *(const ImU64*)p_max,  format, flags, out_grab_bb);</span>
    case ImGuiDataType_Float:
<span style = "background-color:#dfd">        IM_ASSERT(*(const float*)p_min &gt;= -FLT_MAX / 2.0f &amp;&amp; *(const float*)p_max &lt;= FLT_MAX / 2.0f);
        return SliderBehaviorT&lt;float, float, float &gt;(bb, id, data_type, (float*)p_v,  *(const float*)p_min,  *(const float*)p_max,  format, flags, out_grab_bb);</span>
    case ImGuiDataType_Double:
<span style = "background-color:#fdd">        IM_ASSERT(*(const double*)p_min &gt;= -DBL_MAX / 2.0f &amp;&amp; *(const double*)p_max &lt;= DBL_MAX / 2.0f);
        return SliderBehaviorT&lt;double, double, double&gt;(bb, id, data_type, (double*)p_v, *(const double*)p_min, *(const double*)p_max, format, flags, out_grab_bb);</span>
    case ImGuiDataType_COUNT: break;
    }
<span style = "background-color:#fdd">    IM_ASSERT(0);
    return false;</span>
<span style = "background-color:#dfd">}</span>

// Note: p_data, p_min and p_max are _pointers_ to a memory address holding the data. For a slider, they are all required.
// Read code of e.g. SliderFloat(), SliderInt() etc. or examples in 'Demo-&gt;Widgets-&gt;Data Types' to understand how to use this function directly.
bool ImGui::SliderScalar(const char* label, ImGuiDataType data_type, void* p_data, const void* p_min, const void* p_max, const char* format, ImGuiSliderFlags flags)
<span style = "background-color:#dfd">{
    ImGuiWindow* window = GetCurrentWindow();
    if (window-&gt;SkipItems)</span>
<span style = "background-color:#fdd">        return false;</span>

<span style = "background-color:#dfd">    ImGuiContext&amp; g = *GImGui;
    const ImGuiStyle&amp; style = g.Style;
    const ImGuiID id = window-&gt;GetID(label);
    const float w = CalcItemWidth();</span>

<span style = "background-color:#dfd">    const ImVec2 label_size = CalcTextSize(label, NULL, true);
    const ImRect frame_bb(window-&gt;DC.CursorPos, window-&gt;DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y * 2.0f));
    const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x &gt; 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));</span>

<span style = "background-color:#dfd">    const bool temp_input_allowed = (flags &amp; ImGuiSliderFlags_NoInput) == 0;
    ItemSize(total_bb, style.FramePadding.y);
    if (!ItemAdd(total_bb, id, &amp;frame_bb, temp_input_allowed ? ImGuiItemFlags_Inputable : 0))</span>
<span style = "background-color:#fdd">        return false;</span>

    // Default format string when passing NULL
<span style = "background-color:#dfd">    if (format == NULL)</span>
<span style = "background-color:#fdd">        format = DataTypeGetInfo(data_type)-&gt;PrintFmt;</span>
<span style = "background-color:#dfd">    else if (data_type == ImGuiDataType_S32 &amp;&amp; strcmp(format, "%d") != 0) // (FIXME-LEGACY: Patch old "%.0f" format string to use "%d", read function more details.)</span>
<span style = "background-color:#fdd">        format = PatchFormatStringFloatToInt(format);</span>

    // Tabbing or CTRL-clicking on Slider turns it into an input box
<span style = "background-color:#dfd">    const bool hovered = ItemHoverable(frame_bb, id);
    bool temp_input_is_active = temp_input_allowed &amp;&amp; TempInputIsActive(id);
    if (!temp_input_is_active)</span>
    {
<span style = "background-color:#dfd">        const bool input_requested_by_tabbing = temp_input_allowed &amp;&amp; (g.LastItemData.StatusFlags &amp; ImGuiItemStatusFlags_FocusedByTabbing) != 0;
        const bool clicked = (hovered &amp;&amp; g.IO.MouseClicked[0]);
        if (input_requested_by_tabbing || clicked || g.NavActivateId == id || g.NavActivateInputId == id)</span>
        {
<span style = "background-color:#dfd">            SetActiveID(id, window);
            SetFocusID(id, window);
            FocusWindow(window);
            g.ActiveIdUsingNavDirMask |= (1 &lt;&lt; ImGuiDir_Left) | (1 &lt;&lt; ImGuiDir_Right);
            if (temp_input_allowed &amp;&amp; (input_requested_by_tabbing || (clicked &amp;&amp; g.IO.KeyCtrl) || g.NavActivateInputId == id))</span>
<span style = "background-color:#fdd">                temp_input_is_active = true;</span>
        }
    }

<span style = "background-color:#dfd">    if (temp_input_is_active)</span>
    {
        // Only clamp CTRL+Click input when ImGuiSliderFlags_AlwaysClamp is set
<span style = "background-color:#fdd">        const bool is_clamp_input = (flags &amp; ImGuiSliderFlags_AlwaysClamp) != 0;
        return TempInputScalar(frame_bb, id, label, data_type, p_data, format, is_clamp_input ? p_min : NULL, is_clamp_input ? p_max : NULL);</span>
    }

    // Draw frame
<span style = "background-color:#dfd">    const ImU32 frame_col = GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);
    RenderNavHighlight(frame_bb, id);
    RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, g.Style.FrameRounding);</span>

    // Slider behavior
<span style = "background-color:#dfd">    ImRect grab_bb;
    const bool value_changed = SliderBehavior(frame_bb, id, data_type, p_data, p_min, p_max, format, flags, &amp;grab_bb);
    if (value_changed)
        MarkItemEdited(id);</span>

    // Render grab
<span style = "background-color:#dfd">    if (grab_bb.Max.x &gt; grab_bb.Min.x)
        window-&gt;DrawList-&gt;AddRectFilled(grab_bb.Min, grab_bb.Max, GetColorU32(g.ActiveId == id ? ImGuiCol_SliderGrabActive : ImGuiCol_SliderGrab), style.GrabRounding);</span>

    // Display value using user-provided display format so user can add prefix/suffix/decorations to the value.
    char value_buf[64];
<span style = "background-color:#dfd">    const char* value_buf_end = value_buf + DataTypeFormatString(value_buf, IM_ARRAYSIZE(value_buf), data_type, p_data, format);
    if (g.LogEnabled)</span>
<span style = "background-color:#fdd">        LogSetNextTextDecoration("{", "}");</span>
<span style = "background-color:#dfd">    RenderTextClipped(frame_bb.Min, frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f, 0.5f));</span>

<span style = "background-color:#dfd">    if (label_size.x &gt; 0.0f)
        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);</span>

    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags);
<span style = "background-color:#dfd">    return value_changed;
}</span>

// Add multiple sliders on 1 line for compact edition of multiple components
bool ImGui::SliderScalarN(const char* label, ImGuiDataType data_type, void* v, int components, const void* v_min, const void* v_max, const char* format, ImGuiSliderFlags flags)
<span style = "background-color:#fdd">{
    ImGuiWindow* window = GetCurrentWindow();
    if (window-&gt;SkipItems)
        return false;</span>

<span style = "background-color:#fdd">    ImGuiContext&amp; g = *GImGui;
    bool value_changed = false;
    BeginGroup();
    PushID(label);
    PushMultiItemsWidths(components, CalcItemWidth());
    size_t type_size = GDataTypeInfo[data_type].Size;
    for (int i = 0; i &lt; components; i++)</span>
    {
<span style = "background-color:#fdd">        PushID(i);
        if (i &gt; 0)
            SameLine(0, g.Style.ItemInnerSpacing.x);
        value_changed |= SliderScalar("", data_type, v, v_min, v_max, format, flags);
        PopID();
        PopItemWidth();
        v = (void*)((char*)v + type_size);
    }
    PopID();</span>

<span style = "background-color:#fdd">    const char* label_end = FindRenderedTextEnd(label);
    if (label != label_end)</span>
    {
<span style = "background-color:#fdd">        SameLine(0, g.Style.ItemInnerSpacing.x);
        TextEx(label, label_end);</span>
    }

<span style = "background-color:#fdd">    EndGroup();
    return value_changed;
}</span>

bool ImGui::SliderFloat(const char* label, float* v, float v_min, float v_max, const char* format, ImGuiSliderFlags flags)
<span style = "background-color:#dfd">{
    return SliderScalar(label, ImGuiDataType_Float, v, &amp;v_min, &amp;v_max, format, flags);
}</span>

bool ImGui::SliderFloat2(const char* label, float v[2], float v_min, float v_max, const char* format, ImGuiSliderFlags flags)
<span style = "background-color:#fdd">{
    return SliderScalarN(label, ImGuiDataType_Float, v, 2, &amp;v_min, &amp;v_max, format, flags);
}</span>

bool ImGui::SliderFloat3(const char* label, float v[3], float v_min, float v_max, const char* format, ImGuiSliderFlags flags)
<span style = "background-color:#fdd">{
    return SliderScalarN(label, ImGuiDataType_Float, v, 3, &amp;v_min, &amp;v_max, format, flags);
}</span>

bool ImGui::SliderFloat4(const char* label, float v[4], float v_min, float v_max, const char* format, ImGuiSliderFlags flags)
<span style = "background-color:#fdd">{
    return SliderScalarN(label, ImGuiDataType_Float, v, 4, &amp;v_min, &amp;v_max, format, flags);
}</span>

bool ImGui::SliderAngle(const char* label, float* v_rad, float v_degrees_min, float v_degrees_max, const char* format, ImGuiSliderFlags flags)
<span style = "background-color:#fdd">{
    if (format == NULL)
        format = "%.0f deg";
    float v_deg = (*v_rad) * 360.0f / (2 * IM_PI);
    bool value_changed = SliderFloat(label, &amp;v_deg, v_degrees_min, v_degrees_max, format, flags);
    *v_rad = v_deg * (2 * IM_PI) / 360.0f;
    return value_changed;
}</span>

bool ImGui::SliderInt(const char* label, int* v, int v_min, int v_max, const char* format, ImGuiSliderFlags flags)
<span style = "background-color:#fdd">{
    return SliderScalar(label, ImGuiDataType_S32, v, &amp;v_min, &amp;v_max, format, flags);
}</span>

bool ImGui::SliderInt2(const char* label, int v[2], int v_min, int v_max, const char* format, ImGuiSliderFlags flags)
<span style = "background-color:#fdd">{
    return SliderScalarN(label, ImGuiDataType_S32, v, 2, &amp;v_min, &amp;v_max, format, flags);
}</span>

bool ImGui::SliderInt3(const char* label, int v[3], int v_min, int v_max, const char* format, ImGuiSliderFlags flags)
<span style = "background-color:#fdd">{
    return SliderScalarN(label, ImGuiDataType_S32, v, 3, &amp;v_min, &amp;v_max, format, flags);
}</span>

bool ImGui::SliderInt4(const char* label, int v[4], int v_min, int v_max, const char* format, ImGuiSliderFlags flags)
<span style = "background-color:#fdd">{
    return SliderScalarN(label, ImGuiDataType_S32, v, 4, &amp;v_min, &amp;v_max, format, flags);
}</span>

bool ImGui::VSliderScalar(const char* label, const ImVec2&amp; size, ImGuiDataType data_type, void* p_data, const void* p_min, const void* p_max, const char* format, ImGuiSliderFlags flags)
<span style = "background-color:#fdd">{
    ImGuiWindow* window = GetCurrentWindow();
    if (window-&gt;SkipItems)
        return false;</span>

<span style = "background-color:#fdd">    ImGuiContext&amp; g = *GImGui;
    const ImGuiStyle&amp; style = g.Style;
    const ImGuiID id = window-&gt;GetID(label);</span>

<span style = "background-color:#fdd">    const ImVec2 label_size = CalcTextSize(label, NULL, true);
    const ImRect frame_bb(window-&gt;DC.CursorPos, window-&gt;DC.CursorPos + size);
    const ImRect bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x &gt; 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));</span>

<span style = "background-color:#fdd">    ItemSize(bb, style.FramePadding.y);
    if (!ItemAdd(frame_bb, id))
        return false;</span>

    // Default format string when passing NULL
<span style = "background-color:#fdd">    if (format == NULL)
        format = DataTypeGetInfo(data_type)-&gt;PrintFmt;
    else if (data_type == ImGuiDataType_S32 &amp;&amp; strcmp(format, "%d") != 0) // (FIXME-LEGACY: Patch old "%.0f" format string to use "%d", read function more details.)
        format = PatchFormatStringFloatToInt(format);</span>

<span style = "background-color:#fdd">    const bool hovered = ItemHoverable(frame_bb, id);
    if ((hovered &amp;&amp; g.IO.MouseClicked[0]) || g.NavActivateId == id || g.NavActivateInputId == id)</span>
    {
<span style = "background-color:#fdd">        SetActiveID(id, window);
        SetFocusID(id, window);
        FocusWindow(window);
        g.ActiveIdUsingNavDirMask |= (1 &lt;&lt; ImGuiDir_Up) | (1 &lt;&lt; ImGuiDir_Down);</span>
    }

    // Draw frame
<span style = "background-color:#fdd">    const ImU32 frame_col = GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);
    RenderNavHighlight(frame_bb, id);
    RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, g.Style.FrameRounding);</span>

    // Slider behavior
<span style = "background-color:#fdd">    ImRect grab_bb;
    const bool value_changed = SliderBehavior(frame_bb, id, data_type, p_data, p_min, p_max, format, flags | ImGuiSliderFlags_Vertical, &amp;grab_bb);
    if (value_changed)
        MarkItemEdited(id);</span>

    // Render grab
<span style = "background-color:#fdd">    if (grab_bb.Max.y &gt; grab_bb.Min.y)
        window-&gt;DrawList-&gt;AddRectFilled(grab_bb.Min, grab_bb.Max, GetColorU32(g.ActiveId == id ? ImGuiCol_SliderGrabActive : ImGuiCol_SliderGrab), style.GrabRounding);</span>

    // Display value using user-provided display format so user can add prefix/suffix/decorations to the value.
    // For the vertical slider we allow centered text to overlap the frame padding
    char value_buf[64];
<span style = "background-color:#fdd">    const char* value_buf_end = value_buf + DataTypeFormatString(value_buf, IM_ARRAYSIZE(value_buf), data_type, p_data, format);
    RenderTextClipped(ImVec2(frame_bb.Min.x, frame_bb.Min.y + style.FramePadding.y), frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f, 0.0f));
    if (label_size.x &gt; 0.0f)
        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);</span>

<span style = "background-color:#fdd">    return value_changed;
}</span>

bool ImGui::VSliderFloat(const char* label, const ImVec2&amp; size, float* v, float v_min, float v_max, const char* format, ImGuiSliderFlags flags)
<span style = "background-color:#fdd">{
    return VSliderScalar(label, size, ImGuiDataType_Float, v, &amp;v_min, &amp;v_max, format, flags);
}</span>

bool ImGui::VSliderInt(const char* label, const ImVec2&amp; size, int* v, int v_min, int v_max, const char* format, ImGuiSliderFlags flags)
<span style = "background-color:#fdd">{
    return VSliderScalar(label, size, ImGuiDataType_S32, v, &amp;v_min, &amp;v_max, format, flags);
}</span>

#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS

// Obsolete versions with power parameter. See https://github.com/ocornut/imgui/issues/3361 for details.
bool ImGui::SliderScalar(const char* label, ImGuiDataType data_type, void* p_data, const void* p_min, const void* p_max, const char* format, float power)
<span style = "background-color:#fdd">{
    ImGuiSliderFlags slider_flags = ImGuiSliderFlags_None;
    if (power != 1.0f)</span>
    {
<span style = "background-color:#fdd">        IM_ASSERT(power == 1.0f &amp;&amp; "Call function with ImGuiSliderFlags_Logarithmic flags instead of using the old 'float power' function!");
        slider_flags |= ImGuiSliderFlags_Logarithmic;   // Fallback for non-asserting paths</span>
    }
<span style = "background-color:#fdd">    return SliderScalar(label, data_type, p_data, p_min, p_max, format, slider_flags);
}</span>

bool ImGui::SliderScalarN(const char* label, ImGuiDataType data_type, void* v, int components, const void* v_min, const void* v_max, const char* format, float power)
<span style = "background-color:#fdd">{
    ImGuiSliderFlags slider_flags = ImGuiSliderFlags_None;
    if (power != 1.0f)</span>
    {
<span style = "background-color:#fdd">        IM_ASSERT(power == 1.0f &amp;&amp; "Call function with ImGuiSliderFlags_Logarithmic flags instead of using the old 'float power' function!");
        slider_flags |= ImGuiSliderFlags_Logarithmic;   // Fallback for non-asserting paths</span>
    }
<span style = "background-color:#fdd">    return SliderScalarN(label, data_type, v, components, v_min, v_max, format, slider_flags);
}</span>

#endif // IMGUI_DISABLE_OBSOLETE_FUNCTIONS

//-------------------------------------------------------------------------
// [SECTION] Widgets: InputScalar, InputFloat, InputInt, etc.
//-------------------------------------------------------------------------
// - ImParseFormatFindStart() [Internal]
// - ImParseFormatFindEnd() [Internal]
// - ImParseFormatTrimDecorations() [Internal]
// - ImParseFormatPrecision() [Internal]
// - TempInputTextScalar() [Internal]
// - InputScalar()
// - InputScalarN()
// - InputFloat()
// - InputFloat2()
// - InputFloat3()
// - InputFloat4()
// - InputInt()
// - InputInt2()
// - InputInt3()
// - InputInt4()
// - InputDouble()
//-------------------------------------------------------------------------

// We don't use strchr() because our strings are usually very short and often start with '%'
const char* ImParseFormatFindStart(const char* fmt)
<span style = "background-color:#dfd">{
    while (char c = fmt[0])</span>
    {
<span style = "background-color:#dfd">        if (c == '%' &amp;&amp; fmt[1] != '%')
            return fmt;</span>
<span style = "background-color:#fdd">        else if (c == '%')
            fmt++;
        fmt++;
    }
    return fmt;</span>
<span style = "background-color:#dfd">}</span>

const char* ImParseFormatFindEnd(const char* fmt)
<span style = "background-color:#dfd">{</span>
    // Printf/scanf types modifiers: I/L/h/j/l/t/w/z. Other uppercase letters qualify as types aka end of the format.
<span style = "background-color:#dfd">    if (fmt[0] != '%')</span>
<span style = "background-color:#fdd">        return fmt;</span>
<span style = "background-color:#dfd">    const unsigned int ignored_uppercase_mask = (1 &lt;&lt; ('I'-'A')) | (1 &lt;&lt; ('L'-'A'));
    const unsigned int ignored_lowercase_mask = (1 &lt;&lt; ('h'-'a')) | (1 &lt;&lt; ('j'-'a')) | (1 &lt;&lt; ('l'-'a')) | (1 &lt;&lt; ('t'-'a')) | (1 &lt;&lt; ('w'-'a')) | (1 &lt;&lt; ('z'-'a'));
    for (char c; (c = *fmt) != 0; fmt++)</span>
    {
<span style = "background-color:#dfd">        if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z' &amp;&amp; ((1 &lt;&lt; (c - 'A')) &amp; ignored_uppercase_mask) == 0)</span>
<span style = "background-color:#fdd">            return fmt + 1;</span>
<span style = "background-color:#dfd">        if (c &gt;= 'a' &amp;&amp; c &lt;= 'z' &amp;&amp; ((1 &lt;&lt; (c - 'a')) &amp; ignored_lowercase_mask) == 0)
            return fmt + 1;
    }</span>
<span style = "background-color:#fdd">    return fmt;</span>
<span style = "background-color:#dfd">}</span>

// Extract the format out of a format string with leading or trailing decorations
//  fmt = "blah blah"  -&gt; return fmt
//  fmt = "%.3f"       -&gt; return fmt
//  fmt = "hello %.3f" -&gt; return fmt + 6
//  fmt = "%.3f hello" -&gt; return buf written with "%.3f"
const char* ImParseFormatTrimDecorations(const char* fmt, char* buf, size_t buf_size)
<span style = "background-color:#fdd">{
    const char* fmt_start = ImParseFormatFindStart(fmt);
    if (fmt_start[0] != '%')
        return fmt;
    const char* fmt_end = ImParseFormatFindEnd(fmt_start);
    if (fmt_end[0] == 0) // If we only have leading decoration, we don't need to copy the data.
        return fmt_start;
    ImStrncpy(buf, fmt_start, ImMin((size_t)(fmt_end - fmt_start) + 1, buf_size));
    return buf;
}</span>

// Parse display precision back from the display format string
// FIXME: This is still used by some navigation code path to infer a minimum tweak step, but we should aim to rework widgets so it isn't needed.
int ImParseFormatPrecision(const char* fmt, int default_precision)
<span style = "background-color:#fdd">{
    fmt = ImParseFormatFindStart(fmt);
    if (fmt[0] != '%')
        return default_precision;
    fmt++;
    while (*fmt &gt;= '0' &amp;&amp; *fmt &lt;= '9')
        fmt++;
    int precision = INT_MAX;
    if (*fmt == '.')</span>
    {
<span style = "background-color:#fdd">        fmt = ImAtoi&lt;int&gt;(fmt + 1, &amp;precision);
        if (precision &lt; 0 || precision &gt; 99)
            precision = default_precision;</span>
    }
<span style = "background-color:#fdd">    if (*fmt == 'e' || *fmt == 'E') // Maximum precision with scientific notation
        precision = -1;
    if ((*fmt == 'g' || *fmt == 'G') &amp;&amp; precision == INT_MAX)
        precision = -1;
    return (precision == INT_MAX) ? default_precision : precision;
}</span>

// Create text input in place of another active widget (e.g. used when doing a CTRL+Click on drag/slider widgets)
// FIXME: Facilitate using this in variety of other situations.
bool ImGui::TempInputText(const ImRect&amp; bb, ImGuiID id, const char* label, char* buf, int buf_size, ImGuiInputTextFlags flags)
<span style = "background-color:#fdd">{</span>
    // On the first frame, g.TempInputTextId == 0, then on subsequent frames it becomes == id.
    // We clear ActiveID on the first frame to allow the InputText() taking it back.
<span style = "background-color:#fdd">    ImGuiContext&amp; g = *GImGui;
    const bool init = (g.TempInputId != id);
    if (init)
        ClearActiveID();</span>

<span style = "background-color:#fdd">    g.CurrentWindow-&gt;DC.CursorPos = bb.Min;
    bool value_changed = InputTextEx(label, NULL, buf, buf_size, bb.GetSize(), flags | ImGuiInputTextFlags_MergedItem);
    if (init)</span>
    {
        // First frame we started displaying the InputText widget, we expect it to take the active id.
<span style = "background-color:#fdd">        IM_ASSERT(g.ActiveId == id);
        g.TempInputId = g.ActiveId;</span>
    }
<span style = "background-color:#fdd">    return value_changed;
}</span>

// Note that Drag/Slider functions are only forwarding the min/max values clamping values if the ImGuiSliderFlags_AlwaysClamp flag is set!
// This is intended: this way we allow CTRL+Click manual input to set a value out of bounds, for maximum flexibility.
// However this may not be ideal for all uses, as some user code may break on out of bound values.
bool ImGui::TempInputScalar(const ImRect&amp; bb, ImGuiID id, const char* label, ImGuiDataType data_type, void* p_data, const char* format, const void* p_clamp_min, const void* p_clamp_max)
<span style = "background-color:#fdd">{
    ImGuiContext&amp; g = *GImGui;</span>

    char fmt_buf[32];
    char data_buf[32];
<span style = "background-color:#fdd">    format = ImParseFormatTrimDecorations(format, fmt_buf, IM_ARRAYSIZE(fmt_buf));
    DataTypeFormatString(data_buf, IM_ARRAYSIZE(data_buf), data_type, p_data, format);
    ImStrTrimBlanks(data_buf);</span>

<span style = "background-color:#fdd">    ImGuiInputTextFlags flags = ImGuiInputTextFlags_AutoSelectAll | ImGuiInputTextFlags_NoMarkEdited;
    flags |= ((data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double) ? ImGuiInputTextFlags_CharsScientific : ImGuiInputTextFlags_CharsDecimal);
    bool value_changed = false;
    if (TempInputText(bb, id, label, data_buf, IM_ARRAYSIZE(data_buf), flags))</span>
    {
        // Backup old value
<span style = "background-color:#fdd">        size_t data_type_size = DataTypeGetInfo(data_type)-&gt;Size;</span>
        ImGuiDataTypeTempStorage data_backup;
<span style = "background-color:#fdd">        memcpy(&amp;data_backup, p_data, data_type_size);</span>

        // Apply new value (or operations) then clamp
<span style = "background-color:#fdd">        DataTypeApplyOpFromText(data_buf, g.InputTextState.InitialTextA.Data, data_type, p_data, NULL);
        if (p_clamp_min || p_clamp_max)</span>
        {
<span style = "background-color:#fdd">            if (p_clamp_min &amp;&amp; p_clamp_max &amp;&amp; DataTypeCompare(data_type, p_clamp_min, p_clamp_max) &gt; 0)
                ImSwap(p_clamp_min, p_clamp_max);
            DataTypeClamp(data_type, p_data, p_clamp_min, p_clamp_max);</span>
        }

        // Only mark as edited if new value is different
<span style = "background-color:#fdd">        value_changed = memcmp(&amp;data_backup, p_data, data_type_size) != 0;
        if (value_changed)
            MarkItemEdited(id);</span>
    }
<span style = "background-color:#fdd">    return value_changed;
}</span>

// Note: p_data, p_step, p_step_fast are _pointers_ to a memory address holding the data. For an Input widget, p_step and p_step_fast are optional.
// Read code of e.g. InputFloat(), InputInt() etc. or examples in 'Demo-&gt;Widgets-&gt;Data Types' to understand how to use this function directly.
bool ImGui::InputScalar(const char* label, ImGuiDataType data_type, void* p_data, const void* p_step, const void* p_step_fast, const char* format, ImGuiInputTextFlags flags)
<span style = "background-color:#fdd">{
    ImGuiWindow* window = GetCurrentWindow();
    if (window-&gt;SkipItems)
        return false;</span>

<span style = "background-color:#fdd">    ImGuiContext&amp; g = *GImGui;
    ImGuiStyle&amp; style = g.Style;</span>

<span style = "background-color:#fdd">    if (format == NULL)
        format = DataTypeGetInfo(data_type)-&gt;PrintFmt;</span>

    char buf[64];
<span style = "background-color:#fdd">    DataTypeFormatString(buf, IM_ARRAYSIZE(buf), data_type, p_data, format);</span>

<span style = "background-color:#fdd">    bool value_changed = false;
    if ((flags &amp; (ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsScientific)) == 0)
        flags |= ImGuiInputTextFlags_CharsDecimal;
    flags |= ImGuiInputTextFlags_AutoSelectAll;
    flags |= ImGuiInputTextFlags_NoMarkEdited;  // We call MarkItemEdited() ourselves by comparing the actual data rather than the string.</span>

<span style = "background-color:#fdd">    if (p_step != NULL)</span>
    {
<span style = "background-color:#fdd">        const float button_size = GetFrameHeight();</span>

<span style = "background-color:#fdd">        BeginGroup(); // The only purpose of the group here is to allow the caller to query item data e.g. IsItemActive()
        PushID(label);
        SetNextItemWidth(ImMax(1.0f, CalcItemWidth() - (button_size + style.ItemInnerSpacing.x) * 2));
        if (InputText("", buf, IM_ARRAYSIZE(buf), flags)) // PushId(label) + "" gives us the expected ID from outside point of view
            value_changed = DataTypeApplyOpFromText(buf, g.InputTextState.InitialTextA.Data, data_type, p_data, format);</span>

        // Step buttons
<span style = "background-color:#fdd">        const ImVec2 backup_frame_padding = style.FramePadding;
        style.FramePadding.x = style.FramePadding.y;
        ImGuiButtonFlags button_flags = ImGuiButtonFlags_Repeat | ImGuiButtonFlags_DontClosePopups;
        if (flags &amp; ImGuiInputTextFlags_ReadOnly)
            BeginDisabled();
        SameLine(0, style.ItemInnerSpacing.x);
        if (ButtonEx("-", ImVec2(button_size, button_size), button_flags))</span>
        {
<span style = "background-color:#fdd">            DataTypeApplyOp(data_type, '-', p_data, p_data, g.IO.KeyCtrl &amp;&amp; p_step_fast ? p_step_fast : p_step);
            value_changed = true;</span>
        }
<span style = "background-color:#fdd">        SameLine(0, style.ItemInnerSpacing.x);
        if (ButtonEx("+", ImVec2(button_size, button_size), button_flags))</span>
        {
<span style = "background-color:#fdd">            DataTypeApplyOp(data_type, '+', p_data, p_data, g.IO.KeyCtrl &amp;&amp; p_step_fast ? p_step_fast : p_step);
            value_changed = true;</span>
        }
<span style = "background-color:#fdd">        if (flags &amp; ImGuiInputTextFlags_ReadOnly)
            EndDisabled();</span>

<span style = "background-color:#fdd">        const char* label_end = FindRenderedTextEnd(label);
        if (label != label_end)</span>
        {
<span style = "background-color:#fdd">            SameLine(0, style.ItemInnerSpacing.x);
            TextEx(label, label_end);</span>
        }
<span style = "background-color:#fdd">        style.FramePadding = backup_frame_padding;</span>

<span style = "background-color:#fdd">        PopID();
        EndGroup();
    }</span>
    else
    {
<span style = "background-color:#fdd">        if (InputText(label, buf, IM_ARRAYSIZE(buf), flags))
            value_changed = DataTypeApplyOpFromText(buf, g.InputTextState.InitialTextA.Data, data_type, p_data, format);</span>
    }
<span style = "background-color:#fdd">    if (value_changed)
        MarkItemEdited(g.LastItemData.ID);</span>

<span style = "background-color:#fdd">    return value_changed;
}</span>

bool ImGui::InputScalarN(const char* label, ImGuiDataType data_type, void* p_data, int components, const void* p_step, const void* p_step_fast, const char* format, ImGuiInputTextFlags flags)
<span style = "background-color:#fdd">{
    ImGuiWindow* window = GetCurrentWindow();
    if (window-&gt;SkipItems)
        return false;</span>

<span style = "background-color:#fdd">    ImGuiContext&amp; g = *GImGui;
    bool value_changed = false;
    BeginGroup();
    PushID(label);
    PushMultiItemsWidths(components, CalcItemWidth());
    size_t type_size = GDataTypeInfo[data_type].Size;
    for (int i = 0; i &lt; components; i++)</span>
    {
<span style = "background-color:#fdd">        PushID(i);
        if (i &gt; 0)
            SameLine(0, g.Style.ItemInnerSpacing.x);
        value_changed |= InputScalar("", data_type, p_data, p_step, p_step_fast, format, flags);
        PopID();
        PopItemWidth();
        p_data = (void*)((char*)p_data + type_size);
    }
    PopID();</span>

<span style = "background-color:#fdd">    const char* label_end = FindRenderedTextEnd(label);
    if (label != label_end)</span>
    {
<span style = "background-color:#fdd">        SameLine(0.0f, g.Style.ItemInnerSpacing.x);
        TextEx(label, label_end);</span>
    }

<span style = "background-color:#fdd">    EndGroup();
    return value_changed;
}</span>

bool ImGui::InputFloat(const char* label, float* v, float step, float step_fast, const char* format, ImGuiInputTextFlags flags)
<span style = "background-color:#fdd">{
    flags |= ImGuiInputTextFlags_CharsScientific;
    return InputScalar(label, ImGuiDataType_Float, (void*)v, (void*)(step &gt; 0.0f ? &amp;step : NULL), (void*)(step_fast &gt; 0.0f ? &amp;step_fast : NULL), format, flags);
}</span>

bool ImGui::InputFloat2(const char* label, float v[2], const char* format, ImGuiInputTextFlags flags)
<span style = "background-color:#fdd">{
    return InputScalarN(label, ImGuiDataType_Float, v, 2, NULL, NULL, format, flags);
}</span>

bool ImGui::InputFloat3(const char* label, float v[3], const char* format, ImGuiInputTextFlags flags)
<span style = "background-color:#fdd">{
    return InputScalarN(label, ImGuiDataType_Float, v, 3, NULL, NULL, format, flags);
}</span>

bool ImGui::InputFloat4(const char* label, float v[4], const char* format, ImGuiInputTextFlags flags)
<span style = "background-color:#fdd">{
    return InputScalarN(label, ImGuiDataType_Float, v, 4, NULL, NULL, format, flags);
}</span>

bool ImGui::InputInt(const char* label, int* v, int step, int step_fast, ImGuiInputTextFlags flags)
<span style = "background-color:#fdd">{</span>
    // Hexadecimal input provided as a convenience but the flag name is awkward. Typically you'd use InputText() to parse your own data, if you want to handle prefixes.
<span style = "background-color:#fdd">    const char* format = (flags &amp; ImGuiInputTextFlags_CharsHexadecimal) ? "%08X" : "%d";
    return InputScalar(label, ImGuiDataType_S32, (void*)v, (void*)(step &gt; 0 ? &amp;step : NULL), (void*)(step_fast &gt; 0 ? &amp;step_fast : NULL), format, flags);
}</span>

bool ImGui::InputInt2(const char* label, int v[2], ImGuiInputTextFlags flags)
<span style = "background-color:#fdd">{
    return InputScalarN(label, ImGuiDataType_S32, v, 2, NULL, NULL, "%d", flags);
}</span>

bool ImGui::InputInt3(const char* label, int v[3], ImGuiInputTextFlags flags)
<span style = "background-color:#fdd">{
    return InputScalarN(label, ImGuiDataType_S32, v, 3, NULL, NULL, "%d", flags);
}</span>

bool ImGui::InputInt4(const char* label, int v[4], ImGuiInputTextFlags flags)
<span style = "background-color:#fdd">{
    return InputScalarN(label, ImGuiDataType_S32, v, 4, NULL, NULL, "%d", flags);
}</span>

bool ImGui::InputDouble(const char* label, double* v, double step, double step_fast, const char* format, ImGuiInputTextFlags flags)
<span style = "background-color:#fdd">{
    flags |= ImGuiInputTextFlags_CharsScientific;
    return InputScalar(label, ImGuiDataType_Double, (void*)v, (void*)(step &gt; 0.0 ? &amp;step : NULL), (void*)(step_fast &gt; 0.0 ? &amp;step_fast : NULL), format, flags);
}</span>

//-------------------------------------------------------------------------
// [SECTION] Widgets: InputText, InputTextMultiline, InputTextWithHint
//-------------------------------------------------------------------------
// - InputText()
// - InputTextWithHint()
// - InputTextMultiline()
// - InputTextEx() [Internal]
//-------------------------------------------------------------------------

bool ImGui::InputText(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data)
<span style = "background-color:#fdd">{
    IM_ASSERT(!(flags &amp; ImGuiInputTextFlags_Multiline)); // call InputTextMultiline()
    return InputTextEx(label, NULL, buf, (int)buf_size, ImVec2(0, 0), flags, callback, user_data);
}</span>

bool ImGui::InputTextMultiline(const char* label, char* buf, size_t buf_size, const ImVec2&amp; size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data)
<span style = "background-color:#fdd">{
    return InputTextEx(label, NULL, buf, (int)buf_size, size, flags | ImGuiInputTextFlags_Multiline, callback, user_data);
}</span>

bool ImGui::InputTextWithHint(const char* label, const char* hint, char* buf, size_t buf_size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data)
<span style = "background-color:#fdd">{
    IM_ASSERT(!(flags &amp; ImGuiInputTextFlags_Multiline)); // call InputTextMultiline()
    return InputTextEx(label, hint, buf, (int)buf_size, ImVec2(0, 0), flags, callback, user_data);
}</span>

static int InputTextCalcTextLenAndLineCount(const char* text_begin, const char** out_text_end)
<span style = "background-color:#fdd">{
    int line_count = 0;
    const char* s = text_begin;
    while (char c = *s++) // We are only matching for \n so we can ignore UTF-8 decoding
        if (c == '\n')
            line_count++;
    s--;
    if (s[0] != '\n' &amp;&amp; s[0] != '\r')
        line_count++;
    *out_text_end = s;
    return line_count;
}</span>

static ImVec2 InputTextCalcTextSizeW(const ImWchar* text_begin, const ImWchar* text_end, const ImWchar** remaining, ImVec2* out_offset, bool stop_on_new_line)
<span style = "background-color:#fdd">{
    ImGuiContext&amp; g = *GImGui;
    ImFont* font = g.Font;
    const float line_height = g.FontSize;
    const float scale = line_height / font-&gt;FontSize;</span>

<span style = "background-color:#fdd">    ImVec2 text_size = ImVec2(0, 0);
    float line_width = 0.0f;</span>

<span style = "background-color:#fdd">    const ImWchar* s = text_begin;
    while (s &lt; text_end)</span>
    {
<span style = "background-color:#fdd">        unsigned int c = (unsigned int)(*s++);
        if (c == '\n')</span>
        {
<span style = "background-color:#fdd">            text_size.x = ImMax(text_size.x, line_width);
            text_size.y += line_height;
            line_width = 0.0f;
            if (stop_on_new_line)
                break;
            continue;</span>
        }
<span style = "background-color:#fdd">        if (c == '\r')
            continue;</span>

<span style = "background-color:#fdd">        const float char_width = font-&gt;GetCharAdvance((ImWchar)c) * scale;
        line_width += char_width;
    }</span>

<span style = "background-color:#fdd">    if (text_size.x &lt; line_width)
        text_size.x = line_width;</span>

<span style = "background-color:#fdd">    if (out_offset)
        *out_offset = ImVec2(line_width, text_size.y + line_height);  // offset allow for the possibility of sitting after a trailing \n</span>

<span style = "background-color:#fdd">    if (line_width &gt; 0 || text_size.y == 0.0f)                        // whereas size.y will ignore the trailing \n
        text_size.y += line_height;</span>

<span style = "background-color:#fdd">    if (remaining)
        *remaining = s;</span>

<span style = "background-color:#fdd">    return text_size;
}</span>

// Wrapper for stb_textedit.h to edit text (our wrapper is for: statically sized buffer, single-line, wchar characters. InputText converts between UTF-8 and wchar)
namespace ImStb
{

<span style = "background-color:#fdd">static int     STB_TEXTEDIT_STRINGLEN(const ImGuiInputTextState* obj)                             { return obj-&gt;CurLenW; }
static ImWchar STB_TEXTEDIT_GETCHAR(const ImGuiInputTextState* obj, int idx)                      { return obj-&gt;TextW[idx]; }
static float   STB_TEXTEDIT_GETWIDTH(ImGuiInputTextState* obj, int line_start_idx, int char_idx)  { ImWchar c = obj-&gt;TextW[line_start_idx + char_idx]; if (c == '\n') return STB_TEXTEDIT_GETWIDTH_NEWLINE; ImGuiContext&amp; g = *GImGui; return g.Font-&gt;GetCharAdvance(c) * (g.FontSize / g.Font-&gt;FontSize); }
static int     STB_TEXTEDIT_KEYTOTEXT(int key)                                                    { return key &gt;= 0x200000 ? 0 : key; }</span>
static ImWchar STB_TEXTEDIT_NEWLINE = '\n';
static void    STB_TEXTEDIT_LAYOUTROW(StbTexteditRow* r, ImGuiInputTextState* obj, int line_start_idx)
<span style = "background-color:#fdd">{
    const ImWchar* text = obj-&gt;TextW.Data;
    const ImWchar* text_remaining = NULL;
    const ImVec2 size = InputTextCalcTextSizeW(text + line_start_idx, text + obj-&gt;CurLenW, &amp;text_remaining, NULL, true);
    r-&gt;x0 = 0.0f;
    r-&gt;x1 = size.x;
    r-&gt;baseline_y_delta = size.y;
    r-&gt;ymin = 0.0f;
    r-&gt;ymax = size.y;
    r-&gt;num_chars = (int)(text_remaining - (text + line_start_idx));
}</span>

// When ImGuiInputTextFlags_Password is set, we don't want actions such as CTRL+Arrow to leak the fact that underlying data are blanks or separators.
<span style = "background-color:#fdd">static bool is_separator(unsigned int c)                                        { return ImCharIsBlankW(c) || c==',' || c==';' || c=='(' || c==')' || c=='{' || c=='}' || c=='[' || c==']' || c=='|' || c=='\n' || c=='\r'; }
static int  is_word_boundary_from_right(ImGuiInputTextState* obj, int idx)      { if (obj-&gt;Flags &amp; ImGuiInputTextFlags_Password) return 0; return idx &gt; 0 ? (is_separator(obj-&gt;TextW[idx - 1]) &amp;&amp; !is_separator(obj-&gt;TextW[idx]) ) : 1; }
static int  is_word_boundary_from_left(ImGuiInputTextState* obj, int idx)       { if (obj-&gt;Flags &amp; ImGuiInputTextFlags_Password) return 0; return idx &gt; 0 ? (!is_separator(obj-&gt;TextW[idx - 1]) &amp;&amp; is_separator(obj-&gt;TextW[idx])) : 1; }
static int  STB_TEXTEDIT_MOVEWORDLEFT_IMPL(ImGuiInputTextState* obj, int idx)   { idx--; while (idx &gt;= 0 &amp;&amp; !is_word_boundary_from_right(obj, idx)) idx--; return idx &lt; 0 ? 0 : idx; }
static int  STB_TEXTEDIT_MOVEWORDRIGHT_MAC(ImGuiInputTextState* obj, int idx)   { idx++; int len = obj-&gt;CurLenW; while (idx &lt; len &amp;&amp; !is_word_boundary_from_left(obj, idx)) idx++; return idx &gt; len ? len : idx; }
static int  STB_TEXTEDIT_MOVEWORDRIGHT_WIN(ImGuiInputTextState* obj, int idx)   { idx++; int len = obj-&gt;CurLenW; while (idx &lt; len &amp;&amp; !is_word_boundary_from_right(obj, idx)) idx++; return idx &gt; len ? len : idx; }</span>
#define STB_TEXTEDIT_MOVEWORDLEFT   STB_TEXTEDIT_MOVEWORDLEFT_IMPL    // They need to be #define for stb_textedit.h
#ifdef __APPLE__    // FIXME: Move setting to IO structure
#define STB_TEXTEDIT_MOVEWORDRIGHT  STB_TEXTEDIT_MOVEWORDRIGHT_MAC
#else
#define STB_TEXTEDIT_MOVEWORDRIGHT  STB_TEXTEDIT_MOVEWORDRIGHT_WIN
#endif

static void STB_TEXTEDIT_DELETECHARS(ImGuiInputTextState* obj, int pos, int n)
<span style = "background-color:#fdd">{
    ImWchar* dst = obj-&gt;TextW.Data + pos;</span>

    // We maintain our buffer length in both UTF-8 and wchar formats
<span style = "background-color:#fdd">    obj-&gt;Edited = true;
    obj-&gt;CurLenA -= ImTextCountUtf8BytesFromStr(dst, dst + n);
    obj-&gt;CurLenW -= n;</span>

    // Offset remaining text (FIXME-OPT: Use memmove)
<span style = "background-color:#fdd">    const ImWchar* src = obj-&gt;TextW.Data + pos + n;
    while (ImWchar c = *src++)
        *dst++ = c;
    *dst = '\0';
}</span>

static bool STB_TEXTEDIT_INSERTCHARS(ImGuiInputTextState* obj, int pos, const ImWchar* new_text, int new_text_len)
<span style = "background-color:#fdd">{
    const bool is_resizable = (obj-&gt;Flags &amp; ImGuiInputTextFlags_CallbackResize) != 0;
    const int text_len = obj-&gt;CurLenW;
    IM_ASSERT(pos &lt;= text_len);</span>

<span style = "background-color:#fdd">    const int new_text_len_utf8 = ImTextCountUtf8BytesFromStr(new_text, new_text + new_text_len);
    if (!is_resizable &amp;&amp; (new_text_len_utf8 + obj-&gt;CurLenA + 1 &gt; obj-&gt;BufCapacityA))
        return false;</span>

    // Grow internal buffer if needed
<span style = "background-color:#fdd">    if (new_text_len + text_len + 1 &gt; obj-&gt;TextW.Size)</span>
    {
<span style = "background-color:#fdd">        if (!is_resizable)
            return false;
        IM_ASSERT(text_len &lt; obj-&gt;TextW.Size);
        obj-&gt;TextW.resize(text_len + ImClamp(new_text_len * 4, 32, ImMax(256, new_text_len)) + 1);</span>
    }

<span style = "background-color:#fdd">    ImWchar* text = obj-&gt;TextW.Data;
    if (pos != text_len)
        memmove(text + pos + new_text_len, text + pos, (size_t)(text_len - pos) * sizeof(ImWchar));
    memcpy(text + pos, new_text, (size_t)new_text_len * sizeof(ImWchar));</span>

<span style = "background-color:#fdd">    obj-&gt;Edited = true;
    obj-&gt;CurLenW += new_text_len;
    obj-&gt;CurLenA += new_text_len_utf8;
    obj-&gt;TextW[obj-&gt;CurLenW] = '\0';</span>

<span style = "background-color:#fdd">    return true;
}</span>

// We don't use an enum so we can build even with conflicting symbols (if another user of stb_textedit.h leak their STB_TEXTEDIT_K_* symbols)
#define STB_TEXTEDIT_K_LEFT         0x200000 // keyboard input to move cursor left
#define STB_TEXTEDIT_K_RIGHT        0x200001 // keyboard input to move cursor right
#define STB_TEXTEDIT_K_UP           0x200002 // keyboard input to move cursor up
#define STB_TEXTEDIT_K_DOWN         0x200003 // keyboard input to move cursor down
#define STB_TEXTEDIT_K_LINESTART    0x200004 // keyboard input to move cursor to start of line
#define STB_TEXTEDIT_K_LINEEND      0x200005 // keyboard input to move cursor to end of line
#define STB_TEXTEDIT_K_TEXTSTART    0x200006 // keyboard input to move cursor to start of text
#define STB_TEXTEDIT_K_TEXTEND      0x200007 // keyboard input to move cursor to end of text
#define STB_TEXTEDIT_K_DELETE       0x200008 // keyboard input to delete selection or character under cursor
#define STB_TEXTEDIT_K_BACKSPACE    0x200009 // keyboard input to delete selection or character left of cursor
#define STB_TEXTEDIT_K_UNDO         0x20000A // keyboard input to perform undo
#define STB_TEXTEDIT_K_REDO         0x20000B // keyboard input to perform redo
#define STB_TEXTEDIT_K_WORDLEFT     0x20000C // keyboard input to move cursor left one word
#define STB_TEXTEDIT_K_WORDRIGHT    0x20000D // keyboard input to move cursor right one word
#define STB_TEXTEDIT_K_PGUP         0x20000E // keyboard input to move cursor up a page
#define STB_TEXTEDIT_K_PGDOWN       0x20000F // keyboard input to move cursor down a page
#define STB_TEXTEDIT_K_SHIFT        0x400000

#define STB_TEXTEDIT_IMPLEMENTATION
#include "imstb_textedit.h"

// stb_textedit internally allows for a single undo record to do addition and deletion, but somehow, calling
// the stb_textedit_paste() function creates two separate records, so we perform it manually. (FIXME: Report to nothings/stb?)
static void stb_textedit_replace(ImGuiInputTextState* str, STB_TexteditState* state, const STB_TEXTEDIT_CHARTYPE* text, int text_len)
<span style = "background-color:#fdd">{
    stb_text_makeundo_replace(str, state, 0, str-&gt;CurLenW, text_len);
    ImStb::STB_TEXTEDIT_DELETECHARS(str, 0, str-&gt;CurLenW);
    if (text_len &lt;= 0)
        return;
    if (ImStb::STB_TEXTEDIT_INSERTCHARS(str, 0, text, text_len))</span>
    {
<span style = "background-color:#fdd">        state-&gt;cursor = text_len;
        state-&gt;has_preferred_x = 0;
        return;</span>
    }
<span style = "background-color:#fdd">    IM_ASSERT(0); // Failed to insert character, normally shouldn't happen because of how we currently use stb_textedit_replace()
}</span>

} // namespace ImStb

void ImGuiInputTextState::OnKeyPressed(int key)
<span style = "background-color:#fdd">{
    stb_textedit_key(this, &amp;Stb, key);
    CursorFollow = true;
    CursorAnimReset();
}</span>

ImGuiInputTextCallbackData::ImGuiInputTextCallbackData()
<span style = "background-color:#fdd">{
    memset(this, 0, sizeof(*this));
}</span>

// Public API to manipulate UTF-8 text
// We expose UTF-8 to the user (unlike the STB_TEXTEDIT_* functions which are manipulating wchar)
// FIXME: The existence of this rarely exercised code path is a bit of a nuisance.
void ImGuiInputTextCallbackData::DeleteChars(int pos, int bytes_count)
<span style = "background-color:#fdd">{
    IM_ASSERT(pos + bytes_count &lt;= BufTextLen);
    char* dst = Buf + pos;
    const char* src = Buf + pos + bytes_count;
    while (char c = *src++)
        *dst++ = c;
    *dst = '\0';</span>

<span style = "background-color:#fdd">    if (CursorPos &gt;= pos + bytes_count)
        CursorPos -= bytes_count;
    else if (CursorPos &gt;= pos)
        CursorPos = pos;
    SelectionStart = SelectionEnd = CursorPos;
    BufDirty = true;
    BufTextLen -= bytes_count;
}</span>

void ImGuiInputTextCallbackData::InsertChars(int pos, const char* new_text, const char* new_text_end)
<span style = "background-color:#fdd">{
    const bool is_resizable = (Flags &amp; ImGuiInputTextFlags_CallbackResize) != 0;
    const int new_text_len = new_text_end ? (int)(new_text_end - new_text) : (int)strlen(new_text);
    if (new_text_len + BufTextLen &gt;= BufSize)</span>
    {
<span style = "background-color:#fdd">        if (!is_resizable)
            return;</span>

        // Contrary to STB_TEXTEDIT_INSERTCHARS() this is working in the UTF8 buffer, hence the mildly similar code (until we remove the U16 buffer altogether!)
<span style = "background-color:#fdd">        ImGuiContext&amp; g = *GImGui;
        ImGuiInputTextState* edit_state = &amp;g.InputTextState;
        IM_ASSERT(edit_state-&gt;ID != 0 &amp;&amp; g.ActiveId == edit_state-&gt;ID);
        IM_ASSERT(Buf == edit_state-&gt;TextA.Data);
        int new_buf_size = BufTextLen + ImClamp(new_text_len * 4, 32, ImMax(256, new_text_len)) + 1;
        edit_state-&gt;TextA.reserve(new_buf_size + 1);
        Buf = edit_state-&gt;TextA.Data;
        BufSize = edit_state-&gt;BufCapacityA = new_buf_size;</span>
    }

<span style = "background-color:#fdd">    if (BufTextLen != pos)
        memmove(Buf + pos + new_text_len, Buf + pos, (size_t)(BufTextLen - pos));
    memcpy(Buf + pos, new_text, (size_t)new_text_len * sizeof(char));
    Buf[BufTextLen + new_text_len] = '\0';</span>

<span style = "background-color:#fdd">    if (CursorPos &gt;= pos)
        CursorPos += new_text_len;
    SelectionStart = SelectionEnd = CursorPos;
    BufDirty = true;
    BufTextLen += new_text_len;
}</span>

// Return false to discard a character.
static bool InputTextFilterCharacter(unsigned int* p_char, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data, ImGuiInputSource input_source)
<span style = "background-color:#fdd">{
    IM_ASSERT(input_source == ImGuiInputSource_Keyboard || input_source == ImGuiInputSource_Clipboard);
    unsigned int c = *p_char;</span>

    // Filter non-printable (NB: isprint is unreliable! see #2467)
<span style = "background-color:#fdd">    bool apply_named_filters = true;
    if (c &lt; 0x20)</span>
    {
<span style = "background-color:#fdd">        bool pass = false;
        pass |= (c == '\n' &amp;&amp; (flags &amp; ImGuiInputTextFlags_Multiline));
        pass |= (c == '\t' &amp;&amp; (flags &amp; ImGuiInputTextFlags_AllowTabInput));
        if (!pass)
            return false;
        apply_named_filters = false; // Override named filters below so newline and tabs can still be inserted.</span>
    }

<span style = "background-color:#fdd">    if (input_source != ImGuiInputSource_Clipboard)</span>
    {
        // We ignore Ascii representation of delete (emitted from Backspace on OSX, see #2578, #2817)
<span style = "background-color:#fdd">        if (c == 127)
            return false;</span>

        // Filter private Unicode range. GLFW on OSX seems to send private characters for special keys like arrow keys (FIXME)
<span style = "background-color:#fdd">        if (c &gt;= 0xE000 &amp;&amp; c &lt;= 0xF8FF)
            return false;</span>
    }

    // Filter Unicode ranges we are not handling in this build
<span style = "background-color:#fdd">    if (c &gt; IM_UNICODE_CODEPOINT_MAX)
        return false;</span>

    // Generic named filters
<span style = "background-color:#fdd">    if (apply_named_filters &amp;&amp; (flags &amp; (ImGuiInputTextFlags_CharsDecimal | ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsUppercase | ImGuiInputTextFlags_CharsNoBlank | ImGuiInputTextFlags_CharsScientific)))</span>
    {
        // The libc allows overriding locale, with e.g. 'setlocale(LC_NUMERIC, "de_DE.UTF-8");' which affect the output/input of printf/scanf to use e.g. ',' instead of '.'.
        // The standard mandate that programs starts in the "C" locale where the decimal point is '.'.
        // We don't really intend to provide widespread support for it, but out of empathy for people stuck with using odd API, we support the bare minimum aka overriding the decimal point.
        // Change the default decimal_point with:
        //   ImGui::GetCurrentContext()-&gt;PlatformLocaleDecimalPoint = *localeconv()-&gt;decimal_point;
        // Users of non-default decimal point (in particular ',') may be affected by word-selection logic (is_word_boundary_from_right/is_word_boundary_from_left) functions.
<span style = "background-color:#fdd">        ImGuiContext&amp; g = *GImGui;
        const unsigned c_decimal_point = (unsigned int)g.PlatformLocaleDecimalPoint;</span>

        // Allow 0-9 . - + * /
<span style = "background-color:#fdd">        if (flags &amp; ImGuiInputTextFlags_CharsDecimal)
            if (!(c &gt;= '0' &amp;&amp; c &lt;= '9') &amp;&amp; (c != c_decimal_point) &amp;&amp; (c != '-') &amp;&amp; (c != '+') &amp;&amp; (c != '*') &amp;&amp; (c != '/'))
                return false;</span>

        // Allow 0-9 . - + * / e E
<span style = "background-color:#fdd">        if (flags &amp; ImGuiInputTextFlags_CharsScientific)
            if (!(c &gt;= '0' &amp;&amp; c &lt;= '9') &amp;&amp; (c != c_decimal_point) &amp;&amp; (c != '-') &amp;&amp; (c != '+') &amp;&amp; (c != '*') &amp;&amp; (c != '/') &amp;&amp; (c != 'e') &amp;&amp; (c != 'E'))
                return false;</span>

        // Allow 0-9 a-F A-F
<span style = "background-color:#fdd">        if (flags &amp; ImGuiInputTextFlags_CharsHexadecimal)
            if (!(c &gt;= '0' &amp;&amp; c &lt;= '9') &amp;&amp; !(c &gt;= 'a' &amp;&amp; c &lt;= 'f') &amp;&amp; !(c &gt;= 'A' &amp;&amp; c &lt;= 'F'))
                return false;</span>

        // Turn a-z into A-Z
<span style = "background-color:#fdd">        if (flags &amp; ImGuiInputTextFlags_CharsUppercase)
            if (c &gt;= 'a' &amp;&amp; c &lt;= 'z')
                *p_char = (c += (unsigned int)('A' - 'a'));</span>

<span style = "background-color:#fdd">        if (flags &amp; ImGuiInputTextFlags_CharsNoBlank)
            if (ImCharIsBlankW(c))
                return false;</span>
    }

    // Custom callback filter
<span style = "background-color:#fdd">    if (flags &amp; ImGuiInputTextFlags_CallbackCharFilter)</span>
    {
<span style = "background-color:#fdd">        ImGuiInputTextCallbackData callback_data;
        memset(&amp;callback_data, 0, sizeof(ImGuiInputTextCallbackData));
        callback_data.EventFlag = ImGuiInputTextFlags_CallbackCharFilter;
        callback_data.EventChar = (ImWchar)c;
        callback_data.Flags = flags;
        callback_data.UserData = user_data;
        if (callback(&amp;callback_data) != 0)
            return false;
        *p_char = callback_data.EventChar;
        if (!callback_data.EventChar)
            return false;</span>
    }

<span style = "background-color:#fdd">    return true;
}</span>

// Edit a string of text
// - buf_size account for the zero-terminator, so a buf_size of 6 can hold "Hello" but not "Hello!".
//   This is so we can easily call InputText() on static arrays using ARRAYSIZE() and to match
//   Note that in std::string world, capacity() would omit 1 byte used by the zero-terminator.
// - When active, hold on a privately held copy of the text (and apply back to 'buf'). So changing 'buf' while the InputText is active has no effect.
// - If you want to use ImGui::InputText() with std::string, see misc/cpp/imgui_stdlib.h
// (FIXME: Rather confusing and messy function, among the worse part of our codebase, expecting to rewrite a V2 at some point.. Partly because we are
//  doing UTF8 &gt; U16 &gt; UTF8 conversions on the go to easily interface with stb_textedit. Ideally should stay in UTF-8 all the time. See https://github.com/nothings/stb/issues/188)
bool ImGui::InputTextEx(const char* label, const char* hint, char* buf, int buf_size, const ImVec2&amp; size_arg, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* callback_user_data)
<span style = "background-color:#fdd">{
    ImGuiWindow* window = GetCurrentWindow();
    if (window-&gt;SkipItems)
        return false;</span>

<span style = "background-color:#fdd">    IM_ASSERT(buf != NULL &amp;&amp; buf_size &gt;= 0);
    IM_ASSERT(!((flags &amp; ImGuiInputTextFlags_CallbackHistory) &amp;&amp; (flags &amp; ImGuiInputTextFlags_Multiline)));        // Can't use both together (they both use up/down keys)
    IM_ASSERT(!((flags &amp; ImGuiInputTextFlags_CallbackCompletion) &amp;&amp; (flags &amp; ImGuiInputTextFlags_AllowTabInput))); // Can't use both together (they both use tab key)</span>

<span style = "background-color:#fdd">    ImGuiContext&amp; g = *GImGui;
    ImGuiIO&amp; io = g.IO;
    const ImGuiStyle&amp; style = g.Style;</span>

<span style = "background-color:#fdd">    const bool RENDER_SELECTION_WHEN_INACTIVE = false;
    const bool is_multiline = (flags &amp; ImGuiInputTextFlags_Multiline) != 0;
    const bool is_readonly = (flags &amp; ImGuiInputTextFlags_ReadOnly) != 0;
    const bool is_password = (flags &amp; ImGuiInputTextFlags_Password) != 0;
    const bool is_undoable = (flags &amp; ImGuiInputTextFlags_NoUndoRedo) == 0;
    const bool is_resizable = (flags &amp; ImGuiInputTextFlags_CallbackResize) != 0;
    if (is_resizable)
        IM_ASSERT(callback != NULL); // Must provide a callback if you set the ImGuiInputTextFlags_CallbackResize flag!</span>

<span style = "background-color:#fdd">    if (is_multiline) // Open group before calling GetID() because groups tracks id created within their scope,
        BeginGroup();
    const ImGuiID id = window-&gt;GetID(label);
    const ImVec2 label_size = CalcTextSize(label, NULL, true);
    const ImVec2 frame_size = CalcItemSize(size_arg, CalcItemWidth(), (is_multiline ? g.FontSize * 8.0f : label_size.y) + style.FramePadding.y * 2.0f); // Arbitrary default of 8 lines high for multi-line
    const ImVec2 total_size = ImVec2(frame_size.x + (label_size.x &gt; 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f), frame_size.y);</span>

<span style = "background-color:#fdd">    const ImRect frame_bb(window-&gt;DC.CursorPos, window-&gt;DC.CursorPos + frame_size);
    const ImRect total_bb(frame_bb.Min, frame_bb.Min + total_size);</span>

<span style = "background-color:#fdd">    ImGuiWindow* draw_window = window;
    ImVec2 inner_size = frame_size;
    ImGuiItemStatusFlags item_status_flags = 0;
    if (is_multiline)</span>
    {
<span style = "background-color:#fdd">        ImVec2 backup_pos = window-&gt;DC.CursorPos;
        ItemSize(total_bb, style.FramePadding.y);
        if (!ItemAdd(total_bb, id, &amp;frame_bb, ImGuiItemFlags_Inputable))</span>
        {
<span style = "background-color:#fdd">            EndGroup();
            return false;</span>
        }
<span style = "background-color:#fdd">        item_status_flags = g.LastItemData.StatusFlags;
        window-&gt;DC.CursorPos = backup_pos;</span>

        // We reproduce the contents of BeginChildFrame() in order to provide 'label' so our window internal data are easier to read/debug.
        // FIXME-NAV: Pressing NavActivate will trigger general child activation right before triggering our own below. Harmless but bizarre.
<span style = "background-color:#fdd">        PushStyleColor(ImGuiCol_ChildBg, style.Colors[ImGuiCol_FrameBg]);
        PushStyleVar(ImGuiStyleVar_ChildRounding, style.FrameRounding);
        PushStyleVar(ImGuiStyleVar_ChildBorderSize, style.FrameBorderSize);
        bool child_visible = BeginChildEx(label, id, frame_bb.GetSize(), true, ImGuiWindowFlags_NoMove);
        PopStyleVar(2);
        PopStyleColor();
        if (!child_visible)</span>
        {
<span style = "background-color:#fdd">            EndChild();
            EndGroup();
            return false;</span>
        }
<span style = "background-color:#fdd">        draw_window = g.CurrentWindow; // Child window
        draw_window-&gt;DC.NavLayersActiveMaskNext |= (1 &lt;&lt; draw_window-&gt;DC.NavLayerCurrent); // This is to ensure that EndChild() will display a navigation highlight so we can "enter" into it.
        draw_window-&gt;DC.CursorPos += style.FramePadding;
        inner_size.x -= draw_window-&gt;ScrollbarSizes.x;
    }</span>
    else
    {
        // Support for internal ImGuiInputTextFlags_MergedItem flag, which could be redesigned as an ItemFlags if needed (with test performed in ItemAdd)
<span style = "background-color:#fdd">        ItemSize(total_bb, style.FramePadding.y);
        if (!(flags &amp; ImGuiInputTextFlags_MergedItem))
            if (!ItemAdd(total_bb, id, &amp;frame_bb, ImGuiItemFlags_Inputable))
                return false;
        item_status_flags = g.LastItemData.StatusFlags;</span>
    }
<span style = "background-color:#fdd">    const bool hovered = ItemHoverable(frame_bb, id);
    if (hovered)
        g.MouseCursor = ImGuiMouseCursor_TextInput;</span>

    // We are only allowed to access the state if we are already the active widget.
<span style = "background-color:#fdd">    ImGuiInputTextState* state = GetInputTextState(id);</span>

<span style = "background-color:#fdd">    const bool input_requested_by_tabbing = (item_status_flags &amp; ImGuiItemStatusFlags_FocusedByTabbing) != 0;
    const bool input_requested_by_nav = (g.ActiveId != id) &amp;&amp; ((g.NavActivateInputId == id) || (g.NavActivateId == id &amp;&amp; g.NavInputSource == ImGuiInputSource_Keyboard));</span>

<span style = "background-color:#fdd">    const bool user_clicked = hovered &amp;&amp; io.MouseClicked[0];
    const bool user_scroll_finish = is_multiline &amp;&amp; state != NULL &amp;&amp; g.ActiveId == 0 &amp;&amp; g.ActiveIdPreviousFrame == GetWindowScrollbarID(draw_window, ImGuiAxis_Y);
    const bool user_scroll_active = is_multiline &amp;&amp; state != NULL &amp;&amp; g.ActiveId == GetWindowScrollbarID(draw_window, ImGuiAxis_Y);
    bool clear_active_id = false;
    bool select_all = false;</span>

<span style = "background-color:#fdd">    float scroll_y = is_multiline ? draw_window-&gt;Scroll.y : FLT_MAX;</span>

<span style = "background-color:#fdd">    const bool init_changed_specs = (state != NULL &amp;&amp; state-&gt;Stb.single_line != !is_multiline);
    const bool init_make_active = (user_clicked || user_scroll_finish || input_requested_by_nav || input_requested_by_tabbing);
    const bool init_state = (init_make_active || user_scroll_active);
    if ((init_state &amp;&amp; g.ActiveId != id) || init_changed_specs)</span>
    {
        // Access state even if we don't own it yet.
<span style = "background-color:#fdd">        state = &amp;g.InputTextState;
        state-&gt;CursorAnimReset();</span>

        // Take a copy of the initial buffer value (both in original UTF-8 format and converted to wchar)
        // From the moment we focused we are ignoring the content of 'buf' (unless we are in read-only mode)
<span style = "background-color:#fdd">        const int buf_len = (int)strlen(buf);
        state-&gt;InitialTextA.resize(buf_len + 1);    // UTF-8. we use +1 to make sure that .Data is always pointing to at least an empty string.
        memcpy(state-&gt;InitialTextA.Data, buf, buf_len + 1);</span>

        // Start edition
<span style = "background-color:#fdd">        const char* buf_end = NULL;
        state-&gt;TextW.resize(buf_size + 1);          // wchar count &lt;= UTF-8 count. we use +1 to make sure that .Data is always pointing to at least an empty string.
        state-&gt;TextA.resize(0);
        state-&gt;TextAIsValid = false;                // TextA is not valid yet (we will display buf until then)
        state-&gt;CurLenW = ImTextStrFromUtf8(state-&gt;TextW.Data, buf_size, buf, NULL, &amp;buf_end);
        state-&gt;CurLenA = (int)(buf_end - buf);      // We can't get the result from ImStrncpy() above because it is not UTF-8 aware. Here we'll cut off malformed UTF-8.</span>

        // Preserve cursor position and undo/redo stack if we come back to same widget
        // FIXME: For non-readonly widgets we might be able to require that TextAIsValid &amp;&amp; TextA == buf ? (untested) and discard undo stack if user buffer has changed.
<span style = "background-color:#fdd">        const bool recycle_state = (state-&gt;ID == id &amp;&amp; !init_changed_specs);
        if (recycle_state)</span>
        {
            // Recycle existing cursor/selection/undo stack but clamp position
            // Note a single mouse click will override the cursor/position immediately by calling stb_textedit_click handler.
<span style = "background-color:#fdd">            state-&gt;CursorClamp();
        }</span>
        else
        {
<span style = "background-color:#fdd">            state-&gt;ID = id;
            state-&gt;ScrollX = 0.0f;
            stb_textedit_initialize_state(&amp;state-&gt;Stb, !is_multiline);</span>
        }

<span style = "background-color:#fdd">        if (!is_multiline)</span>
        {
<span style = "background-color:#fdd">            if (flags &amp; ImGuiInputTextFlags_AutoSelectAll)
                select_all = true;
            if (input_requested_by_nav &amp;&amp; (!recycle_state || !(g.NavActivateFlags &amp; ImGuiActivateFlags_TryToPreserveState)))
                select_all = true;
            if (input_requested_by_tabbing || (user_clicked &amp;&amp; io.KeyCtrl))
                select_all = true;</span>
        }

<span style = "background-color:#fdd">        if (flags &amp; ImGuiInputTextFlags_AlwaysOverwrite)
            state-&gt;Stb.insert_mode = 1; // stb field name is indeed incorrect (see #2863)</span>
    }

<span style = "background-color:#fdd">    if (g.ActiveId != id &amp;&amp; init_make_active)</span>
    {
<span style = "background-color:#fdd">        IM_ASSERT(state &amp;&amp; state-&gt;ID == id);
        SetActiveID(id, window);
        SetFocusID(id, window);
        FocusWindow(window);</span>

        // Declare our inputs
        IM_ASSERT(ImGuiNavInput_COUNT &lt; 32);
<span style = "background-color:#fdd">        g.ActiveIdUsingNavDirMask |= (1 &lt;&lt; ImGuiDir_Left) | (1 &lt;&lt; ImGuiDir_Right);
        if (is_multiline || (flags &amp; ImGuiInputTextFlags_CallbackHistory))
            g.ActiveIdUsingNavDirMask |= (1 &lt;&lt; ImGuiDir_Up) | (1 &lt;&lt; ImGuiDir_Down);
        g.ActiveIdUsingNavInputMask |= (1 &lt;&lt; ImGuiNavInput_Cancel);
        g.ActiveIdUsingKeyInputMask |= ((ImU64)1 &lt;&lt; ImGuiKey_Home) | ((ImU64)1 &lt;&lt; ImGuiKey_End);
        if (is_multiline)
            g.ActiveIdUsingKeyInputMask |= ((ImU64)1 &lt;&lt; ImGuiKey_PageUp) | ((ImU64)1 &lt;&lt; ImGuiKey_PageDown);
        if (flags &amp; (ImGuiInputTextFlags_CallbackCompletion | ImGuiInputTextFlags_AllowTabInput))  // Disable keyboard tabbing out as we will use the \t character.
            g.ActiveIdUsingKeyInputMask |= ((ImU64)1 &lt;&lt; ImGuiKey_Tab);</span>
    }

    // We have an edge case if ActiveId was set through another widget (e.g. widget being swapped), clear id immediately (don't wait until the end of the function)
<span style = "background-color:#fdd">    if (g.ActiveId == id &amp;&amp; state == NULL)
        ClearActiveID();</span>

    // Release focus when we click outside
<span style = "background-color:#fdd">    if (g.ActiveId == id &amp;&amp; io.MouseClicked[0] &amp;&amp; !init_state &amp;&amp; !init_make_active) //-V560
        clear_active_id = true;</span>

    // Lock the decision of whether we are going to take the path displaying the cursor or selection
<span style = "background-color:#fdd">    const bool render_cursor = (g.ActiveId == id) || (state &amp;&amp; user_scroll_active);
    bool render_selection = state &amp;&amp; (state-&gt;HasSelection() || select_all) &amp;&amp; (RENDER_SELECTION_WHEN_INACTIVE || render_cursor);
    bool value_changed = false;
    bool enter_pressed = false;</span>

    // When read-only we always use the live data passed to the function
    // FIXME-OPT: Because our selection/cursor code currently needs the wide text we need to convert it when active, which is not ideal :(
<span style = "background-color:#fdd">    if (is_readonly &amp;&amp; state != NULL &amp;&amp; (render_cursor || render_selection))</span>
    {
<span style = "background-color:#fdd">        const char* buf_end = NULL;
        state-&gt;TextW.resize(buf_size + 1);
        state-&gt;CurLenW = ImTextStrFromUtf8(state-&gt;TextW.Data, state-&gt;TextW.Size, buf, NULL, &amp;buf_end);
        state-&gt;CurLenA = (int)(buf_end - buf);
        state-&gt;CursorClamp();
        render_selection &amp;= state-&gt;HasSelection();</span>
    }

    // Select the buffer to render.
<span style = "background-color:#fdd">    const bool buf_display_from_state = (render_cursor || render_selection || g.ActiveId == id) &amp;&amp; !is_readonly &amp;&amp; state &amp;&amp; state-&gt;TextAIsValid;
    const bool is_displaying_hint = (hint != NULL &amp;&amp; (buf_display_from_state ? state-&gt;TextA.Data : buf)[0] == 0);</span>

    // Password pushes a temporary font with only a fallback glyph
<span style = "background-color:#fdd">    if (is_password &amp;&amp; !is_displaying_hint)</span>
    {
<span style = "background-color:#fdd">        const ImFontGlyph* glyph = g.Font-&gt;FindGlyph('*');
        ImFont* password_font = &amp;g.InputTextPasswordFont;
        password_font-&gt;FontSize = g.Font-&gt;FontSize;
        password_font-&gt;Scale = g.Font-&gt;Scale;
        password_font-&gt;Ascent = g.Font-&gt;Ascent;
        password_font-&gt;Descent = g.Font-&gt;Descent;
        password_font-&gt;ContainerAtlas = g.Font-&gt;ContainerAtlas;
        password_font-&gt;FallbackGlyph = glyph;
        password_font-&gt;FallbackAdvanceX = glyph-&gt;AdvanceX;
        IM_ASSERT(password_font-&gt;Glyphs.empty() &amp;&amp; password_font-&gt;IndexAdvanceX.empty() &amp;&amp; password_font-&gt;IndexLookup.empty());
        PushFont(password_font);</span>
    }

    // Process mouse inputs and character inputs
<span style = "background-color:#fdd">    int backup_current_text_length = 0;
    if (g.ActiveId == id)</span>
    {
<span style = "background-color:#fdd">        IM_ASSERT(state != NULL);
        backup_current_text_length = state-&gt;CurLenA;
        state-&gt;Edited = false;
        state-&gt;BufCapacityA = buf_size;
        state-&gt;Flags = flags;
        state-&gt;UserCallback = callback;
        state-&gt;UserCallbackData = callback_user_data;</span>

        // Although we are active we don't prevent mouse from hovering other elements unless we are interacting right now with the widget.
        // Down the line we should have a cleaner library-wide concept of Selected vs Active.
<span style = "background-color:#fdd">        g.ActiveIdAllowOverlap = !io.MouseDown[0];
        g.WantTextInputNextFrame = 1;</span>

        // Edit in progress
<span style = "background-color:#fdd">        const float mouse_x = (io.MousePos.x - frame_bb.Min.x - style.FramePadding.x) + state-&gt;ScrollX;
        const float mouse_y = (is_multiline ? (io.MousePos.y - draw_window-&gt;DC.CursorPos.y) : (g.FontSize * 0.5f));</span>

<span style = "background-color:#fdd">        const bool is_osx = io.ConfigMacOSXBehaviors;
        if (select_all)</span>
        {
<span style = "background-color:#fdd">            state-&gt;SelectAll();
            state-&gt;SelectedAllMouseLock = true;
        }
        else if (hovered &amp;&amp; io.MouseClickedCount[0] &gt;= 2 &amp;&amp; !io.KeyShift)</span>
        {
<span style = "background-color:#fdd">            stb_textedit_click(state, &amp;state-&gt;Stb, mouse_x, mouse_y);
            const int multiclick_count = (io.MouseClickedCount[0] - 2);
            if ((multiclick_count % 2) == 0)</span>
            {
                // Double-click: Select word
                // We always use the "Mac" word advance for double-click select vs CTRL+Right which use the platform dependent variant:
                // FIXME: There are likely many ways to improve this behavior, but there's no "right" behavior (depends on use-case, software, OS)
<span style = "background-color:#fdd">                const bool is_bol = (state-&gt;Stb.cursor == 0) || ImStb::STB_TEXTEDIT_GETCHAR(state, state-&gt;Stb.cursor - 1) == '\n';
                if (STB_TEXT_HAS_SELECTION(&amp;state-&gt;Stb) || !is_bol)
                    state-&gt;OnKeyPressed(STB_TEXTEDIT_K_WORDLEFT);</span>
                //state-&gt;OnKeyPressed(STB_TEXTEDIT_K_WORDRIGHT | STB_TEXTEDIT_K_SHIFT);
<span style = "background-color:#fdd">                if (!STB_TEXT_HAS_SELECTION(&amp;state-&gt;Stb))
                    ImStb::stb_textedit_prep_selection_at_cursor(&amp;state-&gt;Stb);
                state-&gt;Stb.cursor = ImStb::STB_TEXTEDIT_MOVEWORDRIGHT_MAC(state, state-&gt;Stb.cursor);
                state-&gt;Stb.select_end = state-&gt;Stb.cursor;
                ImStb::stb_textedit_clamp(state, &amp;state-&gt;Stb);
            }</span>
            else
            {
                // Triple-click: Select line
<span style = "background-color:#fdd">                const bool is_eol = ImStb::STB_TEXTEDIT_GETCHAR(state, state-&gt;Stb.cursor) == '\n';
                state-&gt;OnKeyPressed(STB_TEXTEDIT_K_LINESTART);
                state-&gt;OnKeyPressed(STB_TEXTEDIT_K_LINEEND | STB_TEXTEDIT_K_SHIFT);
                state-&gt;OnKeyPressed(STB_TEXTEDIT_K_RIGHT | STB_TEXTEDIT_K_SHIFT);
                if (!is_eol &amp;&amp; is_multiline)</span>
                {
<span style = "background-color:#fdd">                    ImSwap(state-&gt;Stb.select_start, state-&gt;Stb.select_end);
                    state-&gt;Stb.cursor = state-&gt;Stb.select_end;</span>
                }
<span style = "background-color:#fdd">                state-&gt;CursorFollow = false;</span>
            }
<span style = "background-color:#fdd">            state-&gt;CursorAnimReset();
        }
        else if (io.MouseClicked[0] &amp;&amp; !state-&gt;SelectedAllMouseLock)</span>
        {
            // FIXME: unselect on late click could be done release?
<span style = "background-color:#fdd">            if (hovered)</span>
            {
<span style = "background-color:#fdd">                stb_textedit_click(state, &amp;state-&gt;Stb, mouse_x, mouse_y);
                state-&gt;CursorAnimReset();</span>
            }
<span style = "background-color:#fdd">        }
        else if (io.MouseDown[0] &amp;&amp; !state-&gt;SelectedAllMouseLock &amp;&amp; (io.MouseDelta.x != 0.0f || io.MouseDelta.y != 0.0f))</span>
        {
<span style = "background-color:#fdd">            stb_textedit_drag(state, &amp;state-&gt;Stb, mouse_x, mouse_y);
            state-&gt;CursorAnimReset();
            state-&gt;CursorFollow = true;</span>
        }
<span style = "background-color:#fdd">        if (state-&gt;SelectedAllMouseLock &amp;&amp; !io.MouseDown[0])
            state-&gt;SelectedAllMouseLock = false;</span>

        // It is ill-defined whether the backend needs to send a \t character when pressing the TAB keys.
        // Win32 and GLFW naturally do it but not SDL.
<span style = "background-color:#fdd">        const bool ignore_char_inputs = (io.KeyCtrl &amp;&amp; !io.KeyAlt) || (is_osx &amp;&amp; io.KeySuper);
        if ((flags &amp; ImGuiInputTextFlags_AllowTabInput) &amp;&amp; IsKeyPressedMap(ImGuiKey_Tab) &amp;&amp; !ignore_char_inputs &amp;&amp; !io.KeyShift &amp;&amp; !is_readonly)
            if (!io.InputQueueCharacters.contains('\t'))</span>
            {
<span style = "background-color:#fdd">                unsigned int c = '\t'; // Insert TAB
                if (InputTextFilterCharacter(&amp;c, flags, callback, callback_user_data, ImGuiInputSource_Keyboard))
                    state-&gt;OnKeyPressed((int)c);</span>
            }

        // Process regular text input (before we check for Return because using some IME will effectively send a Return?)
        // We ignore CTRL inputs, but need to allow ALT+CTRL as some keyboards (e.g. German) use AltGR (which _is_ Alt+Ctrl) to input certain characters.
<span style = "background-color:#fdd">        if (io.InputQueueCharacters.Size &gt; 0)</span>
        {
<span style = "background-color:#fdd">            if (!ignore_char_inputs &amp;&amp; !is_readonly &amp;&amp; !input_requested_by_nav)
                for (int n = 0; n &lt; io.InputQueueCharacters.Size; n++)</span>
                {
                    // Insert character if they pass filtering
<span style = "background-color:#fdd">                    unsigned int c = (unsigned int)io.InputQueueCharacters[n];
                    if (c == '\t' &amp;&amp; io.KeyShift)
                        continue;
                    if (InputTextFilterCharacter(&amp;c, flags, callback, callback_user_data, ImGuiInputSource_Keyboard))
                        state-&gt;OnKeyPressed((int)c);
                }</span>

            // Consume characters
<span style = "background-color:#fdd">            io.InputQueueCharacters.resize(0);</span>
        }
    }

    // Process other shortcuts/key-presses
<span style = "background-color:#fdd">    bool cancel_edit = false;
    if (g.ActiveId == id &amp;&amp; !g.ActiveIdIsJustActivated &amp;&amp; !clear_active_id)</span>
    {
<span style = "background-color:#fdd">        IM_ASSERT(state != NULL);
        IM_ASSERT(io.KeyMods == GetMergedKeyModFlags() &amp;&amp; "Mismatching io.KeyCtrl/io.KeyShift/io.KeyAlt/io.KeySuper vs io.KeyMods"); // We rarely do this check, but if anything let's do it here.</span>

<span style = "background-color:#fdd">        const int row_count_per_page = ImMax((int)((inner_size.y - style.FramePadding.y) / g.FontSize), 1);
        state-&gt;Stb.row_count_per_page = row_count_per_page;</span>

<span style = "background-color:#fdd">        const int k_mask = (io.KeyShift ? STB_TEXTEDIT_K_SHIFT : 0);
        const bool is_osx = io.ConfigMacOSXBehaviors;
        const bool is_osx_shift_shortcut = is_osx &amp;&amp; (io.KeyMods == (ImGuiKeyModFlags_Super | ImGuiKeyModFlags_Shift));
        const bool is_wordmove_key_down = is_osx ? io.KeyAlt : io.KeyCtrl;                     // OS X style: Text editing cursor movement using Alt instead of Ctrl
        const bool is_startend_key_down = is_osx &amp;&amp; io.KeySuper &amp;&amp; !io.KeyCtrl &amp;&amp; !io.KeyAlt;  // OS X style: Line/Text Start and End using Cmd+Arrows instead of Home/End
        const bool is_ctrl_key_only = (io.KeyMods == ImGuiKeyModFlags_Ctrl);
        const bool is_shift_key_only = (io.KeyMods == ImGuiKeyModFlags_Shift);
        const bool is_shortcut_key = g.IO.ConfigMacOSXBehaviors ? (io.KeyMods == ImGuiKeyModFlags_Super) : (io.KeyMods == ImGuiKeyModFlags_Ctrl);</span>

<span style = "background-color:#fdd">        const bool is_cut   = ((is_shortcut_key &amp;&amp; IsKeyPressedMap(ImGuiKey_X)) || (is_shift_key_only &amp;&amp; IsKeyPressedMap(ImGuiKey_Delete))) &amp;&amp; !is_readonly &amp;&amp; !is_password &amp;&amp; (!is_multiline || state-&gt;HasSelection());
        const bool is_copy  = ((is_shortcut_key &amp;&amp; IsKeyPressedMap(ImGuiKey_C)) || (is_ctrl_key_only  &amp;&amp; IsKeyPressedMap(ImGuiKey_Insert))) &amp;&amp; !is_password &amp;&amp; (!is_multiline || state-&gt;HasSelection());
        const bool is_paste = ((is_shortcut_key &amp;&amp; IsKeyPressedMap(ImGuiKey_V)) || (is_shift_key_only &amp;&amp; IsKeyPressedMap(ImGuiKey_Insert))) &amp;&amp; !is_readonly;
        const bool is_undo  = ((is_shortcut_key &amp;&amp; IsKeyPressedMap(ImGuiKey_Z)) &amp;&amp; !is_readonly &amp;&amp; is_undoable);
        const bool is_redo  = ((is_shortcut_key &amp;&amp; IsKeyPressedMap(ImGuiKey_Y)) || (is_osx_shift_shortcut &amp;&amp; IsKeyPressedMap(ImGuiKey_Z))) &amp;&amp; !is_readonly &amp;&amp; is_undoable;</span>

        // We allow validate/cancel with Nav source (gamepad) to makes it easier to undo an accidental NavInput press with no keyboard wired, but otherwise it isn't very useful.
<span style = "background-color:#fdd">        const bool is_validate_enter = IsKeyPressedMap(ImGuiKey_Enter) || IsKeyPressedMap(ImGuiKey_KeyPadEnter);
        const bool is_validate_nav = (IsNavInputTest(ImGuiNavInput_Activate, ImGuiInputReadMode_Pressed) &amp;&amp; !IsKeyPressedMap(ImGuiKey_Space)) || IsNavInputTest(ImGuiNavInput_Input, ImGuiInputReadMode_Pressed);
        const bool is_cancel   = IsKeyPressedMap(ImGuiKey_Escape) || IsNavInputTest(ImGuiNavInput_Cancel, ImGuiInputReadMode_Pressed);</span>

<span style = "background-color:#fdd">        if (IsKeyPressedMap(ImGuiKey_LeftArrow))                        { state-&gt;OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_LINESTART : is_wordmove_key_down ? STB_TEXTEDIT_K_WORDLEFT : STB_TEXTEDIT_K_LEFT) | k_mask); }
        else if (IsKeyPressedMap(ImGuiKey_RightArrow))                  { state-&gt;OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_LINEEND : is_wordmove_key_down ? STB_TEXTEDIT_K_WORDRIGHT : STB_TEXTEDIT_K_RIGHT) | k_mask); }
        else if (IsKeyPressedMap(ImGuiKey_UpArrow) &amp;&amp; is_multiline)     { if (io.KeyCtrl) SetScrollY(draw_window, ImMax(draw_window-&gt;Scroll.y - g.FontSize, 0.0f)); else state-&gt;OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_TEXTSTART : STB_TEXTEDIT_K_UP) | k_mask); }
        else if (IsKeyPressedMap(ImGuiKey_DownArrow) &amp;&amp; is_multiline)   { if (io.KeyCtrl) SetScrollY(draw_window, ImMin(draw_window-&gt;Scroll.y + g.FontSize, GetScrollMaxY())); else state-&gt;OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_TEXTEND : STB_TEXTEDIT_K_DOWN) | k_mask); }
        else if (IsKeyPressedMap(ImGuiKey_PageUp) &amp;&amp; is_multiline)      { state-&gt;OnKeyPressed(STB_TEXTEDIT_K_PGUP | k_mask); scroll_y -= row_count_per_page * g.FontSize; }
        else if (IsKeyPressedMap(ImGuiKey_PageDown) &amp;&amp; is_multiline)    { state-&gt;OnKeyPressed(STB_TEXTEDIT_K_PGDOWN | k_mask); scroll_y += row_count_per_page * g.FontSize; }
        else if (IsKeyPressedMap(ImGuiKey_Home))                        { state-&gt;OnKeyPressed(io.KeyCtrl ? STB_TEXTEDIT_K_TEXTSTART | k_mask : STB_TEXTEDIT_K_LINESTART | k_mask); }
        else if (IsKeyPressedMap(ImGuiKey_End))                         { state-&gt;OnKeyPressed(io.KeyCtrl ? STB_TEXTEDIT_K_TEXTEND | k_mask : STB_TEXTEDIT_K_LINEEND | k_mask); }
        else if (IsKeyPressedMap(ImGuiKey_Delete) &amp;&amp; !is_readonly)      { state-&gt;OnKeyPressed(STB_TEXTEDIT_K_DELETE | k_mask); }
        else if (IsKeyPressedMap(ImGuiKey_Backspace) &amp;&amp; !is_readonly)</span>
        {
<span style = "background-color:#fdd">            if (!state-&gt;HasSelection())</span>
            {
<span style = "background-color:#fdd">                if (is_wordmove_key_down)
                    state-&gt;OnKeyPressed(STB_TEXTEDIT_K_WORDLEFT | STB_TEXTEDIT_K_SHIFT);
                else if (is_osx &amp;&amp; io.KeySuper &amp;&amp; !io.KeyAlt &amp;&amp; !io.KeyCtrl)
                    state-&gt;OnKeyPressed(STB_TEXTEDIT_K_LINESTART | STB_TEXTEDIT_K_SHIFT);</span>
            }
<span style = "background-color:#fdd">            state-&gt;OnKeyPressed(STB_TEXTEDIT_K_BACKSPACE | k_mask);
        }
        else if (is_validate_enter)</span>
        {
<span style = "background-color:#fdd">            bool ctrl_enter_for_new_line = (flags &amp; ImGuiInputTextFlags_CtrlEnterForNewLine) != 0;
            if (!is_multiline || (ctrl_enter_for_new_line &amp;&amp; !io.KeyCtrl) || (!ctrl_enter_for_new_line &amp;&amp; io.KeyCtrl))</span>
            {
<span style = "background-color:#fdd">                enter_pressed = clear_active_id = true;
            }
            else if (!is_readonly)</span>
            {
<span style = "background-color:#fdd">                unsigned int c = '\n'; // Insert new line
                if (InputTextFilterCharacter(&amp;c, flags, callback, callback_user_data, ImGuiInputSource_Keyboard))
                    state-&gt;OnKeyPressed((int)c);</span>
            }
<span style = "background-color:#fdd">        }
        else if (is_validate_nav)</span>
        {
<span style = "background-color:#fdd">            IM_ASSERT(!is_validate_enter);
            enter_pressed = clear_active_id = true;
        }
        else if (is_cancel)</span>
        {
<span style = "background-color:#fdd">            clear_active_id = cancel_edit = true;
        }
        else if (is_undo || is_redo)</span>
        {
<span style = "background-color:#fdd">            state-&gt;OnKeyPressed(is_undo ? STB_TEXTEDIT_K_UNDO : STB_TEXTEDIT_K_REDO);
            state-&gt;ClearSelection();
        }
        else if (is_shortcut_key &amp;&amp; IsKeyPressedMap(ImGuiKey_A))</span>
        {
<span style = "background-color:#fdd">            state-&gt;SelectAll();
            state-&gt;CursorFollow = true;
        }
        else if (is_cut || is_copy)</span>
        {
            // Cut, Copy
<span style = "background-color:#fdd">            if (io.SetClipboardTextFn)</span>
            {
<span style = "background-color:#fdd">                const int ib = state-&gt;HasSelection() ? ImMin(state-&gt;Stb.select_start, state-&gt;Stb.select_end) : 0;
                const int ie = state-&gt;HasSelection() ? ImMax(state-&gt;Stb.select_start, state-&gt;Stb.select_end) : state-&gt;CurLenW;
                const int clipboard_data_len = ImTextCountUtf8BytesFromStr(state-&gt;TextW.Data + ib, state-&gt;TextW.Data + ie) + 1;
                char* clipboard_data = (char*)IM_ALLOC(clipboard_data_len * sizeof(char));
                ImTextStrToUtf8(clipboard_data, clipboard_data_len, state-&gt;TextW.Data + ib, state-&gt;TextW.Data + ie);
                SetClipboardText(clipboard_data);
                MemFree(clipboard_data);</span>
            }
<span style = "background-color:#fdd">            if (is_cut)</span>
            {
<span style = "background-color:#fdd">                if (!state-&gt;HasSelection())
                    state-&gt;SelectAll();
                state-&gt;CursorFollow = true;
                stb_textedit_cut(state, &amp;state-&gt;Stb);</span>
            }
<span style = "background-color:#fdd">        }
        else if (is_paste)</span>
        {
<span style = "background-color:#fdd">            if (const char* clipboard = GetClipboardText())</span>
            {
                // Filter pasted buffer
<span style = "background-color:#fdd">                const int clipboard_len = (int)strlen(clipboard);
                ImWchar* clipboard_filtered = (ImWchar*)IM_ALLOC((clipboard_len + 1) * sizeof(ImWchar));
                int clipboard_filtered_len = 0;
                for (const char* s = clipboard; *s; )</span>
                {
                    unsigned int c;
<span style = "background-color:#fdd">                    s += ImTextCharFromUtf8(&amp;c, s, NULL);
                    if (c == 0)
                        break;
                    if (!InputTextFilterCharacter(&amp;c, flags, callback, callback_user_data, ImGuiInputSource_Clipboard))
                        continue;
                    clipboard_filtered[clipboard_filtered_len++] = (ImWchar)c;
                }
                clipboard_filtered[clipboard_filtered_len] = 0;
                if (clipboard_filtered_len &gt; 0) // If everything was filtered, ignore the pasting operation</span>
                {
<span style = "background-color:#fdd">                    stb_textedit_paste(state, &amp;state-&gt;Stb, clipboard_filtered, clipboard_filtered_len);
                    state-&gt;CursorFollow = true;</span>
                }
<span style = "background-color:#fdd">                MemFree(clipboard_filtered);</span>
            }
        }

        // Update render selection flag after events have been handled, so selection highlight can be displayed during the same frame.
<span style = "background-color:#fdd">        render_selection |= state-&gt;HasSelection() &amp;&amp; (RENDER_SELECTION_WHEN_INACTIVE || render_cursor);</span>
    }

    // Process callbacks and apply result back to user's buffer.
<span style = "background-color:#fdd">    if (g.ActiveId == id)</span>
    {
<span style = "background-color:#fdd">        IM_ASSERT(state != NULL);
        const char* apply_new_text = NULL;
        int apply_new_text_length = 0;
        if (cancel_edit)</span>
        {
            // Restore initial value. Only return true if restoring to the initial value changes the current buffer contents.
<span style = "background-color:#fdd">            if (!is_readonly &amp;&amp; strcmp(buf, state-&gt;InitialTextA.Data) != 0)</span>
            {
                // Push records into the undo stack so we can CTRL+Z the revert operation itself
<span style = "background-color:#fdd">                apply_new_text = state-&gt;InitialTextA.Data;
                apply_new_text_length = state-&gt;InitialTextA.Size - 1;
                ImVector&lt;ImWchar&gt; w_text;
                if (apply_new_text_length &gt; 0)</span>
                {
<span style = "background-color:#fdd">                    w_text.resize(ImTextCountCharsFromUtf8(apply_new_text, apply_new_text + apply_new_text_length) + 1);
                    ImTextStrFromUtf8(w_text.Data, w_text.Size, apply_new_text, apply_new_text + apply_new_text_length);</span>
                }
<span style = "background-color:#fdd">                stb_textedit_replace(state, &amp;state-&gt;Stb, w_text.Data, (apply_new_text_length &gt; 0) ? (w_text.Size - 1) : 0);
            }</span>
        }

        // When using 'ImGuiInputTextFlags_EnterReturnsTrue' as a special case we reapply the live buffer back to the input buffer before clearing ActiveId, even though strictly speaking it wasn't modified on this frame.
        // If we didn't do that, code like InputInt() with ImGuiInputTextFlags_EnterReturnsTrue would fail.
        // This also allows the user to use InputText() with ImGuiInputTextFlags_EnterReturnsTrue without maintaining any user-side storage (please note that if you use this property along ImGuiInputTextFlags_CallbackResize you can end up with your temporary string object unnecessarily allocating once a frame, either store your string data, either if you don't then don't use ImGuiInputTextFlags_CallbackResize).
<span style = "background-color:#fdd">        bool apply_edit_back_to_user_buffer = !cancel_edit || (enter_pressed &amp;&amp; (flags &amp; ImGuiInputTextFlags_EnterReturnsTrue) != 0);
        if (apply_edit_back_to_user_buffer)</span>
        {
            // Apply new value immediately - copy modified buffer back
            // Note that as soon as the input box is active, the in-widget value gets priority over any underlying modification of the input buffer
            // FIXME: We actually always render 'buf' when calling DrawList-&gt;AddText, making the comment above incorrect.
            // FIXME-OPT: CPU waste to do this every time the widget is active, should mark dirty state from the stb_textedit callbacks.
<span style = "background-color:#fdd">            if (!is_readonly)</span>
            {
<span style = "background-color:#fdd">                state-&gt;TextAIsValid = true;
                state-&gt;TextA.resize(state-&gt;TextW.Size * 4 + 1);
                ImTextStrToUtf8(state-&gt;TextA.Data, state-&gt;TextA.Size, state-&gt;TextW.Data, NULL);</span>
            }

            // User callback
<span style = "background-color:#fdd">            if ((flags &amp; (ImGuiInputTextFlags_CallbackCompletion | ImGuiInputTextFlags_CallbackHistory | ImGuiInputTextFlags_CallbackEdit | ImGuiInputTextFlags_CallbackAlways)) != 0)</span>
            {
<span style = "background-color:#fdd">                IM_ASSERT(callback != NULL);</span>

                // The reason we specify the usage semantic (Completion/History) is that Completion needs to disable keyboard TABBING at the moment.
<span style = "background-color:#fdd">                ImGuiInputTextFlags event_flag = 0;
                ImGuiKey event_key = ImGuiKey_COUNT;
                if ((flags &amp; ImGuiInputTextFlags_CallbackCompletion) != 0 &amp;&amp; IsKeyPressedMap(ImGuiKey_Tab))</span>
                {
<span style = "background-color:#fdd">                    event_flag = ImGuiInputTextFlags_CallbackCompletion;
                    event_key = ImGuiKey_Tab;
                }
                else if ((flags &amp; ImGuiInputTextFlags_CallbackHistory) != 0 &amp;&amp; IsKeyPressedMap(ImGuiKey_UpArrow))</span>
                {
<span style = "background-color:#fdd">                    event_flag = ImGuiInputTextFlags_CallbackHistory;
                    event_key = ImGuiKey_UpArrow;
                }
                else if ((flags &amp; ImGuiInputTextFlags_CallbackHistory) != 0 &amp;&amp; IsKeyPressedMap(ImGuiKey_DownArrow))</span>
                {
<span style = "background-color:#fdd">                    event_flag = ImGuiInputTextFlags_CallbackHistory;
                    event_key = ImGuiKey_DownArrow;
                }
                else if ((flags &amp; ImGuiInputTextFlags_CallbackEdit) &amp;&amp; state-&gt;Edited)</span>
                {
<span style = "background-color:#fdd">                    event_flag = ImGuiInputTextFlags_CallbackEdit;
                }
                else if (flags &amp; ImGuiInputTextFlags_CallbackAlways)</span>
                {
<span style = "background-color:#fdd">                    event_flag = ImGuiInputTextFlags_CallbackAlways;</span>
                }

<span style = "background-color:#fdd">                if (event_flag)</span>
                {
<span style = "background-color:#fdd">                    ImGuiInputTextCallbackData callback_data;
                    memset(&amp;callback_data, 0, sizeof(ImGuiInputTextCallbackData));
                    callback_data.EventFlag = event_flag;
                    callback_data.Flags = flags;
                    callback_data.UserData = callback_user_data;</span>

<span style = "background-color:#fdd">                    callback_data.EventKey = event_key;
                    callback_data.Buf = state-&gt;TextA.Data;
                    callback_data.BufTextLen = state-&gt;CurLenA;
                    callback_data.BufSize = state-&gt;BufCapacityA;
                    callback_data.BufDirty = false;</span>

                    // We have to convert from wchar-positions to UTF-8-positions, which can be pretty slow (an incentive to ditch the ImWchar buffer, see https://github.com/nothings/stb/issues/188)
<span style = "background-color:#fdd">                    ImWchar* text = state-&gt;TextW.Data;
                    const int utf8_cursor_pos = callback_data.CursorPos = ImTextCountUtf8BytesFromStr(text, text + state-&gt;Stb.cursor);
                    const int utf8_selection_start = callback_data.SelectionStart = ImTextCountUtf8BytesFromStr(text, text + state-&gt;Stb.select_start);
                    const int utf8_selection_end = callback_data.SelectionEnd = ImTextCountUtf8BytesFromStr(text, text + state-&gt;Stb.select_end);</span>

                    // Call user code
<span style = "background-color:#fdd">                    callback(&amp;callback_data);</span>

                    // Read back what user may have modified
<span style = "background-color:#fdd">                    IM_ASSERT(callback_data.Buf == state-&gt;TextA.Data);  // Invalid to modify those fields
                    IM_ASSERT(callback_data.BufSize == state-&gt;BufCapacityA);
                    IM_ASSERT(callback_data.Flags == flags);
                    const bool buf_dirty = callback_data.BufDirty;
                    if (callback_data.CursorPos != utf8_cursor_pos || buf_dirty)            { state-&gt;Stb.cursor = ImTextCountCharsFromUtf8(callback_data.Buf, callback_data.Buf + callback_data.CursorPos); state-&gt;CursorFollow = true; }
                    if (callback_data.SelectionStart != utf8_selection_start || buf_dirty)  { state-&gt;Stb.select_start = (callback_data.SelectionStart == callback_data.CursorPos) ? state-&gt;Stb.cursor : ImTextCountCharsFromUtf8(callback_data.Buf, callback_data.Buf + callback_data.SelectionStart); }
                    if (callback_data.SelectionEnd != utf8_selection_end || buf_dirty)      { state-&gt;Stb.select_end = (callback_data.SelectionEnd == callback_data.SelectionStart) ? state-&gt;Stb.select_start : ImTextCountCharsFromUtf8(callback_data.Buf, callback_data.Buf + callback_data.SelectionEnd); }
                    if (buf_dirty)</span>
                    {
<span style = "background-color:#fdd">                        IM_ASSERT(callback_data.BufTextLen == (int)strlen(callback_data.Buf)); // You need to maintain BufTextLen if you change the text!
                        if (callback_data.BufTextLen &gt; backup_current_text_length &amp;&amp; is_resizable)
                            state-&gt;TextW.resize(state-&gt;TextW.Size + (callback_data.BufTextLen - backup_current_text_length));
                        state-&gt;CurLenW = ImTextStrFromUtf8(state-&gt;TextW.Data, state-&gt;TextW.Size, callback_data.Buf, NULL);
                        state-&gt;CurLenA = callback_data.BufTextLen;  // Assume correct length and valid UTF-8 from user, saves us an extra strlen()
                        state-&gt;CursorAnimReset();</span>
                    }
                }
            }

            // Will copy result string if modified
<span style = "background-color:#fdd">            if (!is_readonly &amp;&amp; strcmp(state-&gt;TextA.Data, buf) != 0)</span>
            {
<span style = "background-color:#fdd">                apply_new_text = state-&gt;TextA.Data;
                apply_new_text_length = state-&gt;CurLenA;</span>
            }
        }

        // Copy result to user buffer
<span style = "background-color:#fdd">        if (apply_new_text)</span>
        {
            // We cannot test for 'backup_current_text_length != apply_new_text_length' here because we have no guarantee that the size
            // of our owned buffer matches the size of the string object held by the user, and by design we allow InputText() to be used
            // without any storage on user's side.
<span style = "background-color:#fdd">            IM_ASSERT(apply_new_text_length &gt;= 0);
            if (is_resizable)</span>
            {
<span style = "background-color:#fdd">                ImGuiInputTextCallbackData callback_data;
                callback_data.EventFlag = ImGuiInputTextFlags_CallbackResize;
                callback_data.Flags = flags;
                callback_data.Buf = buf;
                callback_data.BufTextLen = apply_new_text_length;
                callback_data.BufSize = ImMax(buf_size, apply_new_text_length + 1);
                callback_data.UserData = callback_user_data;
                callback(&amp;callback_data);
                buf = callback_data.Buf;
                buf_size = callback_data.BufSize;
                apply_new_text_length = ImMin(callback_data.BufTextLen, buf_size - 1);
                IM_ASSERT(apply_new_text_length &lt;= buf_size);</span>
            }
            //IMGUI_DEBUG_LOG("InputText(\"%s\"): apply_new_text length %d\n", label, apply_new_text_length);

            // If the underlying buffer resize was denied or not carried to the next frame, apply_new_text_length+1 may be &gt;= buf_size.
<span style = "background-color:#fdd">            ImStrncpy(buf, apply_new_text, ImMin(apply_new_text_length + 1, buf_size));
            value_changed = true;</span>
        }

        // Clear temporary user storage
<span style = "background-color:#fdd">        state-&gt;Flags = ImGuiInputTextFlags_None;
        state-&gt;UserCallback = NULL;
        state-&gt;UserCallbackData = NULL;</span>
    }

    // Release active ID at the end of the function (so e.g. pressing Return still does a final application of the value)
<span style = "background-color:#fdd">    if (clear_active_id &amp;&amp; g.ActiveId == id)
        ClearActiveID();</span>

    // Render frame
<span style = "background-color:#fdd">    if (!is_multiline)</span>
    {
<span style = "background-color:#fdd">        RenderNavHighlight(frame_bb, id);
        RenderFrame(frame_bb.Min, frame_bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);</span>
    }

<span style = "background-color:#fdd">    const ImVec4 clip_rect(frame_bb.Min.x, frame_bb.Min.y, frame_bb.Min.x + inner_size.x, frame_bb.Min.y + inner_size.y); // Not using frame_bb.Max because we have adjusted size
    ImVec2 draw_pos = is_multiline ? draw_window-&gt;DC.CursorPos : frame_bb.Min + style.FramePadding;
    ImVec2 text_size(0.0f, 0.0f);</span>

    // Set upper limit of single-line InputTextEx() at 2 million characters strings. The current pathological worst case is a long line
    // without any carriage return, which would makes ImFont::RenderText() reserve too many vertices and probably crash. Avoid it altogether.
    // Note that we only use this limit on single-line InputText(), so a pathologically large line on a InputTextMultiline() would still crash.
<span style = "background-color:#fdd">    const int buf_display_max_length = 2 * 1024 * 1024;
    const char* buf_display = buf_display_from_state ? state-&gt;TextA.Data : buf; //-V595
    const char* buf_display_end = NULL; // We have specialized paths below for setting the length
    if (is_displaying_hint)</span>
    {
<span style = "background-color:#fdd">        buf_display = hint;
        buf_display_end = hint + strlen(hint);</span>
    }

    // Render text. We currently only render selection when the widget is active or while scrolling.
    // FIXME: We could remove the '&amp;&amp; render_cursor' to keep rendering selection when inactive.
<span style = "background-color:#fdd">    if (render_cursor || render_selection)</span>
    {
<span style = "background-color:#fdd">        IM_ASSERT(state != NULL);
        if (!is_displaying_hint)
            buf_display_end = buf_display + state-&gt;CurLenA;</span>

        // Render text (with cursor and selection)
        // This is going to be messy. We need to:
        // - Display the text (this alone can be more easily clipped)
        // - Handle scrolling, highlight selection, display cursor (those all requires some form of 1d-&gt;2d cursor position calculation)
        // - Measure text height (for scrollbar)
        // We are attempting to do most of that in **one main pass** to minimize the computation cost (non-negligible for large amount of text) + 2nd pass for selection rendering (we could merge them by an extra refactoring effort)
        // FIXME: This should occur on buf_display but we'd need to maintain cursor/select_start/select_end for UTF-8.
<span style = "background-color:#fdd">        const ImWchar* text_begin = state-&gt;TextW.Data;
        ImVec2 cursor_offset, select_start_offset;</span>

        {
            // Find lines numbers straddling 'cursor' (slot 0) and 'select_start' (slot 1) positions.
<span style = "background-color:#fdd">            const ImWchar* searches_input_ptr[2] = { NULL, NULL };
            int searches_result_line_no[2] = { -1000, -1000 };
            int searches_remaining = 0;
            if (render_cursor)</span>
            {
<span style = "background-color:#fdd">                searches_input_ptr[0] = text_begin + state-&gt;Stb.cursor;
                searches_result_line_no[0] = -1;
                searches_remaining++;</span>
            }
<span style = "background-color:#fdd">            if (render_selection)</span>
            {
<span style = "background-color:#fdd">                searches_input_ptr[1] = text_begin + ImMin(state-&gt;Stb.select_start, state-&gt;Stb.select_end);
                searches_result_line_no[1] = -1;
                searches_remaining++;</span>
            }

            // Iterate all lines to find our line numbers
            // In multi-line mode, we never exit the loop until all lines are counted, so add one extra to the searches_remaining counter.
<span style = "background-color:#fdd">            searches_remaining += is_multiline ? 1 : 0;
            int line_count = 0;</span>
            //for (const ImWchar* s = text_begin; (s = (const ImWchar*)wcschr((const wchar_t*)s, (wchar_t)'\n')) != NULL; s++)  // FIXME-OPT: Could use this when wchar_t are 16-bit
<span style = "background-color:#fdd">            for (const ImWchar* s = text_begin; *s != 0; s++)
                if (*s == '\n')</span>
                {
<span style = "background-color:#fdd">                    line_count++;
                    if (searches_result_line_no[0] == -1 &amp;&amp; s &gt;= searches_input_ptr[0]) { searches_result_line_no[0] = line_count; if (--searches_remaining &lt;= 0) break; }
                    if (searches_result_line_no[1] == -1 &amp;&amp; s &gt;= searches_input_ptr[1]) { searches_result_line_no[1] = line_count; if (--searches_remaining &lt;= 0) break; }
                }
            line_count++;
            if (searches_result_line_no[0] == -1)
                searches_result_line_no[0] = line_count;
            if (searches_result_line_no[1] == -1)
                searches_result_line_no[1] = line_count;</span>

            // Calculate 2d position by finding the beginning of the line and measuring distance
<span style = "background-color:#fdd">            cursor_offset.x = InputTextCalcTextSizeW(ImStrbolW(searches_input_ptr[0], text_begin), searches_input_ptr[0]).x;
            cursor_offset.y = searches_result_line_no[0] * g.FontSize;
            if (searches_result_line_no[1] &gt;= 0)</span>
            {
<span style = "background-color:#fdd">                select_start_offset.x = InputTextCalcTextSizeW(ImStrbolW(searches_input_ptr[1], text_begin), searches_input_ptr[1]).x;
                select_start_offset.y = searches_result_line_no[1] * g.FontSize;</span>
            }

            // Store text height (note that we haven't calculated text width at all, see GitHub issues #383, #1224)
<span style = "background-color:#fdd">            if (is_multiline)
                text_size = ImVec2(inner_size.x, line_count * g.FontSize);</span>
        }

        // Scroll
<span style = "background-color:#fdd">        if (render_cursor &amp;&amp; state-&gt;CursorFollow)</span>
        {
            // Horizontal scroll in chunks of quarter width
<span style = "background-color:#fdd">            if (!(flags &amp; ImGuiInputTextFlags_NoHorizontalScroll))</span>
            {
<span style = "background-color:#fdd">                const float scroll_increment_x = inner_size.x * 0.25f;
                const float visible_width = inner_size.x - style.FramePadding.x;
                if (cursor_offset.x &lt; state-&gt;ScrollX)
                    state-&gt;ScrollX = IM_FLOOR(ImMax(0.0f, cursor_offset.x - scroll_increment_x));
                else if (cursor_offset.x - visible_width &gt;= state-&gt;ScrollX)
                    state-&gt;ScrollX = IM_FLOOR(cursor_offset.x - visible_width + scroll_increment_x);
            }</span>
            else
            {
<span style = "background-color:#fdd">                state-&gt;ScrollX = 0.0f;</span>
            }

            // Vertical scroll
<span style = "background-color:#fdd">            if (is_multiline)</span>
            {
                // Test if cursor is vertically visible
<span style = "background-color:#fdd">                if (cursor_offset.y - g.FontSize &lt; scroll_y)
                    scroll_y = ImMax(0.0f, cursor_offset.y - g.FontSize);
                else if (cursor_offset.y - inner_size.y &gt;= scroll_y)
                    scroll_y = cursor_offset.y - inner_size.y + style.FramePadding.y * 2.0f;
                const float scroll_max_y = ImMax((text_size.y + style.FramePadding.y * 2.0f) - inner_size.y, 0.0f);
                scroll_y = ImClamp(scroll_y, 0.0f, scroll_max_y);
                draw_pos.y += (draw_window-&gt;Scroll.y - scroll_y);   // Manipulate cursor pos immediately avoid a frame of lag
                draw_window-&gt;Scroll.y = scroll_y;</span>
            }

<span style = "background-color:#fdd">            state-&gt;CursorFollow = false;</span>
        }

        // Draw selection
<span style = "background-color:#fdd">        const ImVec2 draw_scroll = ImVec2(state-&gt;ScrollX, 0.0f);
        if (render_selection)</span>
        {
<span style = "background-color:#fdd">            const ImWchar* text_selected_begin = text_begin + ImMin(state-&gt;Stb.select_start, state-&gt;Stb.select_end);
            const ImWchar* text_selected_end = text_begin + ImMax(state-&gt;Stb.select_start, state-&gt;Stb.select_end);</span>

<span style = "background-color:#fdd">            ImU32 bg_color = GetColorU32(ImGuiCol_TextSelectedBg, render_cursor ? 1.0f : 0.6f); // FIXME: current code flow mandate that render_cursor is always true here, we are leaving the transparent one for tests.
            float bg_offy_up = is_multiline ? 0.0f : -1.0f;    // FIXME: those offsets should be part of the style? they don't play so well with multi-line selection.
            float bg_offy_dn = is_multiline ? 0.0f : 2.0f;
            ImVec2 rect_pos = draw_pos + select_start_offset - draw_scroll;
            for (const ImWchar* p = text_selected_begin; p &lt; text_selected_end; )</span>
            {
<span style = "background-color:#fdd">                if (rect_pos.y &gt; clip_rect.w + g.FontSize)
                    break;
                if (rect_pos.y &lt; clip_rect.y)</span>
                {
                    //p = (const ImWchar*)wmemchr((const wchar_t*)p, '\n', text_selected_end - p);  // FIXME-OPT: Could use this when wchar_t are 16-bit
                    //p = p ? p + 1 : text_selected_end;
<span style = "background-color:#fdd">                    while (p &lt; text_selected_end)
                        if (*p++ == '\n')
                            break;
                }</span>
                else
                {
<span style = "background-color:#fdd">                    ImVec2 rect_size = InputTextCalcTextSizeW(p, text_selected_end, &amp;p, NULL, true);
                    if (rect_size.x &lt;= 0.0f) rect_size.x = IM_FLOOR(g.Font-&gt;GetCharAdvance((ImWchar)' ') * 0.50f); // So we can see selected empty lines
                    ImRect rect(rect_pos + ImVec2(0.0f, bg_offy_up - g.FontSize), rect_pos + ImVec2(rect_size.x, bg_offy_dn));
                    rect.ClipWith(clip_rect);
                    if (rect.Overlaps(clip_rect))
                        draw_window-&gt;DrawList-&gt;AddRectFilled(rect.Min, rect.Max, bg_color);</span>
                }
<span style = "background-color:#fdd">                rect_pos.x = draw_pos.x - draw_scroll.x;
                rect_pos.y += g.FontSize;
            }</span>
        }

        // We test for 'buf_display_max_length' as a way to avoid some pathological cases (e.g. single-line 1 MB string) which would make ImDrawList crash.
<span style = "background-color:#fdd">        if (is_multiline || (buf_display_end - buf_display) &lt; buf_display_max_length)</span>
        {
<span style = "background-color:#fdd">            ImU32 col = GetColorU32(is_displaying_hint ? ImGuiCol_TextDisabled : ImGuiCol_Text);
            draw_window-&gt;DrawList-&gt;AddText(g.Font, g.FontSize, draw_pos - draw_scroll, col, buf_display, buf_display_end, 0.0f, is_multiline ? NULL : &amp;clip_rect);</span>
        }

        // Draw blinking cursor
<span style = "background-color:#fdd">        if (render_cursor)</span>
        {
<span style = "background-color:#fdd">            state-&gt;CursorAnim += io.DeltaTime;
            bool cursor_is_visible = (!g.IO.ConfigInputTextCursorBlink) || (state-&gt;CursorAnim &lt;= 0.0f) || ImFmod(state-&gt;CursorAnim, 1.20f) &lt;= 0.80f;
            ImVec2 cursor_screen_pos = ImFloor(draw_pos + cursor_offset - draw_scroll);
            ImRect cursor_screen_rect(cursor_screen_pos.x, cursor_screen_pos.y - g.FontSize + 0.5f, cursor_screen_pos.x + 1.0f, cursor_screen_pos.y - 1.5f);
            if (cursor_is_visible &amp;&amp; cursor_screen_rect.Overlaps(clip_rect))
                draw_window-&gt;DrawList-&gt;AddLine(cursor_screen_rect.Min, cursor_screen_rect.GetBL(), GetColorU32(ImGuiCol_Text));</span>

            // Notify OS of text input position for advanced IME (-1 x offset so that Windows IME can cover our cursor. Bit of an extra nicety.)
<span style = "background-color:#fdd">            if (!is_readonly)
                g.PlatformImePos = ImVec2(cursor_screen_pos.x - 1.0f, cursor_screen_pos.y - g.FontSize);</span>
        }
<span style = "background-color:#fdd">    }</span>
    else
    {
        // Render text only (no selection, no cursor)
<span style = "background-color:#fdd">        if (is_multiline)
            text_size = ImVec2(inner_size.x, InputTextCalcTextLenAndLineCount(buf_display, &amp;buf_display_end) * g.FontSize); // We don't need width
        else if (!is_displaying_hint &amp;&amp; g.ActiveId == id)
            buf_display_end = buf_display + state-&gt;CurLenA;
        else if (!is_displaying_hint)
            buf_display_end = buf_display + strlen(buf_display);</span>

<span style = "background-color:#fdd">        if (is_multiline || (buf_display_end - buf_display) &lt; buf_display_max_length)</span>
        {
<span style = "background-color:#fdd">            ImU32 col = GetColorU32(is_displaying_hint ? ImGuiCol_TextDisabled : ImGuiCol_Text);
            draw_window-&gt;DrawList-&gt;AddText(g.Font, g.FontSize, draw_pos, col, buf_display, buf_display_end, 0.0f, is_multiline ? NULL : &amp;clip_rect);</span>
        }
    }

<span style = "background-color:#fdd">    if (is_password &amp;&amp; !is_displaying_hint)
        PopFont();</span>

<span style = "background-color:#fdd">    if (is_multiline)</span>
    {
<span style = "background-color:#fdd">        Dummy(ImVec2(text_size.x, text_size.y + style.FramePadding.y));
        EndChild();
        EndGroup();</span>
    }

    // Log as text
<span style = "background-color:#fdd">    if (g.LogEnabled &amp;&amp; (!is_password || is_displaying_hint))</span>
    {
<span style = "background-color:#fdd">        LogSetNextTextDecoration("{", "}");
        LogRenderedText(&amp;draw_pos, buf_display, buf_display_end);</span>
    }

<span style = "background-color:#fdd">    if (label_size.x &gt; 0)
        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);</span>

<span style = "background-color:#fdd">    if (value_changed &amp;&amp; !(flags &amp; ImGuiInputTextFlags_NoMarkEdited))
        MarkItemEdited(id);</span>

    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags);
<span style = "background-color:#fdd">    if ((flags &amp; ImGuiInputTextFlags_EnterReturnsTrue) != 0)
        return enter_pressed;</span>
    else
<span style = "background-color:#fdd">        return value_changed;
}</span>

//-------------------------------------------------------------------------
// [SECTION] Widgets: ColorEdit, ColorPicker, ColorButton, etc.
//-------------------------------------------------------------------------
// - ColorEdit3()
// - ColorEdit4()
// - ColorPicker3()
// - RenderColorRectWithAlphaCheckerboard() [Internal]
// - ColorPicker4()
// - ColorButton()
// - SetColorEditOptions()
// - ColorTooltip() [Internal]
// - ColorEditOptionsPopup() [Internal]
// - ColorPickerOptionsPopup() [Internal]
//-------------------------------------------------------------------------

bool ImGui::ColorEdit3(const char* label, float col[3], ImGuiColorEditFlags flags)
<span style = "background-color:#fdd">{
    return ColorEdit4(label, col, flags | ImGuiColorEditFlags_NoAlpha);
}</span>

// ColorEdit supports RGB and HSV inputs. In case of RGB input resulting color may have undefined hue and/or saturation.
// Since widget displays both RGB and HSV values we must preserve hue and saturation to prevent these values resetting.
static void ColorEditRestoreHS(const float* col, float* H, float* S, float* V)
<span style = "background-color:#fdd">{</span>
    // This check is optional. Suppose we have two color widgets side by side, both widgets display different colors, but both colors have hue and/or saturation undefined.
    // With color check: hue/saturation is preserved in one widget. Editing color in one widget would reset hue/saturation in another one.
    // Without color check: common hue/saturation would be displayed in all widgets that have hue/saturation undefined.
    // g.ColorEditLastColor is stored as ImU32 RGB value: this essentially gives us color equality check with reduced precision.
    // Tiny external color changes would not be detected and this check would still pass. This is OK, since we only restore hue/saturation _only_ if they are undefined,
    // therefore this change flipping hue/saturation from undefined to a very tiny value would still be represented in color picker.
<span style = "background-color:#fdd">    ImGuiContext&amp; g = *GImGui;
    if (g.ColorEditLastColor != ImGui::ColorConvertFloat4ToU32(ImVec4(col[0], col[1], col[2], 0)))
        return;</span>

    // When S == 0, H is undefined.
    // When H == 1 it wraps around to 0.
<span style = "background-color:#fdd">    if (*S == 0.0f || (*H == 0.0f &amp;&amp; g.ColorEditLastHue == 1))
        *H = g.ColorEditLastHue;</span>

    // When V == 0, S is undefined.
<span style = "background-color:#fdd">    if (*V == 0.0f)
        *S = g.ColorEditLastSat;
}</span>

// Edit colors components (each component in 0.0f..1.0f range).
// See enum ImGuiColorEditFlags_ for available options. e.g. Only access 3 floats if ImGuiColorEditFlags_NoAlpha flag is set.
// With typical options: Left-click on color square to open color picker. Right-click to open option menu. CTRL-Click over input fields to edit them and TAB to go to next item.
bool ImGui::ColorEdit4(const char* label, float col[4], ImGuiColorEditFlags flags)
<span style = "background-color:#fdd">{
    ImGuiWindow* window = GetCurrentWindow();
    if (window-&gt;SkipItems)
        return false;</span>

<span style = "background-color:#fdd">    ImGuiContext&amp; g = *GImGui;
    const ImGuiStyle&amp; style = g.Style;
    const float square_sz = GetFrameHeight();
    const float w_full = CalcItemWidth();
    const float w_button = (flags &amp; ImGuiColorEditFlags_NoSmallPreview) ? 0.0f : (square_sz + style.ItemInnerSpacing.x);
    const float w_inputs = w_full - w_button;
    const char* label_display_end = FindRenderedTextEnd(label);
    g.NextItemData.ClearFlags();</span>

<span style = "background-color:#fdd">    BeginGroup();
    PushID(label);</span>

    // If we're not showing any slider there's no point in doing any HSV conversions
<span style = "background-color:#fdd">    const ImGuiColorEditFlags flags_untouched = flags;
    if (flags &amp; ImGuiColorEditFlags_NoInputs)
        flags = (flags &amp; (~ImGuiColorEditFlags_DisplayMask_)) | ImGuiColorEditFlags_DisplayRGB | ImGuiColorEditFlags_NoOptions;</span>

    // Context menu: display and modify options (before defaults are applied)
<span style = "background-color:#fdd">    if (!(flags &amp; ImGuiColorEditFlags_NoOptions))
        ColorEditOptionsPopup(col, flags);</span>

    // Read stored options
<span style = "background-color:#fdd">    if (!(flags &amp; ImGuiColorEditFlags_DisplayMask_))
        flags |= (g.ColorEditOptions &amp; ImGuiColorEditFlags_DisplayMask_);
    if (!(flags &amp; ImGuiColorEditFlags_DataTypeMask_))
        flags |= (g.ColorEditOptions &amp; ImGuiColorEditFlags_DataTypeMask_);
    if (!(flags &amp; ImGuiColorEditFlags_PickerMask_))
        flags |= (g.ColorEditOptions &amp; ImGuiColorEditFlags_PickerMask_);
    if (!(flags &amp; ImGuiColorEditFlags_InputMask_))
        flags |= (g.ColorEditOptions &amp; ImGuiColorEditFlags_InputMask_);
    flags |= (g.ColorEditOptions &amp; ~(ImGuiColorEditFlags_DisplayMask_ | ImGuiColorEditFlags_DataTypeMask_ | ImGuiColorEditFlags_PickerMask_ | ImGuiColorEditFlags_InputMask_));
    IM_ASSERT(ImIsPowerOfTwo(flags &amp; ImGuiColorEditFlags_DisplayMask_)); // Check that only 1 is selected
    IM_ASSERT(ImIsPowerOfTwo(flags &amp; ImGuiColorEditFlags_InputMask_));   // Check that only 1 is selected</span>

<span style = "background-color:#fdd">    const bool alpha = (flags &amp; ImGuiColorEditFlags_NoAlpha) == 0;
    const bool hdr = (flags &amp; ImGuiColorEditFlags_HDR) != 0;
    const int components = alpha ? 4 : 3;</span>

    // Convert to the formats we need
<span style = "background-color:#fdd">    float f[4] = { col[0], col[1], col[2], alpha ? col[3] : 1.0f };
    if ((flags &amp; ImGuiColorEditFlags_InputHSV) &amp;&amp; (flags &amp; ImGuiColorEditFlags_DisplayRGB))
        ColorConvertHSVtoRGB(f[0], f[1], f[2], f[0], f[1], f[2]);
    else if ((flags &amp; ImGuiColorEditFlags_InputRGB) &amp;&amp; (flags &amp; ImGuiColorEditFlags_DisplayHSV))</span>
    {
        // Hue is lost when converting from greyscale rgb (saturation=0). Restore it.
<span style = "background-color:#fdd">        ColorConvertRGBtoHSV(f[0], f[1], f[2], f[0], f[1], f[2]);
        ColorEditRestoreHS(col, &amp;f[0], &amp;f[1], &amp;f[2]);</span>
    }
<span style = "background-color:#fdd">    int i[4] = { IM_F32_TO_INT8_UNBOUND(f[0]), IM_F32_TO_INT8_UNBOUND(f[1]), IM_F32_TO_INT8_UNBOUND(f[2]), IM_F32_TO_INT8_UNBOUND(f[3]) };</span>

<span style = "background-color:#fdd">    bool value_changed = false;
    bool value_changed_as_float = false;</span>

<span style = "background-color:#fdd">    const ImVec2 pos = window-&gt;DC.CursorPos;
    const float inputs_offset_x = (style.ColorButtonPosition == ImGuiDir_Left) ? w_button : 0.0f;
    window-&gt;DC.CursorPos.x = pos.x + inputs_offset_x;</span>

<span style = "background-color:#fdd">    if ((flags &amp; (ImGuiColorEditFlags_DisplayRGB | ImGuiColorEditFlags_DisplayHSV)) != 0 &amp;&amp; (flags &amp; ImGuiColorEditFlags_NoInputs) == 0)</span>
    {
        // RGB/HSV 0..255 Sliders
<span style = "background-color:#fdd">        const float w_item_one  = ImMax(1.0f, IM_FLOOR((w_inputs - (style.ItemInnerSpacing.x) * (components - 1)) / (float)components));
        const float w_item_last = ImMax(1.0f, IM_FLOOR(w_inputs - (w_item_one + style.ItemInnerSpacing.x) * (components - 1)));</span>

<span style = "background-color:#fdd">        const bool hide_prefix = (w_item_one &lt;= CalcTextSize((flags &amp; ImGuiColorEditFlags_Float) ? "M:0.000" : "M:000").x);</span>
        static const char* ids[4] = { "##X", "##Y", "##Z", "##W" };
        static const char* fmt_table_int[3][4] =
        {
            {   "%3d",   "%3d",   "%3d",   "%3d" }, // Short display
            { "R:%3d", "G:%3d", "B:%3d", "A:%3d" }, // Long display for RGBA
            { "H:%3d", "S:%3d", "V:%3d", "A:%3d" }  // Long display for HSVA
        };
        static const char* fmt_table_float[3][4] =
        {
            {   "%0.3f",   "%0.3f",   "%0.3f",   "%0.3f" }, // Short display
            { "R:%0.3f", "G:%0.3f", "B:%0.3f", "A:%0.3f" }, // Long display for RGBA
            { "H:%0.3f", "S:%0.3f", "V:%0.3f", "A:%0.3f" }  // Long display for HSVA
        };
<span style = "background-color:#fdd">        const int fmt_idx = hide_prefix ? 0 : (flags &amp; ImGuiColorEditFlags_DisplayHSV) ? 2 : 1;</span>

<span style = "background-color:#fdd">        for (int n = 0; n &lt; components; n++)</span>
        {
<span style = "background-color:#fdd">            if (n &gt; 0)
                SameLine(0, style.ItemInnerSpacing.x);
            SetNextItemWidth((n + 1 &lt; components) ? w_item_one : w_item_last);</span>

            // FIXME: When ImGuiColorEditFlags_HDR flag is passed HS values snap in weird ways when SV values go below 0.
<span style = "background-color:#fdd">            if (flags &amp; ImGuiColorEditFlags_Float)</span>
            {
<span style = "background-color:#fdd">                value_changed |= DragFloat(ids[n], &amp;f[n], 1.0f / 255.0f, 0.0f, hdr ? 0.0f : 1.0f, fmt_table_float[fmt_idx][n]);
                value_changed_as_float |= value_changed;
            }</span>
            else
            {
<span style = "background-color:#fdd">                value_changed |= DragInt(ids[n], &amp;i[n], 1.0f, 0, hdr ? 0 : 255, fmt_table_int[fmt_idx][n]);</span>
            }
<span style = "background-color:#fdd">            if (!(flags &amp; ImGuiColorEditFlags_NoOptions))
                OpenPopupOnItemClick("context");
        }
    }
    else if ((flags &amp; ImGuiColorEditFlags_DisplayHex) != 0 &amp;&amp; (flags &amp; ImGuiColorEditFlags_NoInputs) == 0)</span>
    {
        // RGB Hexadecimal Input
        char buf[64];
<span style = "background-color:#fdd">        if (alpha)
            ImFormatString(buf, IM_ARRAYSIZE(buf), "#%02X%02X%02X%02X", ImClamp(i[0], 0, 255), ImClamp(i[1], 0, 255), ImClamp(i[2], 0, 255), ImClamp(i[3], 0, 255));</span>
        else
<span style = "background-color:#fdd">            ImFormatString(buf, IM_ARRAYSIZE(buf), "#%02X%02X%02X", ImClamp(i[0], 0, 255), ImClamp(i[1], 0, 255), ImClamp(i[2], 0, 255));
        SetNextItemWidth(w_inputs);
        if (InputText("##Text", buf, IM_ARRAYSIZE(buf), ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsUppercase))</span>
        {
<span style = "background-color:#fdd">            value_changed = true;
            char* p = buf;
            while (*p == '#' || ImCharIsBlankA(*p))
                p++;
            i[0] = i[1] = i[2] = 0;
            i[3] = 0xFF; // alpha default to 255 is not parsed by scanf (e.g. inputting #FFFFFF omitting alpha)</span>
            int r;
<span style = "background-color:#fdd">            if (alpha)
                r = sscanf(p, "%02X%02X%02X%02X", (unsigned int*)&amp;i[0], (unsigned int*)&amp;i[1], (unsigned int*)&amp;i[2], (unsigned int*)&amp;i[3]); // Treat at unsigned (%X is unsigned)</span>
            else
<span style = "background-color:#fdd">                r = sscanf(p, "%02X%02X%02X", (unsigned int*)&amp;i[0], (unsigned int*)&amp;i[1], (unsigned int*)&amp;i[2]);</span>
            IM_UNUSED(r); // Fixes C6031: Return value ignored: 'sscanf'.
        }
<span style = "background-color:#fdd">        if (!(flags &amp; ImGuiColorEditFlags_NoOptions))
            OpenPopupOnItemClick("context");</span>
    }

<span style = "background-color:#fdd">    ImGuiWindow* picker_active_window = NULL;
    if (!(flags &amp; ImGuiColorEditFlags_NoSmallPreview))</span>
    {
<span style = "background-color:#fdd">        const float button_offset_x = ((flags &amp; ImGuiColorEditFlags_NoInputs) || (style.ColorButtonPosition == ImGuiDir_Left)) ? 0.0f : w_inputs + style.ItemInnerSpacing.x;
        window-&gt;DC.CursorPos = ImVec2(pos.x + button_offset_x, pos.y);</span>

<span style = "background-color:#fdd">        const ImVec4 col_v4(col[0], col[1], col[2], alpha ? col[3] : 1.0f);
        if (ColorButton("##ColorButton", col_v4, flags))</span>
        {
<span style = "background-color:#fdd">            if (!(flags &amp; ImGuiColorEditFlags_NoPicker))</span>
            {
                // Store current color and open a picker
<span style = "background-color:#fdd">                g.ColorPickerRef = col_v4;
                OpenPopup("picker");
                SetNextWindowPos(g.LastItemData.Rect.GetBL() + ImVec2(-1, style.ItemSpacing.y));</span>
            }
        }
<span style = "background-color:#fdd">        if (!(flags &amp; ImGuiColorEditFlags_NoOptions))
            OpenPopupOnItemClick("context");</span>

<span style = "background-color:#fdd">        if (BeginPopup("picker"))</span>
        {
<span style = "background-color:#fdd">            picker_active_window = g.CurrentWindow;
            if (label != label_display_end)</span>
            {
<span style = "background-color:#fdd">                TextEx(label, label_display_end);
                Spacing();</span>
            }
<span style = "background-color:#fdd">            ImGuiColorEditFlags picker_flags_to_forward = ImGuiColorEditFlags_DataTypeMask_ | ImGuiColorEditFlags_PickerMask_ | ImGuiColorEditFlags_InputMask_ | ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaBar;
            ImGuiColorEditFlags picker_flags = (flags_untouched &amp; picker_flags_to_forward) | ImGuiColorEditFlags_DisplayMask_ | ImGuiColorEditFlags_NoLabel | ImGuiColorEditFlags_AlphaPreviewHalf;
            SetNextItemWidth(square_sz * 12.0f); // Use 256 + bar sizes?
            value_changed |= ColorPicker4("##picker", col, picker_flags, &amp;g.ColorPickerRef.x);
            EndPopup();</span>
        }
    }

<span style = "background-color:#fdd">    if (label != label_display_end &amp;&amp; !(flags &amp; ImGuiColorEditFlags_NoLabel))</span>
    {
<span style = "background-color:#fdd">        const float text_offset_x = (flags &amp; ImGuiColorEditFlags_NoInputs) ? w_button : w_full + style.ItemInnerSpacing.x;
        window-&gt;DC.CursorPos = ImVec2(pos.x + text_offset_x, pos.y + style.FramePadding.y);
        TextEx(label, label_display_end);</span>
    }

    // Convert back
<span style = "background-color:#fdd">    if (value_changed &amp;&amp; picker_active_window == NULL)</span>
    {
<span style = "background-color:#fdd">        if (!value_changed_as_float)
            for (int n = 0; n &lt; 4; n++)
                f[n] = i[n] / 255.0f;
        if ((flags &amp; ImGuiColorEditFlags_DisplayHSV) &amp;&amp; (flags &amp; ImGuiColorEditFlags_InputRGB))</span>
        {
<span style = "background-color:#fdd">            g.ColorEditLastHue = f[0];
            g.ColorEditLastSat = f[1];
            ColorConvertHSVtoRGB(f[0], f[1], f[2], f[0], f[1], f[2]);
            g.ColorEditLastColor = ColorConvertFloat4ToU32(ImVec4(f[0], f[1], f[2], 0));</span>
        }
<span style = "background-color:#fdd">        if ((flags &amp; ImGuiColorEditFlags_DisplayRGB) &amp;&amp; (flags &amp; ImGuiColorEditFlags_InputHSV))
            ColorConvertRGBtoHSV(f[0], f[1], f[2], f[0], f[1], f[2]);</span>

<span style = "background-color:#fdd">        col[0] = f[0];
        col[1] = f[1];
        col[2] = f[2];
        if (alpha)
            col[3] = f[3];</span>
    }

<span style = "background-color:#fdd">    PopID();
    EndGroup();</span>

    // Drag and Drop Target
    // NB: The flag test is merely an optional micro-optimization, BeginDragDropTarget() does the same test.
<span style = "background-color:#fdd">    if ((g.LastItemData.StatusFlags &amp; ImGuiItemStatusFlags_HoveredRect) &amp;&amp; !(flags &amp; ImGuiColorEditFlags_NoDragDrop) &amp;&amp; BeginDragDropTarget())</span>
    {
<span style = "background-color:#fdd">        bool accepted_drag_drop = false;
        if (const ImGuiPayload* payload = AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_3F))</span>
        {
<span style = "background-color:#fdd">            memcpy((float*)col, payload-&gt;Data, sizeof(float) * 3); // Preserve alpha if any //-V512
            value_changed = accepted_drag_drop = true;</span>
        }
<span style = "background-color:#fdd">        if (const ImGuiPayload* payload = AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_4F))</span>
        {
<span style = "background-color:#fdd">            memcpy((float*)col, payload-&gt;Data, sizeof(float) * components);
            value_changed = accepted_drag_drop = true;</span>
        }

        // Drag-drop payloads are always RGB
<span style = "background-color:#fdd">        if (accepted_drag_drop &amp;&amp; (flags &amp; ImGuiColorEditFlags_InputHSV))
            ColorConvertRGBtoHSV(col[0], col[1], col[2], col[0], col[1], col[2]);
        EndDragDropTarget();</span>
    }

    // When picker is being actively used, use its active id so IsItemActive() will function on ColorEdit4().
<span style = "background-color:#fdd">    if (picker_active_window &amp;&amp; g.ActiveId != 0 &amp;&amp; g.ActiveIdWindow == picker_active_window)
        g.LastItemData.ID = g.ActiveId;</span>

<span style = "background-color:#fdd">    if (value_changed)
        MarkItemEdited(g.LastItemData.ID);</span>

<span style = "background-color:#fdd">    return value_changed;
}</span>

bool ImGui::ColorPicker3(const char* label, float col[3], ImGuiColorEditFlags flags)
<span style = "background-color:#fdd">{
    float col4[4] = { col[0], col[1], col[2], 1.0f };
    if (!ColorPicker4(label, col4, flags | ImGuiColorEditFlags_NoAlpha))
        return false;
    col[0] = col4[0]; col[1] = col4[1]; col[2] = col4[2];
    return true;
}</span>

// Helper for ColorPicker4()
static void RenderArrowsForVerticalBar(ImDrawList* draw_list, ImVec2 pos, ImVec2 half_sz, float bar_w, float alpha)
<span style = "background-color:#fdd">{
    ImU32 alpha8 = IM_F32_TO_INT8_SAT(alpha);
    ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + half_sz.x + 1,         pos.y), ImVec2(half_sz.x + 2, half_sz.y + 1), ImGuiDir_Right, IM_COL32(0,0,0,alpha8));
    ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + half_sz.x,             pos.y), half_sz,                              ImGuiDir_Right, IM_COL32(255,255,255,alpha8));
    ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + bar_w - half_sz.x - 1, pos.y), ImVec2(half_sz.x + 2, half_sz.y + 1), ImGuiDir_Left,  IM_COL32(0,0,0,alpha8));
    ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + bar_w - half_sz.x,     pos.y), half_sz,                              ImGuiDir_Left,  IM_COL32(255,255,255,alpha8));
}</span>

// Note: ColorPicker4() only accesses 3 floats if ImGuiColorEditFlags_NoAlpha flag is set.
// (In C++ the 'float col[4]' notation for a function argument is equivalent to 'float* col', we only specify a size to facilitate understanding of the code.)
// FIXME: we adjust the big color square height based on item width, which may cause a flickering feedback loop (if automatic height makes a vertical scrollbar appears, affecting automatic width..)
// FIXME: this is trying to be aware of style.Alpha but not fully correct. Also, the color wheel will have overlapping glitches with (style.Alpha &lt; 1.0)
bool ImGui::ColorPicker4(const char* label, float col[4], ImGuiColorEditFlags flags, const float* ref_col)
<span style = "background-color:#fdd">{
    ImGuiContext&amp; g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();
    if (window-&gt;SkipItems)
        return false;</span>

<span style = "background-color:#fdd">    ImDrawList* draw_list = window-&gt;DrawList;
    ImGuiStyle&amp; style = g.Style;
    ImGuiIO&amp; io = g.IO;</span>

<span style = "background-color:#fdd">    const float width = CalcItemWidth();
    g.NextItemData.ClearFlags();</span>

<span style = "background-color:#fdd">    PushID(label);
    BeginGroup();</span>

<span style = "background-color:#fdd">    if (!(flags &amp; ImGuiColorEditFlags_NoSidePreview))
        flags |= ImGuiColorEditFlags_NoSmallPreview;</span>

    // Context menu: display and store options.
<span style = "background-color:#fdd">    if (!(flags &amp; ImGuiColorEditFlags_NoOptions))
        ColorPickerOptionsPopup(col, flags);</span>

    // Read stored options
<span style = "background-color:#fdd">    if (!(flags &amp; ImGuiColorEditFlags_PickerMask_))
        flags |= ((g.ColorEditOptions &amp; ImGuiColorEditFlags_PickerMask_) ? g.ColorEditOptions : ImGuiColorEditFlags_DefaultOptions_) &amp; ImGuiColorEditFlags_PickerMask_;
    if (!(flags &amp; ImGuiColorEditFlags_InputMask_))
        flags |= ((g.ColorEditOptions &amp; ImGuiColorEditFlags_InputMask_) ? g.ColorEditOptions : ImGuiColorEditFlags_DefaultOptions_) &amp; ImGuiColorEditFlags_InputMask_;
    IM_ASSERT(ImIsPowerOfTwo(flags &amp; ImGuiColorEditFlags_PickerMask_)); // Check that only 1 is selected
    IM_ASSERT(ImIsPowerOfTwo(flags &amp; ImGuiColorEditFlags_InputMask_));  // Check that only 1 is selected
    if (!(flags &amp; ImGuiColorEditFlags_NoOptions))
        flags |= (g.ColorEditOptions &amp; ImGuiColorEditFlags_AlphaBar);</span>

    // Setup
<span style = "background-color:#fdd">    int components = (flags &amp; ImGuiColorEditFlags_NoAlpha) ? 3 : 4;
    bool alpha_bar = (flags &amp; ImGuiColorEditFlags_AlphaBar) &amp;&amp; !(flags &amp; ImGuiColorEditFlags_NoAlpha);
    ImVec2 picker_pos = window-&gt;DC.CursorPos;
    float square_sz = GetFrameHeight();
    float bars_width = square_sz; // Arbitrary smallish width of Hue/Alpha picking bars
    float sv_picker_size = ImMax(bars_width * 1, width - (alpha_bar ? 2 : 1) * (bars_width + style.ItemInnerSpacing.x)); // Saturation/Value picking box
    float bar0_pos_x = picker_pos.x + sv_picker_size + style.ItemInnerSpacing.x;
    float bar1_pos_x = bar0_pos_x + bars_width + style.ItemInnerSpacing.x;
    float bars_triangles_half_sz = IM_FLOOR(bars_width * 0.20f);</span>

    float backup_initial_col[4];
<span style = "background-color:#fdd">    memcpy(backup_initial_col, col, components * sizeof(float));</span>

<span style = "background-color:#fdd">    float wheel_thickness = sv_picker_size * 0.08f;
    float wheel_r_outer = sv_picker_size * 0.50f;
    float wheel_r_inner = wheel_r_outer - wheel_thickness;
    ImVec2 wheel_center(picker_pos.x + (sv_picker_size + bars_width)*0.5f, picker_pos.y + sv_picker_size * 0.5f);</span>

    // Note: the triangle is displayed rotated with triangle_pa pointing to Hue, but most coordinates stays unrotated for logic.
<span style = "background-color:#fdd">    float triangle_r = wheel_r_inner - (int)(sv_picker_size * 0.027f);
    ImVec2 triangle_pa = ImVec2(triangle_r, 0.0f); // Hue point.
    ImVec2 triangle_pb = ImVec2(triangle_r * -0.5f, triangle_r * -0.866025f); // Black point.
    ImVec2 triangle_pc = ImVec2(triangle_r * -0.5f, triangle_r * +0.866025f); // White point.</span>

<span style = "background-color:#fdd">    float H = col[0], S = col[1], V = col[2];
    float R = col[0], G = col[1], B = col[2];
    if (flags &amp; ImGuiColorEditFlags_InputRGB)</span>
    {
        // Hue is lost when converting from greyscale rgb (saturation=0). Restore it.
<span style = "background-color:#fdd">        ColorConvertRGBtoHSV(R, G, B, H, S, V);
        ColorEditRestoreHS(col, &amp;H, &amp;S, &amp;V);
    }
    else if (flags &amp; ImGuiColorEditFlags_InputHSV)</span>
    {
<span style = "background-color:#fdd">        ColorConvertHSVtoRGB(H, S, V, R, G, B);</span>
    }

<span style = "background-color:#fdd">    bool value_changed = false, value_changed_h = false, value_changed_sv = false;</span>

<span style = "background-color:#fdd">    PushItemFlag(ImGuiItemFlags_NoNav, true);
    if (flags &amp; ImGuiColorEditFlags_PickerHueWheel)</span>
    {
        // Hue wheel + SV triangle logic
<span style = "background-color:#fdd">        InvisibleButton("hsv", ImVec2(sv_picker_size + style.ItemInnerSpacing.x + bars_width, sv_picker_size));
        if (IsItemActive())</span>
        {
<span style = "background-color:#fdd">            ImVec2 initial_off = g.IO.MouseClickedPos[0] - wheel_center;
            ImVec2 current_off = g.IO.MousePos - wheel_center;
            float initial_dist2 = ImLengthSqr(initial_off);
            if (initial_dist2 &gt;= (wheel_r_inner - 1) * (wheel_r_inner - 1) &amp;&amp; initial_dist2 &lt;= (wheel_r_outer + 1) * (wheel_r_outer + 1))</span>
            {
                // Interactive with Hue wheel
<span style = "background-color:#fdd">                H = ImAtan2(current_off.y, current_off.x) / IM_PI * 0.5f;
                if (H &lt; 0.0f)
                    H += 1.0f;
                value_changed = value_changed_h = true;</span>
            }
<span style = "background-color:#fdd">            float cos_hue_angle = ImCos(-H * 2.0f * IM_PI);
            float sin_hue_angle = ImSin(-H * 2.0f * IM_PI);
            if (ImTriangleContainsPoint(triangle_pa, triangle_pb, triangle_pc, ImRotate(initial_off, cos_hue_angle, sin_hue_angle)))</span>
            {
                // Interacting with SV triangle
<span style = "background-color:#fdd">                ImVec2 current_off_unrotated = ImRotate(current_off, cos_hue_angle, sin_hue_angle);
                if (!ImTriangleContainsPoint(triangle_pa, triangle_pb, triangle_pc, current_off_unrotated))
                    current_off_unrotated = ImTriangleClosestPoint(triangle_pa, triangle_pb, triangle_pc, current_off_unrotated);</span>
                float uu, vv, ww;
<span style = "background-color:#fdd">                ImTriangleBarycentricCoords(triangle_pa, triangle_pb, triangle_pc, current_off_unrotated, uu, vv, ww);
                V = ImClamp(1.0f - vv, 0.0001f, 1.0f);
                S = ImClamp(uu / V, 0.0001f, 1.0f);
                value_changed = value_changed_sv = true;</span>
            }
        }
<span style = "background-color:#fdd">        if (!(flags &amp; ImGuiColorEditFlags_NoOptions))
            OpenPopupOnItemClick("context");
    }
    else if (flags &amp; ImGuiColorEditFlags_PickerHueBar)</span>
    {
        // SV rectangle logic
<span style = "background-color:#fdd">        InvisibleButton("sv", ImVec2(sv_picker_size, sv_picker_size));
        if (IsItemActive())</span>
        {
<span style = "background-color:#fdd">            S = ImSaturate((io.MousePos.x - picker_pos.x) / (sv_picker_size - 1));
            V = 1.0f - ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size - 1));</span>

            // Greatly reduces hue jitter and reset to 0 when hue == 255 and color is rapidly modified using SV square.
<span style = "background-color:#fdd">            if (g.ColorEditLastColor == ColorConvertFloat4ToU32(ImVec4(col[0], col[1], col[2], 0)))
                H = g.ColorEditLastHue;
            value_changed = value_changed_sv = true;</span>
        }
<span style = "background-color:#fdd">        if (!(flags &amp; ImGuiColorEditFlags_NoOptions))
            OpenPopupOnItemClick("context");</span>

        // Hue bar logic
<span style = "background-color:#fdd">        SetCursorScreenPos(ImVec2(bar0_pos_x, picker_pos.y));
        InvisibleButton("hue", ImVec2(bars_width, sv_picker_size));
        if (IsItemActive())</span>
        {
<span style = "background-color:#fdd">            H = ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size - 1));
            value_changed = value_changed_h = true;</span>
        }
    }

    // Alpha bar logic
<span style = "background-color:#fdd">    if (alpha_bar)</span>
    {
<span style = "background-color:#fdd">        SetCursorScreenPos(ImVec2(bar1_pos_x, picker_pos.y));
        InvisibleButton("alpha", ImVec2(bars_width, sv_picker_size));
        if (IsItemActive())</span>
        {
<span style = "background-color:#fdd">            col[3] = 1.0f - ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size - 1));
            value_changed = true;</span>
        }
    }
<span style = "background-color:#fdd">    PopItemFlag(); // ImGuiItemFlags_NoNav</span>

<span style = "background-color:#fdd">    if (!(flags &amp; ImGuiColorEditFlags_NoSidePreview))</span>
    {
<span style = "background-color:#fdd">        SameLine(0, style.ItemInnerSpacing.x);
        BeginGroup();</span>
    }

<span style = "background-color:#fdd">    if (!(flags &amp; ImGuiColorEditFlags_NoLabel))</span>
    {
<span style = "background-color:#fdd">        const char* label_display_end = FindRenderedTextEnd(label);
        if (label != label_display_end)</span>
        {
<span style = "background-color:#fdd">            if ((flags &amp; ImGuiColorEditFlags_NoSidePreview))
                SameLine(0, style.ItemInnerSpacing.x);
            TextEx(label, label_display_end);</span>
        }
    }

<span style = "background-color:#fdd">    if (!(flags &amp; ImGuiColorEditFlags_NoSidePreview))</span>
    {
<span style = "background-color:#fdd">        PushItemFlag(ImGuiItemFlags_NoNavDefaultFocus, true);
        ImVec4 col_v4(col[0], col[1], col[2], (flags &amp; ImGuiColorEditFlags_NoAlpha) ? 1.0f : col[3]);
        if ((flags &amp; ImGuiColorEditFlags_NoLabel))
            Text("Current");</span>

<span style = "background-color:#fdd">        ImGuiColorEditFlags sub_flags_to_forward = ImGuiColorEditFlags_InputMask_ | ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf | ImGuiColorEditFlags_NoTooltip;
        ColorButton("##current", col_v4, (flags &amp; sub_flags_to_forward), ImVec2(square_sz * 3, square_sz * 2));
        if (ref_col != NULL)</span>
        {
<span style = "background-color:#fdd">            Text("Original");
            ImVec4 ref_col_v4(ref_col[0], ref_col[1], ref_col[2], (flags &amp; ImGuiColorEditFlags_NoAlpha) ? 1.0f : ref_col[3]);
            if (ColorButton("##original", ref_col_v4, (flags &amp; sub_flags_to_forward), ImVec2(square_sz * 3, square_sz * 2)))</span>
            {
<span style = "background-color:#fdd">                memcpy(col, ref_col, components * sizeof(float));
                value_changed = true;</span>
            }
        }
<span style = "background-color:#fdd">        PopItemFlag();
        EndGroup();</span>
    }

    // Convert back color to RGB
<span style = "background-color:#fdd">    if (value_changed_h || value_changed_sv)</span>
    {
<span style = "background-color:#fdd">        if (flags &amp; ImGuiColorEditFlags_InputRGB)</span>
        {
<span style = "background-color:#fdd">            ColorConvertHSVtoRGB(H, S, V, col[0], col[1], col[2]);
            g.ColorEditLastHue = H;
            g.ColorEditLastSat = S;
            g.ColorEditLastColor = ColorConvertFloat4ToU32(ImVec4(col[0], col[1], col[2], 0));
        }
        else if (flags &amp; ImGuiColorEditFlags_InputHSV)</span>
        {
<span style = "background-color:#fdd">            col[0] = H;
            col[1] = S;
            col[2] = V;</span>
        }
    }

    // R,G,B and H,S,V slider color editor
<span style = "background-color:#fdd">    bool value_changed_fix_hue_wrap = false;
    if ((flags &amp; ImGuiColorEditFlags_NoInputs) == 0)</span>
    {
<span style = "background-color:#fdd">        PushItemWidth((alpha_bar ? bar1_pos_x : bar0_pos_x) + bars_width - picker_pos.x);
        ImGuiColorEditFlags sub_flags_to_forward = ImGuiColorEditFlags_DataTypeMask_ | ImGuiColorEditFlags_InputMask_ | ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_NoOptions | ImGuiColorEditFlags_NoSmallPreview | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf;
        ImGuiColorEditFlags sub_flags = (flags &amp; sub_flags_to_forward) | ImGuiColorEditFlags_NoPicker;
        if (flags &amp; ImGuiColorEditFlags_DisplayRGB || (flags &amp; ImGuiColorEditFlags_DisplayMask_) == 0)
            if (ColorEdit4("##rgb", col, sub_flags | ImGuiColorEditFlags_DisplayRGB))</span>
            {
                // FIXME: Hackily differentiating using the DragInt (ActiveId != 0 &amp;&amp; !ActiveIdAllowOverlap) vs. using the InputText or DropTarget.
                // For the later we don't want to run the hue-wrap canceling code. If you are well versed in HSV picker please provide your input! (See #2050)
<span style = "background-color:#fdd">                value_changed_fix_hue_wrap = (g.ActiveId != 0 &amp;&amp; !g.ActiveIdAllowOverlap);
                value_changed = true;</span>
            }
<span style = "background-color:#fdd">        if (flags &amp; ImGuiColorEditFlags_DisplayHSV || (flags &amp; ImGuiColorEditFlags_DisplayMask_) == 0)
            value_changed |= ColorEdit4("##hsv", col, sub_flags | ImGuiColorEditFlags_DisplayHSV);
        if (flags &amp; ImGuiColorEditFlags_DisplayHex || (flags &amp; ImGuiColorEditFlags_DisplayMask_) == 0)
            value_changed |= ColorEdit4("##hex", col, sub_flags | ImGuiColorEditFlags_DisplayHex);
        PopItemWidth();</span>
    }

    // Try to cancel hue wrap (after ColorEdit4 call), if any
<span style = "background-color:#fdd">    if (value_changed_fix_hue_wrap &amp;&amp; (flags &amp; ImGuiColorEditFlags_InputRGB))</span>
    {
        float new_H, new_S, new_V;
<span style = "background-color:#fdd">        ColorConvertRGBtoHSV(col[0], col[1], col[2], new_H, new_S, new_V);
        if (new_H &lt;= 0 &amp;&amp; H &gt; 0)</span>
        {
<span style = "background-color:#fdd">            if (new_V &lt;= 0 &amp;&amp; V != new_V)
                ColorConvertHSVtoRGB(H, S, new_V &lt;= 0 ? V * 0.5f : new_V, col[0], col[1], col[2]);
            else if (new_S &lt;= 0)
                ColorConvertHSVtoRGB(H, new_S &lt;= 0 ? S * 0.5f : new_S, new_V, col[0], col[1], col[2]);</span>
        }
    }

<span style = "background-color:#fdd">    if (value_changed)</span>
    {
<span style = "background-color:#fdd">        if (flags &amp; ImGuiColorEditFlags_InputRGB)</span>
        {
<span style = "background-color:#fdd">            R = col[0];
            G = col[1];
            B = col[2];
            ColorConvertRGBtoHSV(R, G, B, H, S, V);
            ColorEditRestoreHS(col, &amp;H, &amp;S, &amp;V);   // Fix local Hue as display below will use it immediately.
        }
        else if (flags &amp; ImGuiColorEditFlags_InputHSV)</span>
        {
<span style = "background-color:#fdd">            H = col[0];
            S = col[1];
            V = col[2];
            ColorConvertHSVtoRGB(H, S, V, R, G, B);</span>
        }
    }

<span style = "background-color:#fdd">    const int style_alpha8 = IM_F32_TO_INT8_SAT(style.Alpha);
    const ImU32 col_black = IM_COL32(0,0,0,style_alpha8);
    const ImU32 col_white = IM_COL32(255,255,255,style_alpha8);
    const ImU32 col_midgrey = IM_COL32(128,128,128,style_alpha8);
    const ImU32 col_hues[6 + 1] = { IM_COL32(255,0,0,style_alpha8), IM_COL32(255,255,0,style_alpha8), IM_COL32(0,255,0,style_alpha8), IM_COL32(0,255,255,style_alpha8), IM_COL32(0,0,255,style_alpha8), IM_COL32(255,0,255,style_alpha8), IM_COL32(255,0,0,style_alpha8) };</span>

<span style = "background-color:#fdd">    ImVec4 hue_color_f(1, 1, 1, style.Alpha); ColorConvertHSVtoRGB(H, 1, 1, hue_color_f.x, hue_color_f.y, hue_color_f.z);
    ImU32 hue_color32 = ColorConvertFloat4ToU32(hue_color_f);
    ImU32 user_col32_striped_of_alpha = ColorConvertFloat4ToU32(ImVec4(R, G, B, style.Alpha)); // Important: this is still including the main rendering/style alpha!!</span>

<span style = "background-color:#fdd">    ImVec2 sv_cursor_pos;</span>

<span style = "background-color:#fdd">    if (flags &amp; ImGuiColorEditFlags_PickerHueWheel)</span>
    {
        // Render Hue Wheel
<span style = "background-color:#fdd">        const float aeps = 0.5f / wheel_r_outer; // Half a pixel arc length in radians (2pi cancels out).
        const int segment_per_arc = ImMax(4, (int)wheel_r_outer / 12);
        for (int n = 0; n &lt; 6; n++)</span>
        {
<span style = "background-color:#fdd">            const float a0 = (n)     /6.0f * 2.0f * IM_PI - aeps;
            const float a1 = (n+1.0f)/6.0f * 2.0f * IM_PI + aeps;
            const int vert_start_idx = draw_list-&gt;VtxBuffer.Size;
            draw_list-&gt;PathArcTo(wheel_center, (wheel_r_inner + wheel_r_outer)*0.5f, a0, a1, segment_per_arc);
            draw_list-&gt;PathStroke(col_white, 0, wheel_thickness);
            const int vert_end_idx = draw_list-&gt;VtxBuffer.Size;</span>

            // Paint colors over existing vertices
<span style = "background-color:#fdd">            ImVec2 gradient_p0(wheel_center.x + ImCos(a0) * wheel_r_inner, wheel_center.y + ImSin(a0) * wheel_r_inner);
            ImVec2 gradient_p1(wheel_center.x + ImCos(a1) * wheel_r_inner, wheel_center.y + ImSin(a1) * wheel_r_inner);
            ShadeVertsLinearColorGradientKeepAlpha(draw_list, vert_start_idx, vert_end_idx, gradient_p0, gradient_p1, col_hues[n], col_hues[n + 1]);
        }</span>

        // Render Cursor + preview on Hue Wheel
<span style = "background-color:#fdd">        float cos_hue_angle = ImCos(H * 2.0f * IM_PI);
        float sin_hue_angle = ImSin(H * 2.0f * IM_PI);
        ImVec2 hue_cursor_pos(wheel_center.x + cos_hue_angle * (wheel_r_inner + wheel_r_outer) * 0.5f, wheel_center.y + sin_hue_angle * (wheel_r_inner + wheel_r_outer) * 0.5f);
        float hue_cursor_rad = value_changed_h ? wheel_thickness * 0.65f : wheel_thickness * 0.55f;
        int hue_cursor_segments = ImClamp((int)(hue_cursor_rad / 1.4f), 9, 32);
        draw_list-&gt;AddCircleFilled(hue_cursor_pos, hue_cursor_rad, hue_color32, hue_cursor_segments);
        draw_list-&gt;AddCircle(hue_cursor_pos, hue_cursor_rad + 1, col_midgrey, hue_cursor_segments);
        draw_list-&gt;AddCircle(hue_cursor_pos, hue_cursor_rad, col_white, hue_cursor_segments);</span>

        // Render SV triangle (rotated according to hue)
<span style = "background-color:#fdd">        ImVec2 tra = wheel_center + ImRotate(triangle_pa, cos_hue_angle, sin_hue_angle);
        ImVec2 trb = wheel_center + ImRotate(triangle_pb, cos_hue_angle, sin_hue_angle);
        ImVec2 trc = wheel_center + ImRotate(triangle_pc, cos_hue_angle, sin_hue_angle);
        ImVec2 uv_white = GetFontTexUvWhitePixel();
        draw_list-&gt;PrimReserve(6, 6);
        draw_list-&gt;PrimVtx(tra, uv_white, hue_color32);
        draw_list-&gt;PrimVtx(trb, uv_white, hue_color32);
        draw_list-&gt;PrimVtx(trc, uv_white, col_white);
        draw_list-&gt;PrimVtx(tra, uv_white, 0);
        draw_list-&gt;PrimVtx(trb, uv_white, col_black);
        draw_list-&gt;PrimVtx(trc, uv_white, 0);
        draw_list-&gt;AddTriangle(tra, trb, trc, col_midgrey, 1.5f);
        sv_cursor_pos = ImLerp(ImLerp(trc, tra, ImSaturate(S)), trb, ImSaturate(1 - V));
    }
    else if (flags &amp; ImGuiColorEditFlags_PickerHueBar)</span>
    {
        // Render SV Square
<span style = "background-color:#fdd">        draw_list-&gt;AddRectFilledMultiColor(picker_pos, picker_pos + ImVec2(sv_picker_size, sv_picker_size), col_white, hue_color32, hue_color32, col_white);
        draw_list-&gt;AddRectFilledMultiColor(picker_pos, picker_pos + ImVec2(sv_picker_size, sv_picker_size), 0, 0, col_black, col_black);
        RenderFrameBorder(picker_pos, picker_pos + ImVec2(sv_picker_size, sv_picker_size), 0.0f);
        sv_cursor_pos.x = ImClamp(IM_ROUND(picker_pos.x + ImSaturate(S)     * sv_picker_size), picker_pos.x + 2, picker_pos.x + sv_picker_size - 2); // Sneakily prevent the circle to stick out too much
        sv_cursor_pos.y = ImClamp(IM_ROUND(picker_pos.y + ImSaturate(1 - V) * sv_picker_size), picker_pos.y + 2, picker_pos.y + sv_picker_size - 2);</span>

        // Render Hue Bar
<span style = "background-color:#fdd">        for (int i = 0; i &lt; 6; ++i)
            draw_list-&gt;AddRectFilledMultiColor(ImVec2(bar0_pos_x, picker_pos.y + i * (sv_picker_size / 6)), ImVec2(bar0_pos_x + bars_width, picker_pos.y + (i + 1) * (sv_picker_size / 6)), col_hues[i], col_hues[i], col_hues[i + 1], col_hues[i + 1]);
        float bar0_line_y = IM_ROUND(picker_pos.y + H * sv_picker_size);
        RenderFrameBorder(ImVec2(bar0_pos_x, picker_pos.y), ImVec2(bar0_pos_x + bars_width, picker_pos.y + sv_picker_size), 0.0f);
        RenderArrowsForVerticalBar(draw_list, ImVec2(bar0_pos_x - 1, bar0_line_y), ImVec2(bars_triangles_half_sz + 1, bars_triangles_half_sz), bars_width + 2.0f, style.Alpha);</span>
    }

    // Render cursor/preview circle (clamp S/V within 0..1 range because floating points colors may lead HSV values to be out of range)
<span style = "background-color:#fdd">    float sv_cursor_rad = value_changed_sv ? 10.0f : 6.0f;
    draw_list-&gt;AddCircleFilled(sv_cursor_pos, sv_cursor_rad, user_col32_striped_of_alpha, 12);
    draw_list-&gt;AddCircle(sv_cursor_pos, sv_cursor_rad + 1, col_midgrey, 12);
    draw_list-&gt;AddCircle(sv_cursor_pos, sv_cursor_rad, col_white, 12);</span>

    // Render alpha bar
<span style = "background-color:#fdd">    if (alpha_bar)</span>
    {
<span style = "background-color:#fdd">        float alpha = ImSaturate(col[3]);
        ImRect bar1_bb(bar1_pos_x, picker_pos.y, bar1_pos_x + bars_width, picker_pos.y + sv_picker_size);
        RenderColorRectWithAlphaCheckerboard(draw_list, bar1_bb.Min, bar1_bb.Max, 0, bar1_bb.GetWidth() / 2.0f, ImVec2(0.0f, 0.0f));
        draw_list-&gt;AddRectFilledMultiColor(bar1_bb.Min, bar1_bb.Max, user_col32_striped_of_alpha, user_col32_striped_of_alpha, user_col32_striped_of_alpha &amp; ~IM_COL32_A_MASK, user_col32_striped_of_alpha &amp; ~IM_COL32_A_MASK);
        float bar1_line_y = IM_ROUND(picker_pos.y + (1.0f - alpha) * sv_picker_size);
        RenderFrameBorder(bar1_bb.Min, bar1_bb.Max, 0.0f);
        RenderArrowsForVerticalBar(draw_list, ImVec2(bar1_pos_x - 1, bar1_line_y), ImVec2(bars_triangles_half_sz + 1, bars_triangles_half_sz), bars_width + 2.0f, style.Alpha);</span>
    }

<span style = "background-color:#fdd">    EndGroup();</span>

<span style = "background-color:#fdd">    if (value_changed &amp;&amp; memcmp(backup_initial_col, col, components * sizeof(float)) == 0)
        value_changed = false;
    if (value_changed)
        MarkItemEdited(g.LastItemData.ID);</span>

<span style = "background-color:#fdd">    PopID();</span>

<span style = "background-color:#fdd">    return value_changed;
}</span>

// A little color square. Return true when clicked.
// FIXME: May want to display/ignore the alpha component in the color display? Yet show it in the tooltip.
// 'desc_id' is not called 'label' because we don't display it next to the button, but only in the tooltip.
// Note that 'col' may be encoded in HSV if ImGuiColorEditFlags_InputHSV is set.
bool ImGui::ColorButton(const char* desc_id, const ImVec4&amp; col, ImGuiColorEditFlags flags, ImVec2 size)
<span style = "background-color:#fdd">{
    ImGuiWindow* window = GetCurrentWindow();
    if (window-&gt;SkipItems)
        return false;</span>

<span style = "background-color:#fdd">    ImGuiContext&amp; g = *GImGui;
    const ImGuiID id = window-&gt;GetID(desc_id);
    float default_size = GetFrameHeight();
    if (size.x == 0.0f)
        size.x = default_size;
    if (size.y == 0.0f)
        size.y = default_size;
    const ImRect bb(window-&gt;DC.CursorPos, window-&gt;DC.CursorPos + size);
    ItemSize(bb, (size.y &gt;= default_size) ? g.Style.FramePadding.y : 0.0f);
    if (!ItemAdd(bb, id))
        return false;</span>

    bool hovered, held;
<span style = "background-color:#fdd">    bool pressed = ButtonBehavior(bb, id, &amp;hovered, &amp;held);</span>

<span style = "background-color:#fdd">    if (flags &amp; ImGuiColorEditFlags_NoAlpha)
        flags &amp;= ~(ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf);</span>

<span style = "background-color:#fdd">    ImVec4 col_rgb = col;
    if (flags &amp; ImGuiColorEditFlags_InputHSV)
        ColorConvertHSVtoRGB(col_rgb.x, col_rgb.y, col_rgb.z, col_rgb.x, col_rgb.y, col_rgb.z);</span>

<span style = "background-color:#fdd">    ImVec4 col_rgb_without_alpha(col_rgb.x, col_rgb.y, col_rgb.z, 1.0f);
    float grid_step = ImMin(size.x, size.y) / 2.99f;
    float rounding = ImMin(g.Style.FrameRounding, grid_step * 0.5f);
    ImRect bb_inner = bb;
    float off = 0.0f;
    if ((flags &amp; ImGuiColorEditFlags_NoBorder) == 0)</span>
    {
<span style = "background-color:#fdd">        off = -0.75f; // The border (using Col_FrameBg) tends to look off when color is near-opaque and rounding is enabled. This offset seemed like a good middle ground to reduce those artifacts.
        bb_inner.Expand(off);</span>
    }
<span style = "background-color:#fdd">    if ((flags &amp; ImGuiColorEditFlags_AlphaPreviewHalf) &amp;&amp; col_rgb.w &lt; 1.0f)</span>
    {
<span style = "background-color:#fdd">        float mid_x = IM_ROUND((bb_inner.Min.x + bb_inner.Max.x) * 0.5f);
        RenderColorRectWithAlphaCheckerboard(window-&gt;DrawList, ImVec2(bb_inner.Min.x + grid_step, bb_inner.Min.y), bb_inner.Max, GetColorU32(col_rgb), grid_step, ImVec2(-grid_step + off, off), rounding, ImDrawFlags_RoundCornersRight);
        window-&gt;DrawList-&gt;AddRectFilled(bb_inner.Min, ImVec2(mid_x, bb_inner.Max.y), GetColorU32(col_rgb_without_alpha), rounding, ImDrawFlags_RoundCornersLeft);
    }</span>
    else
    {
        // Because GetColorU32() multiplies by the global style Alpha and we don't want to display a checkerboard if the source code had no alpha
<span style = "background-color:#fdd">        ImVec4 col_source = (flags &amp; ImGuiColorEditFlags_AlphaPreview) ? col_rgb : col_rgb_without_alpha;
        if (col_source.w &lt; 1.0f)
            RenderColorRectWithAlphaCheckerboard(window-&gt;DrawList, bb_inner.Min, bb_inner.Max, GetColorU32(col_source), grid_step, ImVec2(off, off), rounding);</span>
        else
<span style = "background-color:#fdd">            window-&gt;DrawList-&gt;AddRectFilled(bb_inner.Min, bb_inner.Max, GetColorU32(col_source), rounding);</span>
    }
<span style = "background-color:#fdd">    RenderNavHighlight(bb, id);
    if ((flags &amp; ImGuiColorEditFlags_NoBorder) == 0)</span>
    {
<span style = "background-color:#fdd">        if (g.Style.FrameBorderSize &gt; 0.0f)
            RenderFrameBorder(bb.Min, bb.Max, rounding);</span>
        else
<span style = "background-color:#fdd">            window-&gt;DrawList-&gt;AddRect(bb.Min, bb.Max, GetColorU32(ImGuiCol_FrameBg), rounding); // Color button are often in need of some sort of border</span>
    }

    // Drag and Drop Source
    // NB: The ActiveId test is merely an optional micro-optimization, BeginDragDropSource() does the same test.
<span style = "background-color:#fdd">    if (g.ActiveId == id &amp;&amp; !(flags &amp; ImGuiColorEditFlags_NoDragDrop) &amp;&amp; BeginDragDropSource())</span>
    {
<span style = "background-color:#fdd">        if (flags &amp; ImGuiColorEditFlags_NoAlpha)
            SetDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_3F, &amp;col_rgb, sizeof(float) * 3, ImGuiCond_Once);</span>
        else
<span style = "background-color:#fdd">            SetDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_4F, &amp;col_rgb, sizeof(float) * 4, ImGuiCond_Once);
        ColorButton(desc_id, col, flags);
        SameLine();
        TextEx("Color");
        EndDragDropSource();</span>
    }

    // Tooltip
<span style = "background-color:#fdd">    if (!(flags &amp; ImGuiColorEditFlags_NoTooltip) &amp;&amp; hovered)
        ColorTooltip(desc_id, &amp;col.x, flags &amp; (ImGuiColorEditFlags_InputMask_ | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf));</span>

<span style = "background-color:#fdd">    return pressed;
}</span>

// Initialize/override default color options
void ImGui::SetColorEditOptions(ImGuiColorEditFlags flags)
<span style = "background-color:#fdd">{
    ImGuiContext&amp; g = *GImGui;
    if ((flags &amp; ImGuiColorEditFlags_DisplayMask_) == 0)
        flags |= ImGuiColorEditFlags_DefaultOptions_ &amp; ImGuiColorEditFlags_DisplayMask_;
    if ((flags &amp; ImGuiColorEditFlags_DataTypeMask_) == 0)
        flags |= ImGuiColorEditFlags_DefaultOptions_ &amp; ImGuiColorEditFlags_DataTypeMask_;
    if ((flags &amp; ImGuiColorEditFlags_PickerMask_) == 0)
        flags |= ImGuiColorEditFlags_DefaultOptions_ &amp; ImGuiColorEditFlags_PickerMask_;
    if ((flags &amp; ImGuiColorEditFlags_InputMask_) == 0)
        flags |= ImGuiColorEditFlags_DefaultOptions_ &amp; ImGuiColorEditFlags_InputMask_;
    IM_ASSERT(ImIsPowerOfTwo(flags &amp; ImGuiColorEditFlags_DisplayMask_));    // Check only 1 option is selected
    IM_ASSERT(ImIsPowerOfTwo(flags &amp; ImGuiColorEditFlags_DataTypeMask_));   // Check only 1 option is selected
    IM_ASSERT(ImIsPowerOfTwo(flags &amp; ImGuiColorEditFlags_PickerMask_));     // Check only 1 option is selected
    IM_ASSERT(ImIsPowerOfTwo(flags &amp; ImGuiColorEditFlags_InputMask_));      // Check only 1 option is selected
    g.ColorEditOptions = flags;
}</span>

// Note: only access 3 floats if ImGuiColorEditFlags_NoAlpha flag is set.
void ImGui::ColorTooltip(const char* text, const float* col, ImGuiColorEditFlags flags)
<span style = "background-color:#fdd">{
    ImGuiContext&amp; g = *GImGui;</span>

<span style = "background-color:#fdd">    BeginTooltipEx(0, ImGuiTooltipFlags_OverridePreviousTooltip);
    const char* text_end = text ? FindRenderedTextEnd(text, NULL) : text;
    if (text_end &gt; text)</span>
    {
<span style = "background-color:#fdd">        TextEx(text, text_end);
        Separator();</span>
    }

<span style = "background-color:#fdd">    ImVec2 sz(g.FontSize * 3 + g.Style.FramePadding.y * 2, g.FontSize * 3 + g.Style.FramePadding.y * 2);
    ImVec4 cf(col[0], col[1], col[2], (flags &amp; ImGuiColorEditFlags_NoAlpha) ? 1.0f : col[3]);
    int cr = IM_F32_TO_INT8_SAT(col[0]), cg = IM_F32_TO_INT8_SAT(col[1]), cb = IM_F32_TO_INT8_SAT(col[2]), ca = (flags &amp; ImGuiColorEditFlags_NoAlpha) ? 255 : IM_F32_TO_INT8_SAT(col[3]);
    ColorButton("##preview", cf, (flags &amp; (ImGuiColorEditFlags_InputMask_ | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf)) | ImGuiColorEditFlags_NoTooltip, sz);
    SameLine();
    if ((flags &amp; ImGuiColorEditFlags_InputRGB) || !(flags &amp; ImGuiColorEditFlags_InputMask_))</span>
    {
<span style = "background-color:#fdd">        if (flags &amp; ImGuiColorEditFlags_NoAlpha)
            Text("#%02X%02X%02X\nR: %d, G: %d, B: %d\n(%.3f, %.3f, %.3f)", cr, cg, cb, cr, cg, cb, col[0], col[1], col[2]);</span>
        else
<span style = "background-color:#fdd">            Text("#%02X%02X%02X%02X\nR:%d, G:%d, B:%d, A:%d\n(%.3f, %.3f, %.3f, %.3f)", cr, cg, cb, ca, cr, cg, cb, ca, col[0], col[1], col[2], col[3]);
    }
    else if (flags &amp; ImGuiColorEditFlags_InputHSV)</span>
    {
<span style = "background-color:#fdd">        if (flags &amp; ImGuiColorEditFlags_NoAlpha)
            Text("H: %.3f, S: %.3f, V: %.3f", col[0], col[1], col[2]);</span>
        else
<span style = "background-color:#fdd">            Text("H: %.3f, S: %.3f, V: %.3f, A: %.3f", col[0], col[1], col[2], col[3]);</span>
    }
<span style = "background-color:#fdd">    EndTooltip();
}</span>

void ImGui::ColorEditOptionsPopup(const float* col, ImGuiColorEditFlags flags)
<span style = "background-color:#fdd">{
    bool allow_opt_inputs = !(flags &amp; ImGuiColorEditFlags_DisplayMask_);
    bool allow_opt_datatype = !(flags &amp; ImGuiColorEditFlags_DataTypeMask_);
    if ((!allow_opt_inputs &amp;&amp; !allow_opt_datatype) || !BeginPopup("context"))
        return;
    ImGuiContext&amp; g = *GImGui;
    ImGuiColorEditFlags opts = g.ColorEditOptions;
    if (allow_opt_inputs)</span>
    {
<span style = "background-color:#fdd">        if (RadioButton("RGB", (opts &amp; ImGuiColorEditFlags_DisplayRGB) != 0)) opts = (opts &amp; ~ImGuiColorEditFlags_DisplayMask_) | ImGuiColorEditFlags_DisplayRGB;
        if (RadioButton("HSV", (opts &amp; ImGuiColorEditFlags_DisplayHSV) != 0)) opts = (opts &amp; ~ImGuiColorEditFlags_DisplayMask_) | ImGuiColorEditFlags_DisplayHSV;
        if (RadioButton("Hex", (opts &amp; ImGuiColorEditFlags_DisplayHex) != 0)) opts = (opts &amp; ~ImGuiColorEditFlags_DisplayMask_) | ImGuiColorEditFlags_DisplayHex;</span>
    }
<span style = "background-color:#fdd">    if (allow_opt_datatype)</span>
    {
<span style = "background-color:#fdd">        if (allow_opt_inputs) Separator();
        if (RadioButton("0..255",     (opts &amp; ImGuiColorEditFlags_Uint8) != 0)) opts = (opts &amp; ~ImGuiColorEditFlags_DataTypeMask_) | ImGuiColorEditFlags_Uint8;
        if (RadioButton("0.00..1.00", (opts &amp; ImGuiColorEditFlags_Float) != 0)) opts = (opts &amp; ~ImGuiColorEditFlags_DataTypeMask_) | ImGuiColorEditFlags_Float;</span>
    }

<span style = "background-color:#fdd">    if (allow_opt_inputs || allow_opt_datatype)
        Separator();
    if (Button("Copy as..", ImVec2(-1, 0)))
        OpenPopup("Copy");
    if (BeginPopup("Copy"))</span>
    {
<span style = "background-color:#fdd">        int cr = IM_F32_TO_INT8_SAT(col[0]), cg = IM_F32_TO_INT8_SAT(col[1]), cb = IM_F32_TO_INT8_SAT(col[2]), ca = (flags &amp; ImGuiColorEditFlags_NoAlpha) ? 255 : IM_F32_TO_INT8_SAT(col[3]);</span>
        char buf[64];
<span style = "background-color:#fdd">        ImFormatString(buf, IM_ARRAYSIZE(buf), "(%.3ff, %.3ff, %.3ff, %.3ff)", col[0], col[1], col[2], (flags &amp; ImGuiColorEditFlags_NoAlpha) ? 1.0f : col[3]);
        if (Selectable(buf))
            SetClipboardText(buf);
        ImFormatString(buf, IM_ARRAYSIZE(buf), "(%d,%d,%d,%d)", cr, cg, cb, ca);
        if (Selectable(buf))
            SetClipboardText(buf);
        ImFormatString(buf, IM_ARRAYSIZE(buf), "#%02X%02X%02X", cr, cg, cb);
        if (Selectable(buf))
            SetClipboardText(buf);
        if (!(flags &amp; ImGuiColorEditFlags_NoAlpha))</span>
        {
<span style = "background-color:#fdd">            ImFormatString(buf, IM_ARRAYSIZE(buf), "#%02X%02X%02X%02X", cr, cg, cb, ca);
            if (Selectable(buf))
                SetClipboardText(buf);</span>
        }
<span style = "background-color:#fdd">        EndPopup();</span>
    }

<span style = "background-color:#fdd">    g.ColorEditOptions = opts;
    EndPopup();
}</span>

void ImGui::ColorPickerOptionsPopup(const float* ref_col, ImGuiColorEditFlags flags)
<span style = "background-color:#fdd">{
    bool allow_opt_picker = !(flags &amp; ImGuiColorEditFlags_PickerMask_);
    bool allow_opt_alpha_bar = !(flags &amp; ImGuiColorEditFlags_NoAlpha) &amp;&amp; !(flags &amp; ImGuiColorEditFlags_AlphaBar);
    if ((!allow_opt_picker &amp;&amp; !allow_opt_alpha_bar) || !BeginPopup("context"))
        return;
    ImGuiContext&amp; g = *GImGui;
    if (allow_opt_picker)</span>
    {
<span style = "background-color:#fdd">        ImVec2 picker_size(g.FontSize * 8, ImMax(g.FontSize * 8 - (GetFrameHeight() + g.Style.ItemInnerSpacing.x), 1.0f)); // FIXME: Picker size copied from main picker function
        PushItemWidth(picker_size.x);
        for (int picker_type = 0; picker_type &lt; 2; picker_type++)</span>
        {
            // Draw small/thumbnail version of each picker type (over an invisible button for selection)
<span style = "background-color:#fdd">            if (picker_type &gt; 0) Separator();
            PushID(picker_type);
            ImGuiColorEditFlags picker_flags = ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoOptions | ImGuiColorEditFlags_NoLabel | ImGuiColorEditFlags_NoSidePreview | (flags &amp; ImGuiColorEditFlags_NoAlpha);
            if (picker_type == 0) picker_flags |= ImGuiColorEditFlags_PickerHueBar;
            if (picker_type == 1) picker_flags |= ImGuiColorEditFlags_PickerHueWheel;
            ImVec2 backup_pos = GetCursorScreenPos();
            if (Selectable("##selectable", false, 0, picker_size)) // By default, Selectable() is closing popup
                g.ColorEditOptions = (g.ColorEditOptions &amp; ~ImGuiColorEditFlags_PickerMask_) | (picker_flags &amp; ImGuiColorEditFlags_PickerMask_);
            SetCursorScreenPos(backup_pos);
            ImVec4 previewing_ref_col;
            memcpy(&amp;previewing_ref_col, ref_col, sizeof(float) * ((picker_flags &amp; ImGuiColorEditFlags_NoAlpha) ? 3 : 4));
            ColorPicker4("##previewing_picker", &amp;previewing_ref_col.x, picker_flags);
            PopID();
        }
        PopItemWidth();</span>
    }
<span style = "background-color:#fdd">    if (allow_opt_alpha_bar)</span>
    {
<span style = "background-color:#fdd">        if (allow_opt_picker) Separator();
        CheckboxFlags("Alpha Bar", &amp;g.ColorEditOptions, ImGuiColorEditFlags_AlphaBar);</span>
    }
<span style = "background-color:#fdd">    EndPopup();
}</span>

//-------------------------------------------------------------------------
// [SECTION] Widgets: TreeNode, CollapsingHeader, etc.
//-------------------------------------------------------------------------
// - TreeNode()
// - TreeNodeV()
// - TreeNodeEx()
// - TreeNodeExV()
// - TreeNodeBehavior() [Internal]
// - TreePush()
// - TreePop()
// - GetTreeNodeToLabelSpacing()
// - SetNextItemOpen()
// - CollapsingHeader()
//-------------------------------------------------------------------------

bool ImGui::TreeNode(const char* str_id, const char* fmt, ...)
<span style = "background-color:#fdd">{</span>
    va_list args;
<span style = "background-color:#fdd">    va_start(args, fmt);
    bool is_open = TreeNodeExV(str_id, 0, fmt, args);
    va_end(args);
    return is_open;
}</span>

bool ImGui::TreeNode(const void* ptr_id, const char* fmt, ...)
<span style = "background-color:#fdd">{</span>
    va_list args;
<span style = "background-color:#fdd">    va_start(args, fmt);
    bool is_open = TreeNodeExV(ptr_id, 0, fmt, args);
    va_end(args);
    return is_open;
}</span>

bool ImGui::TreeNode(const char* label)
<span style = "background-color:#fdd">{
    ImGuiWindow* window = GetCurrentWindow();
    if (window-&gt;SkipItems)
        return false;
    return TreeNodeBehavior(window-&gt;GetID(label), 0, label, NULL);
}</span>

bool ImGui::TreeNodeV(const char* str_id, const char* fmt, va_list args)
<span style = "background-color:#fdd">{
    return TreeNodeExV(str_id, 0, fmt, args);
}</span>

bool ImGui::TreeNodeV(const void* ptr_id, const char* fmt, va_list args)
<span style = "background-color:#fdd">{
    return TreeNodeExV(ptr_id, 0, fmt, args);
}</span>

bool ImGui::TreeNodeEx(const char* label, ImGuiTreeNodeFlags flags)
<span style = "background-color:#fdd">{
    ImGuiWindow* window = GetCurrentWindow();
    if (window-&gt;SkipItems)
        return false;</span>

<span style = "background-color:#fdd">    return TreeNodeBehavior(window-&gt;GetID(label), flags, label, NULL);
}</span>

bool ImGui::TreeNodeEx(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, ...)
<span style = "background-color:#fdd">{</span>
    va_list args;
<span style = "background-color:#fdd">    va_start(args, fmt);
    bool is_open = TreeNodeExV(str_id, flags, fmt, args);
    va_end(args);
    return is_open;
}</span>

bool ImGui::TreeNodeEx(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, ...)
<span style = "background-color:#fdd">{</span>
    va_list args;
<span style = "background-color:#fdd">    va_start(args, fmt);
    bool is_open = TreeNodeExV(ptr_id, flags, fmt, args);
    va_end(args);
    return is_open;
}</span>

bool ImGui::TreeNodeExV(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args)
<span style = "background-color:#fdd">{
    ImGuiWindow* window = GetCurrentWindow();
    if (window-&gt;SkipItems)
        return false;</span>

<span style = "background-color:#fdd">    ImGuiContext&amp; g = *GImGui;
    const char* label_end = g.TempBuffer + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);
    return TreeNodeBehavior(window-&gt;GetID(str_id), flags, g.TempBuffer, label_end);
}</span>

bool ImGui::TreeNodeExV(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args)
<span style = "background-color:#fdd">{
    ImGuiWindow* window = GetCurrentWindow();
    if (window-&gt;SkipItems)
        return false;</span>

<span style = "background-color:#fdd">    ImGuiContext&amp; g = *GImGui;
    const char* label_end = g.TempBuffer + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);
    return TreeNodeBehavior(window-&gt;GetID(ptr_id), flags, g.TempBuffer, label_end);
}</span>

bool ImGui::TreeNodeBehaviorIsOpen(ImGuiID id, ImGuiTreeNodeFlags flags)
<span style = "background-color:#fdd">{
    if (flags &amp; ImGuiTreeNodeFlags_Leaf)
        return true;</span>

    // We only write to the tree storage if the user clicks (or explicitly use the SetNextItemOpen function)
<span style = "background-color:#fdd">    ImGuiContext&amp; g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    ImGuiStorage* storage = window-&gt;DC.StateStorage;</span>

    bool is_open;
<span style = "background-color:#fdd">    if (g.NextItemData.Flags &amp; ImGuiNextItemDataFlags_HasOpen)</span>
    {
<span style = "background-color:#fdd">        if (g.NextItemData.OpenCond &amp; ImGuiCond_Always)</span>
        {
<span style = "background-color:#fdd">            is_open = g.NextItemData.OpenVal;
            storage-&gt;SetInt(id, is_open);
        }</span>
        else
        {
            // We treat ImGuiCond_Once and ImGuiCond_FirstUseEver the same because tree node state are not saved persistently.
<span style = "background-color:#fdd">            const int stored_value = storage-&gt;GetInt(id, -1);
            if (stored_value == -1)</span>
            {
<span style = "background-color:#fdd">                is_open = g.NextItemData.OpenVal;
                storage-&gt;SetInt(id, is_open);
            }</span>
            else
            {
<span style = "background-color:#fdd">                is_open = stored_value != 0;</span>
            }
        }
<span style = "background-color:#fdd">    }</span>
    else
    {
<span style = "background-color:#fdd">        is_open = storage-&gt;GetInt(id, (flags &amp; ImGuiTreeNodeFlags_DefaultOpen) ? 1 : 0) != 0;</span>
    }

    // When logging is enabled, we automatically expand tree nodes (but *NOT* collapsing headers.. seems like sensible behavior).
    // NB- If we are above max depth we still allow manually opened nodes to be logged.
<span style = "background-color:#fdd">    if (g.LogEnabled &amp;&amp; !(flags &amp; ImGuiTreeNodeFlags_NoAutoOpenOnLog) &amp;&amp; (window-&gt;DC.TreeDepth - g.LogDepthRef) &lt; g.LogDepthToExpand)
        is_open = true;</span>

<span style = "background-color:#fdd">    return is_open;
}</span>

bool ImGui::TreeNodeBehavior(ImGuiID id, ImGuiTreeNodeFlags flags, const char* label, const char* label_end)
<span style = "background-color:#fdd">{
    ImGuiWindow* window = GetCurrentWindow();
    if (window-&gt;SkipItems)
        return false;</span>

<span style = "background-color:#fdd">    ImGuiContext&amp; g = *GImGui;
    const ImGuiStyle&amp; style = g.Style;
    const bool display_frame = (flags &amp; ImGuiTreeNodeFlags_Framed) != 0;
    const ImVec2 padding = (display_frame || (flags &amp; ImGuiTreeNodeFlags_FramePadding)) ? style.FramePadding : ImVec2(style.FramePadding.x, ImMin(window-&gt;DC.CurrLineTextBaseOffset, style.FramePadding.y));</span>

<span style = "background-color:#fdd">    if (!label_end)
        label_end = FindRenderedTextEnd(label);
    const ImVec2 label_size = CalcTextSize(label, label_end, false);</span>

    // We vertically grow up to current line height up the typical widget height.
<span style = "background-color:#fdd">    const float frame_height = ImMax(ImMin(window-&gt;DC.CurrLineSize.y, g.FontSize + style.FramePadding.y * 2), label_size.y + padding.y * 2);
    ImRect frame_bb;
    frame_bb.Min.x = (flags &amp; ImGuiTreeNodeFlags_SpanFullWidth) ? window-&gt;WorkRect.Min.x : window-&gt;DC.CursorPos.x;
    frame_bb.Min.y = window-&gt;DC.CursorPos.y;
    frame_bb.Max.x = window-&gt;WorkRect.Max.x;
    frame_bb.Max.y = window-&gt;DC.CursorPos.y + frame_height;
    if (display_frame)</span>
    {
        // Framed header expand a little outside the default padding, to the edge of InnerClipRect
        // (FIXME: May remove this at some point and make InnerClipRect align with WindowPadding.x instead of WindowPadding.x*0.5f)
<span style = "background-color:#fdd">        frame_bb.Min.x -= IM_FLOOR(window-&gt;WindowPadding.x * 0.5f - 1.0f);
        frame_bb.Max.x += IM_FLOOR(window-&gt;WindowPadding.x * 0.5f);</span>
    }

<span style = "background-color:#fdd">    const float text_offset_x = g.FontSize + (display_frame ? padding.x * 3 : padding.x * 2);           // Collapser arrow width + Spacing
    const float text_offset_y = ImMax(padding.y, window-&gt;DC.CurrLineTextBaseOffset);                    // Latch before ItemSize changes it
    const float text_width = g.FontSize + (label_size.x &gt; 0.0f ? label_size.x + padding.x * 2 : 0.0f);  // Include collapser
    ImVec2 text_pos(window-&gt;DC.CursorPos.x + text_offset_x, window-&gt;DC.CursorPos.y + text_offset_y);
    ItemSize(ImVec2(text_width, frame_height), padding.y);</span>

    // For regular tree nodes, we arbitrary allow to click past 2 worth of ItemSpacing
<span style = "background-color:#fdd">    ImRect interact_bb = frame_bb;
    if (!display_frame &amp;&amp; (flags &amp; (ImGuiTreeNodeFlags_SpanAvailWidth | ImGuiTreeNodeFlags_SpanFullWidth)) == 0)
        interact_bb.Max.x = frame_bb.Min.x + text_width + style.ItemSpacing.x * 2.0f;</span>

    // Store a flag for the current depth to tell if we will allow closing this node when navigating one of its child.
    // For this purpose we essentially compare if g.NavIdIsAlive went from 0 to 1 between TreeNode() and TreePop().
    // This is currently only support 32 level deep and we are fine with (1 &lt;&lt; Depth) overflowing into a zero.
<span style = "background-color:#fdd">    const bool is_leaf = (flags &amp; ImGuiTreeNodeFlags_Leaf) != 0;
    bool is_open = TreeNodeBehaviorIsOpen(id, flags);
    if (is_open &amp;&amp; !g.NavIdIsAlive &amp;&amp; (flags &amp; ImGuiTreeNodeFlags_NavLeftJumpsBackHere) &amp;&amp; !(flags &amp; ImGuiTreeNodeFlags_NoTreePushOnOpen))
        window-&gt;DC.TreeJumpToParentOnPopMask |= (1 &lt;&lt; window-&gt;DC.TreeDepth);</span>

<span style = "background-color:#fdd">    bool item_add = ItemAdd(interact_bb, id);
    g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HasDisplayRect;
    g.LastItemData.DisplayRect = frame_bb;</span>

<span style = "background-color:#fdd">    if (!item_add)</span>
    {
<span style = "background-color:#fdd">        if (is_open &amp;&amp; !(flags &amp; ImGuiTreeNodeFlags_NoTreePushOnOpen))
            TreePushOverrideID(id);</span>
        IMGUI_TEST_ENGINE_ITEM_INFO(g.LastItemData.ID, label, g.LastItemData.StatusFlags | (is_leaf ? 0 : ImGuiItemStatusFlags_Openable) | (is_open ? ImGuiItemStatusFlags_Opened : 0));
<span style = "background-color:#fdd">        return is_open;</span>
    }

<span style = "background-color:#fdd">    ImGuiButtonFlags button_flags = ImGuiTreeNodeFlags_None;
    if (flags &amp; ImGuiTreeNodeFlags_AllowItemOverlap)
        button_flags |= ImGuiButtonFlags_AllowItemOverlap;
    if (!is_leaf)
        button_flags |= ImGuiButtonFlags_PressedOnDragDropHold;</span>

    // We allow clicking on the arrow section with keyboard modifiers held, in order to easily
    // allow browsing a tree while preserving selection with code implementing multi-selection patterns.
    // When clicking on the rest of the tree node we always disallow keyboard modifiers.
<span style = "background-color:#fdd">    const float arrow_hit_x1 = (text_pos.x - text_offset_x) - style.TouchExtraPadding.x;
    const float arrow_hit_x2 = (text_pos.x - text_offset_x) + (g.FontSize + padding.x * 2.0f) + style.TouchExtraPadding.x;
    const bool is_mouse_x_over_arrow = (g.IO.MousePos.x &gt;= arrow_hit_x1 &amp;&amp; g.IO.MousePos.x &lt; arrow_hit_x2);
    if (window != g.HoveredWindow || !is_mouse_x_over_arrow)
        button_flags |= ImGuiButtonFlags_NoKeyModifiers;</span>

    // Open behaviors can be altered with the _OpenOnArrow and _OnOnDoubleClick flags.
    // Some alteration have subtle effects (e.g. toggle on MouseUp vs MouseDown events) due to requirements for multi-selection and drag and drop support.
    // - Single-click on label = Toggle on MouseUp (default, when _OpenOnArrow=0)
    // - Single-click on arrow = Toggle on MouseDown (when _OpenOnArrow=0)
    // - Single-click on arrow = Toggle on MouseDown (when _OpenOnArrow=1)
    // - Double-click on label = Toggle on MouseDoubleClick (when _OpenOnDoubleClick=1)
    // - Double-click on arrow = Toggle on MouseDoubleClick (when _OpenOnDoubleClick=1 and _OpenOnArrow=0)
    // It is rather standard that arrow click react on Down rather than Up.
    // We set ImGuiButtonFlags_PressedOnClickRelease on OpenOnDoubleClick because we want the item to be active on the initial MouseDown in order for drag and drop to work.
<span style = "background-color:#fdd">    if (is_mouse_x_over_arrow)
        button_flags |= ImGuiButtonFlags_PressedOnClick;
    else if (flags &amp; ImGuiTreeNodeFlags_OpenOnDoubleClick)
        button_flags |= ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnDoubleClick;</span>
    else
<span style = "background-color:#fdd">        button_flags |= ImGuiButtonFlags_PressedOnClickRelease;</span>

<span style = "background-color:#fdd">    bool selected = (flags &amp; ImGuiTreeNodeFlags_Selected) != 0;
    const bool was_selected = selected;</span>

    bool hovered, held;
<span style = "background-color:#fdd">    bool pressed = ButtonBehavior(interact_bb, id, &amp;hovered, &amp;held, button_flags);
    bool toggled = false;
    if (!is_leaf)</span>
    {
<span style = "background-color:#fdd">        if (pressed &amp;&amp; g.DragDropHoldJustPressedId != id)</span>
        {
<span style = "background-color:#fdd">            if ((flags &amp; (ImGuiTreeNodeFlags_OpenOnArrow | ImGuiTreeNodeFlags_OpenOnDoubleClick)) == 0 || (g.NavActivateId == id))
                toggled = true;
            if (flags &amp; ImGuiTreeNodeFlags_OpenOnArrow)
                toggled |= is_mouse_x_over_arrow &amp;&amp; !g.NavDisableMouseHover; // Lightweight equivalent of IsMouseHoveringRect() since ButtonBehavior() already did the job
            if ((flags &amp; ImGuiTreeNodeFlags_OpenOnDoubleClick) &amp;&amp; g.IO.MouseClickedCount[0] == 2)
                toggled = true;
        }
        else if (pressed &amp;&amp; g.DragDropHoldJustPressedId == id)</span>
        {
<span style = "background-color:#fdd">            IM_ASSERT(button_flags &amp; ImGuiButtonFlags_PressedOnDragDropHold);
            if (!is_open) // When using Drag and Drop "hold to open" we keep the node highlighted after opening, but never close it again.
                toggled = true;</span>
        }

<span style = "background-color:#fdd">        if (g.NavId == id &amp;&amp; g.NavMoveDir == ImGuiDir_Left &amp;&amp; is_open)</span>
        {
<span style = "background-color:#fdd">            toggled = true;
            NavMoveRequestCancel();</span>
        }
<span style = "background-color:#fdd">        if (g.NavId == id &amp;&amp; g.NavMoveDir == ImGuiDir_Right &amp;&amp; !is_open) // If there's something upcoming on the line we may want to give it the priority?</span>
        {
<span style = "background-color:#fdd">            toggled = true;
            NavMoveRequestCancel();</span>
        }

<span style = "background-color:#fdd">        if (toggled)</span>
        {
<span style = "background-color:#fdd">            is_open = !is_open;
            window-&gt;DC.StateStorage-&gt;SetInt(id, is_open);
            g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_ToggledOpen;</span>
        }
    }
<span style = "background-color:#fdd">    if (flags &amp; ImGuiTreeNodeFlags_AllowItemOverlap)
        SetItemAllowOverlap();</span>

    // In this branch, TreeNodeBehavior() cannot toggle the selection so this will never trigger.
<span style = "background-color:#fdd">    if (selected != was_selected) //-V547
        g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_ToggledSelection;</span>

    // Render
<span style = "background-color:#fdd">    const ImU32 text_col = GetColorU32(ImGuiCol_Text);
    ImGuiNavHighlightFlags nav_highlight_flags = ImGuiNavHighlightFlags_TypeThin;
    if (display_frame)</span>
    {
        // Framed type
<span style = "background-color:#fdd">        const ImU32 bg_col = GetColorU32((held &amp;&amp; hovered) ? ImGuiCol_HeaderActive : hovered ? ImGuiCol_HeaderHovered : ImGuiCol_Header);
        RenderFrame(frame_bb.Min, frame_bb.Max, bg_col, true, style.FrameRounding);
        RenderNavHighlight(frame_bb, id, nav_highlight_flags);
        if (flags &amp; ImGuiTreeNodeFlags_Bullet)
            RenderBullet(window-&gt;DrawList, ImVec2(text_pos.x - text_offset_x * 0.60f, text_pos.y + g.FontSize * 0.5f), text_col);
        else if (!is_leaf)
            RenderArrow(window-&gt;DrawList, ImVec2(text_pos.x - text_offset_x + padding.x, text_pos.y), text_col, is_open ? ImGuiDir_Down : ImGuiDir_Right, 1.0f);</span>
        else // Leaf without bullet, left-adjusted text
<span style = "background-color:#fdd">            text_pos.x -= text_offset_x;
        if (flags &amp; ImGuiTreeNodeFlags_ClipLabelForTrailingButton)
            frame_bb.Max.x -= g.FontSize + style.FramePadding.x;</span>

<span style = "background-color:#fdd">        if (g.LogEnabled)
            LogSetNextTextDecoration("###", "###");
        RenderTextClipped(text_pos, frame_bb.Max, label, label_end, &amp;label_size);
    }</span>
    else
    {
        // Unframed typed for tree nodes
<span style = "background-color:#fdd">        if (hovered || selected)</span>
        {
<span style = "background-color:#fdd">            const ImU32 bg_col = GetColorU32((held &amp;&amp; hovered) ? ImGuiCol_HeaderActive : hovered ? ImGuiCol_HeaderHovered : ImGuiCol_Header);
            RenderFrame(frame_bb.Min, frame_bb.Max, bg_col, false);</span>
        }
<span style = "background-color:#fdd">        RenderNavHighlight(frame_bb, id, nav_highlight_flags);
        if (flags &amp; ImGuiTreeNodeFlags_Bullet)
            RenderBullet(window-&gt;DrawList, ImVec2(text_pos.x - text_offset_x * 0.5f, text_pos.y + g.FontSize * 0.5f), text_col);
        else if (!is_leaf)
            RenderArrow(window-&gt;DrawList, ImVec2(text_pos.x - text_offset_x + padding.x, text_pos.y + g.FontSize * 0.15f), text_col, is_open ? ImGuiDir_Down : ImGuiDir_Right, 0.70f);
        if (g.LogEnabled)
            LogSetNextTextDecoration("&gt;", NULL);
        RenderText(text_pos, label, label_end, false);</span>
    }

<span style = "background-color:#fdd">    if (is_open &amp;&amp; !(flags &amp; ImGuiTreeNodeFlags_NoTreePushOnOpen))
        TreePushOverrideID(id);</span>
    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags | (is_leaf ? 0 : ImGuiItemStatusFlags_Openable) | (is_open ? ImGuiItemStatusFlags_Opened : 0));
<span style = "background-color:#fdd">    return is_open;
}</span>

void ImGui::TreePush(const char* str_id)
<span style = "background-color:#fdd">{
    ImGuiWindow* window = GetCurrentWindow();
    Indent();
    window-&gt;DC.TreeDepth++;
    PushID(str_id);
}</span>

void ImGui::TreePush(const void* ptr_id)
<span style = "background-color:#fdd">{
    ImGuiWindow* window = GetCurrentWindow();
    Indent();
    window-&gt;DC.TreeDepth++;
    PushID(ptr_id);
}</span>

void ImGui::TreePushOverrideID(ImGuiID id)
<span style = "background-color:#fdd">{
    ImGuiContext&amp; g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    Indent();
    window-&gt;DC.TreeDepth++;
    PushOverrideID(id);
}</span>

void ImGui::TreePop()
<span style = "background-color:#fdd">{
    ImGuiContext&amp; g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    Unindent();</span>

<span style = "background-color:#fdd">    window-&gt;DC.TreeDepth--;
    ImU32 tree_depth_mask = (1 &lt;&lt; window-&gt;DC.TreeDepth);</span>

    // Handle Left arrow to move to parent tree node (when ImGuiTreeNodeFlags_NavLeftJumpsBackHere is enabled)
<span style = "background-color:#fdd">    if (g.NavMoveDir == ImGuiDir_Left &amp;&amp; g.NavWindow == window &amp;&amp; NavMoveRequestButNoResultYet())
        if (g.NavIdIsAlive &amp;&amp; (window-&gt;DC.TreeJumpToParentOnPopMask &amp; tree_depth_mask))</span>
        {
<span style = "background-color:#fdd">            SetNavID(window-&gt;IDStack.back(), g.NavLayer, 0, ImRect());
            NavMoveRequestCancel();</span>
        }
<span style = "background-color:#fdd">    window-&gt;DC.TreeJumpToParentOnPopMask &amp;= tree_depth_mask - 1;</span>

<span style = "background-color:#fdd">    IM_ASSERT(window-&gt;IDStack.Size &gt; 1); // There should always be 1 element in the IDStack (pushed during window creation). If this triggers you called TreePop/PopID too much.
    PopID();
}</span>

// Horizontal distance preceding label when using TreeNode() or Bullet()
float ImGui::GetTreeNodeToLabelSpacing()
<span style = "background-color:#fdd">{
    ImGuiContext&amp; g = *GImGui;
    return g.FontSize + (g.Style.FramePadding.x * 2.0f);
}</span>

// Set next TreeNode/CollapsingHeader open state.
void ImGui::SetNextItemOpen(bool is_open, ImGuiCond cond)
<span style = "background-color:#fdd">{
    ImGuiContext&amp; g = *GImGui;
    if (g.CurrentWindow-&gt;SkipItems)
        return;
    g.NextItemData.Flags |= ImGuiNextItemDataFlags_HasOpen;
    g.NextItemData.OpenVal = is_open;
    g.NextItemData.OpenCond = cond ? cond : ImGuiCond_Always;
}</span>

// CollapsingHeader returns true when opened but do not indent nor push into the ID stack (because of the ImGuiTreeNodeFlags_NoTreePushOnOpen flag).
// This is basically the same as calling TreeNodeEx(label, ImGuiTreeNodeFlags_CollapsingHeader). You can remove the _NoTreePushOnOpen flag if you want behavior closer to normal TreeNode().
bool ImGui::CollapsingHeader(const char* label, ImGuiTreeNodeFlags flags)
<span style = "background-color:#fdd">{
    ImGuiWindow* window = GetCurrentWindow();
    if (window-&gt;SkipItems)
        return false;</span>

<span style = "background-color:#fdd">    return TreeNodeBehavior(window-&gt;GetID(label), flags | ImGuiTreeNodeFlags_CollapsingHeader, label);
}</span>

// p_visible == NULL                        : regular collapsing header
// p_visible != NULL &amp;&amp; *p_visible == true  : show a small close button on the corner of the header, clicking the button will set *p_visible = false
// p_visible != NULL &amp;&amp; *p_visible == false : do not show the header at all
// Do not mistake this with the Open state of the header itself, which you can adjust with SetNextItemOpen() or ImGuiTreeNodeFlags_DefaultOpen.
bool ImGui::CollapsingHeader(const char* label, bool* p_visible, ImGuiTreeNodeFlags flags)
<span style = "background-color:#fdd">{
    ImGuiWindow* window = GetCurrentWindow();
    if (window-&gt;SkipItems)
        return false;</span>

<span style = "background-color:#fdd">    if (p_visible &amp;&amp; !*p_visible)
        return false;</span>

<span style = "background-color:#fdd">    ImGuiID id = window-&gt;GetID(label);
    flags |= ImGuiTreeNodeFlags_CollapsingHeader;
    if (p_visible)
        flags |= ImGuiTreeNodeFlags_AllowItemOverlap | ImGuiTreeNodeFlags_ClipLabelForTrailingButton;
    bool is_open = TreeNodeBehavior(id, flags, label);
    if (p_visible != NULL)</span>
    {
        // Create a small overlapping close button
        // FIXME: We can evolve this into user accessible helpers to add extra buttons on title bars, headers, etc.
        // FIXME: CloseButton can overlap into text, need find a way to clip the text somehow.
<span style = "background-color:#fdd">        ImGuiContext&amp; g = *GImGui;
        ImGuiLastItemData last_item_backup = g.LastItemData;
        float button_size = g.FontSize;
        float button_x = ImMax(g.LastItemData.Rect.Min.x, g.LastItemData.Rect.Max.x - g.Style.FramePadding.x * 2.0f - button_size);
        float button_y = g.LastItemData.Rect.Min.y;
        ImGuiID close_button_id = GetIDWithSeed("#CLOSE", NULL, id);
        if (CloseButton(close_button_id, ImVec2(button_x, button_y)))
            *p_visible = false;
        g.LastItemData = last_item_backup;</span>
    }

<span style = "background-color:#fdd">    return is_open;
}</span>

//-------------------------------------------------------------------------
// [SECTION] Widgets: Selectable
//-------------------------------------------------------------------------
// - Selectable()
//-------------------------------------------------------------------------

// Tip: pass a non-visible label (e.g. "##hello") then you can use the space to draw other text or image.
// But you need to make sure the ID is unique, e.g. enclose calls in PushID/PopID or use ##unique_id.
// With this scheme, ImGuiSelectableFlags_SpanAllColumns and ImGuiSelectableFlags_AllowItemOverlap are also frequently used flags.
// FIXME: Selectable() with (size.x == 0.0f) and (SelectableTextAlign.x &gt; 0.0f) followed by SameLine() is currently not supported.
bool ImGui::Selectable(const char* label, bool selected, ImGuiSelectableFlags flags, const ImVec2&amp; size_arg)
<span style = "background-color:#dfd">{
    ImGuiWindow* window = GetCurrentWindow();
    if (window-&gt;SkipItems)</span>
<span style = "background-color:#fdd">        return false;</span>

<span style = "background-color:#dfd">    ImGuiContext&amp; g = *GImGui;
    const ImGuiStyle&amp; style = g.Style;</span>

    // Submit label or explicit size to ItemSize(), whereas ItemAdd() will submit a larger/spanning rectangle.
<span style = "background-color:#dfd">    ImGuiID id = window-&gt;GetID(label);
    ImVec2 label_size = CalcTextSize(label, NULL, true);
    ImVec2 size(size_arg.x != 0.0f ? size_arg.x : label_size.x, size_arg.y != 0.0f ? size_arg.y : label_size.y);
    ImVec2 pos = window-&gt;DC.CursorPos;
    pos.y += window-&gt;DC.CurrLineTextBaseOffset;
    ItemSize(size, 0.0f);</span>

    // Fill horizontal space
    // We don't support (size &lt; 0.0f) in Selectable() because the ItemSpacing extension would make explicitly right-aligned sizes not visibly match other widgets.
<span style = "background-color:#dfd">    const bool span_all_columns = (flags &amp; ImGuiSelectableFlags_SpanAllColumns) != 0;
    const float min_x = span_all_columns ? window-&gt;ParentWorkRect.Min.x : pos.x;
    const float max_x = span_all_columns ? window-&gt;ParentWorkRect.Max.x : window-&gt;WorkRect.Max.x;
    if (size_arg.x == 0.0f || (flags &amp; ImGuiSelectableFlags_SpanAvailWidth))
        size.x = ImMax(label_size.x, max_x - min_x);</span>

    // Text stays at the submission position, but bounding box may be extended on both sides
<span style = "background-color:#dfd">    const ImVec2 text_min = pos;
    const ImVec2 text_max(min_x + size.x, pos.y + size.y);</span>

    // Selectables are meant to be tightly packed together with no click-gap, so we extend their box to cover spacing between selectable.
<span style = "background-color:#dfd">    ImRect bb(min_x, pos.y, text_max.x, text_max.y);
    if ((flags &amp; ImGuiSelectableFlags_NoPadWithHalfSpacing) == 0)</span>
    {
<span style = "background-color:#dfd">        const float spacing_x = span_all_columns ? 0.0f : style.ItemSpacing.x;
        const float spacing_y = style.ItemSpacing.y;
        const float spacing_L = IM_FLOOR(spacing_x * 0.50f);
        const float spacing_U = IM_FLOOR(spacing_y * 0.50f);
        bb.Min.x -= spacing_L;
        bb.Min.y -= spacing_U;
        bb.Max.x += (spacing_x - spacing_L);
        bb.Max.y += (spacing_y - spacing_U);</span>
    }
    //if (g.IO.KeyCtrl) { GetForegroundDrawList()-&gt;AddRect(bb.Min, bb.Max, IM_COL32(0, 255, 0, 255)); }

    // Modify ClipRect for the ItemAdd(), faster than doing a PushColumnsBackground/PushTableBackground for every Selectable..
<span style = "background-color:#dfd">    const float backup_clip_rect_min_x = window-&gt;ClipRect.Min.x;
    const float backup_clip_rect_max_x = window-&gt;ClipRect.Max.x;
    if (span_all_columns)</span>
    {
<span style = "background-color:#fdd">        window-&gt;ClipRect.Min.x = window-&gt;ParentWorkRect.Min.x;
        window-&gt;ClipRect.Max.x = window-&gt;ParentWorkRect.Max.x;</span>
    }

<span style = "background-color:#dfd">    const bool disabled_item = (flags &amp; ImGuiSelectableFlags_Disabled) != 0;
    const bool item_add = ItemAdd(bb, id, NULL, disabled_item ? ImGuiItemFlags_Disabled : ImGuiItemFlags_None);
    if (span_all_columns)</span>
    {
<span style = "background-color:#fdd">        window-&gt;ClipRect.Min.x = backup_clip_rect_min_x;
        window-&gt;ClipRect.Max.x = backup_clip_rect_max_x;</span>
    }

<span style = "background-color:#dfd">    if (!item_add)
        return false;</span>

<span style = "background-color:#dfd">    const bool disabled_global = (g.CurrentItemFlags &amp; ImGuiItemFlags_Disabled) != 0;
    if (disabled_item &amp;&amp; !disabled_global) // Only testing this as an optimization</span>
<span style = "background-color:#fdd">        BeginDisabled();</span>

    // FIXME: We can standardize the behavior of those two, we could also keep the fast path of override ClipRect + full push on render only,
    // which would be advantageous since most selectable are not selected.
<span style = "background-color:#dfd">    if (span_all_columns &amp;&amp; window-&gt;DC.CurrentColumns)</span>
<span style = "background-color:#fdd">        PushColumnsBackground();</span>
<span style = "background-color:#dfd">    else if (span_all_columns &amp;&amp; g.CurrentTable)</span>
<span style = "background-color:#fdd">        TablePushBackgroundChannel();</span>

    // We use NoHoldingActiveID on menus so user can click and _hold_ on a menu then drag to browse child entries
<span style = "background-color:#dfd">    ImGuiButtonFlags button_flags = 0;
    if (flags &amp; ImGuiSelectableFlags_NoHoldingActiveID) { button_flags |= ImGuiButtonFlags_NoHoldingActiveId; }
    if (flags &amp; ImGuiSelectableFlags_SelectOnClick)     { button_flags |= ImGuiButtonFlags_PressedOnClick; }
    if (flags &amp; ImGuiSelectableFlags_SelectOnRelease)   { button_flags |= ImGuiButtonFlags_PressedOnRelease; }
    if (flags &amp; ImGuiSelectableFlags_AllowDoubleClick)  { button_flags |= ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnDoubleClick; }
    if (flags &amp; ImGuiSelectableFlags_AllowItemOverlap)  { button_flags |= ImGuiButtonFlags_AllowItemOverlap; }</span>

<span style = "background-color:#dfd">    const bool was_selected = selected;</span>
    bool hovered, held;
<span style = "background-color:#dfd">    bool pressed = ButtonBehavior(bb, id, &amp;hovered, &amp;held, button_flags);</span>

    // Auto-select when moved into
    // - This will be more fully fleshed in the range-select branch
    // - This is not exposed as it won't nicely work with some user side handling of shift/control
    // - We cannot do 'if (g.NavJustMovedToId != id) { selected = false; pressed = was_selected; }' for two reasons
    //   - (1) it would require focus scope to be set, need exposing PushFocusScope() or equivalent (e.g. BeginSelection() calling PushFocusScope())
    //   - (2) usage will fail with clipped items
    //   The multi-select API aim to fix those issues, e.g. may be replaced with a BeginSelection() API.
<span style = "background-color:#dfd">    if ((flags &amp; ImGuiSelectableFlags_SelectOnNav) &amp;&amp; g.NavJustMovedToId != 0 &amp;&amp; g.NavJustMovedToFocusScopeId == window-&gt;DC.NavFocusScopeIdCurrent)</span>
<span style = "background-color:#fdd">        if (g.NavJustMovedToId == id)
            selected = pressed = true;</span>

    // Update NavId when clicking or when Hovering (this doesn't happen on most widgets), so navigation can be resumed with gamepad/keyboard
<span style = "background-color:#dfd">    if (pressed || (hovered &amp;&amp; (flags &amp; ImGuiSelectableFlags_SetNavIdOnHover)))</span>
    {
<span style = "background-color:#dfd">        if (!g.NavDisableMouseHover &amp;&amp; g.NavWindow == window &amp;&amp; g.NavLayer == window-&gt;DC.NavLayerCurrent)</span>
        {
<span style = "background-color:#dfd">            SetNavID(id, window-&gt;DC.NavLayerCurrent, window-&gt;DC.NavFocusScopeIdCurrent, WindowRectAbsToRel(window, bb)); // (bb == NavRect)
            g.NavDisableHighlight = true;</span>
        }
    }
<span style = "background-color:#dfd">    if (pressed)
        MarkItemEdited(id);</span>

<span style = "background-color:#dfd">    if (flags &amp; ImGuiSelectableFlags_AllowItemOverlap)</span>
<span style = "background-color:#fdd">        SetItemAllowOverlap();</span>

    // In this branch, Selectable() cannot toggle the selection so this will never trigger.
<span style = "background-color:#dfd">    if (selected != was_selected) //-V547</span>
<span style = "background-color:#fdd">        g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_ToggledSelection;</span>

    // Render
<span style = "background-color:#dfd">    if (held &amp;&amp; (flags &amp; ImGuiSelectableFlags_DrawHoveredWhenHeld))</span>
<span style = "background-color:#fdd">        hovered = true;</span>
<span style = "background-color:#dfd">    if (hovered || selected)</span>
    {
<span style = "background-color:#dfd">        const ImU32 col = GetColorU32((held &amp;&amp; hovered) ? ImGuiCol_HeaderActive : hovered ? ImGuiCol_HeaderHovered : ImGuiCol_Header);
        RenderFrame(bb.Min, bb.Max, col, false, 0.0f);</span>
    }
<span style = "background-color:#dfd">    RenderNavHighlight(bb, id, ImGuiNavHighlightFlags_TypeThin | ImGuiNavHighlightFlags_NoRounding);</span>

<span style = "background-color:#dfd">    if (span_all_columns &amp;&amp; window-&gt;DC.CurrentColumns)</span>
<span style = "background-color:#fdd">        PopColumnsBackground();</span>
<span style = "background-color:#dfd">    else if (span_all_columns &amp;&amp; g.CurrentTable)</span>
<span style = "background-color:#fdd">        TablePopBackgroundChannel();</span>

<span style = "background-color:#dfd">    RenderTextClipped(text_min, text_max, label, NULL, &amp;label_size, style.SelectableTextAlign, &amp;bb);</span>

    // Automatically close popups
<span style = "background-color:#dfd">    if (pressed &amp;&amp; (window-&gt;Flags &amp; ImGuiWindowFlags_Popup) &amp;&amp; !(flags &amp; ImGuiSelectableFlags_DontClosePopups) &amp;&amp; !(g.LastItemData.InFlags &amp; ImGuiItemFlags_SelectableDontClosePopup))
        CloseCurrentPopup();</span>

<span style = "background-color:#dfd">    if (disabled_item &amp;&amp; !disabled_global)</span>
<span style = "background-color:#fdd">        EndDisabled();</span>

    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags);
<span style = "background-color:#dfd">    return pressed; //-V1020
}</span>

bool ImGui::Selectable(const char* label, bool* p_selected, ImGuiSelectableFlags flags, const ImVec2&amp; size_arg)
<span style = "background-color:#fdd">{
    if (Selectable(label, *p_selected, flags, size_arg))</span>
    {
<span style = "background-color:#fdd">        *p_selected = !*p_selected;
        return true;</span>
    }
<span style = "background-color:#fdd">    return false;
}</span>

//-------------------------------------------------------------------------
// [SECTION] Widgets: ListBox
//-------------------------------------------------------------------------
// - BeginListBox()
// - EndListBox()
// - ListBox()
//-------------------------------------------------------------------------

// Tip: To have a list filling the entire window width, use size.x = -FLT_MIN and pass an non-visible label e.g. "##empty"
// Tip: If your vertical size is calculated from an item count (e.g. 10 * item_height) consider adding a fractional part to facilitate seeing scrolling boundaries (e.g. 10.25 * item_height).
bool ImGui::BeginListBox(const char* label, const ImVec2&amp; size_arg)
<span style = "background-color:#fdd">{
    ImGuiContext&amp; g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();
    if (window-&gt;SkipItems)
        return false;</span>

<span style = "background-color:#fdd">    const ImGuiStyle&amp; style = g.Style;
    const ImGuiID id = GetID(label);
    const ImVec2 label_size = CalcTextSize(label, NULL, true);</span>

    // Size default to hold ~7.25 items.
    // Fractional number of items helps seeing that we can scroll down/up without looking at scrollbar.
<span style = "background-color:#fdd">    ImVec2 size = ImFloor(CalcItemSize(size_arg, CalcItemWidth(), GetTextLineHeightWithSpacing() * 7.25f + style.FramePadding.y * 2.0f));
    ImVec2 frame_size = ImVec2(size.x, ImMax(size.y, label_size.y));
    ImRect frame_bb(window-&gt;DC.CursorPos, window-&gt;DC.CursorPos + frame_size);
    ImRect bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x &gt; 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));
    g.NextItemData.ClearFlags();</span>

<span style = "background-color:#fdd">    if (!IsRectVisible(bb.Min, bb.Max))</span>
    {
<span style = "background-color:#fdd">        ItemSize(bb.GetSize(), style.FramePadding.y);
        ItemAdd(bb, 0, &amp;frame_bb);
        return false;</span>
    }

    // FIXME-OPT: We could omit the BeginGroup() if label_size.x but would need to omit the EndGroup() as well.
<span style = "background-color:#fdd">    BeginGroup();
    if (label_size.x &gt; 0.0f)</span>
    {
<span style = "background-color:#fdd">        ImVec2 label_pos = ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y);
        RenderText(label_pos, label);
        window-&gt;DC.CursorMaxPos = ImMax(window-&gt;DC.CursorMaxPos, label_pos + label_size);</span>
    }

<span style = "background-color:#fdd">    BeginChildFrame(id, frame_bb.GetSize());
    return true;
}</span>

#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
// OBSOLETED in 1.81 (from February 2021)
bool ImGui::ListBoxHeader(const char* label, int items_count, int height_in_items)
<span style = "background-color:#fdd">{</span>
    // If height_in_items == -1, default height is maximum 7.
<span style = "background-color:#fdd">    ImGuiContext&amp; g = *GImGui;
    float height_in_items_f = (height_in_items &lt; 0 ? ImMin(items_count, 7) : height_in_items) + 0.25f;
    ImVec2 size;
    size.x = 0.0f;
    size.y = GetTextLineHeightWithSpacing() * height_in_items_f + g.Style.FramePadding.y * 2.0f;
    return BeginListBox(label, size);
}</span>
#endif

void ImGui::EndListBox()
<span style = "background-color:#fdd">{
    ImGuiContext&amp; g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    IM_ASSERT((window-&gt;Flags &amp; ImGuiWindowFlags_ChildWindow) &amp;&amp; "Mismatched BeginListBox/EndListBox calls. Did you test the return value of BeginListBox?");</span>
    IM_UNUSED(window);

<span style = "background-color:#fdd">    EndChildFrame();
    EndGroup(); // This is only required to be able to do IsItemXXX query on the whole ListBox including label
}</span>

bool ImGui::ListBox(const char* label, int* current_item, const char* const items[], int items_count, int height_items)
<span style = "background-color:#fdd">{
    const bool value_changed = ListBox(label, current_item, Items_ArrayGetter, (void*)items, items_count, height_items);
    return value_changed;
}</span>

// This is merely a helper around BeginListBox(), EndListBox().
// Considering using those directly to submit custom data or store selection differently.
bool ImGui::ListBox(const char* label, int* current_item, bool (*items_getter)(void*, int, const char**), void* data, int items_count, int height_in_items)
<span style = "background-color:#fdd">{
    ImGuiContext&amp; g = *GImGui;</span>

    // Calculate size from "height_in_items"
<span style = "background-color:#fdd">    if (height_in_items &lt; 0)
        height_in_items = ImMin(items_count, 7);
    float height_in_items_f = height_in_items + 0.25f;
    ImVec2 size(0.0f, ImFloor(GetTextLineHeightWithSpacing() * height_in_items_f + g.Style.FramePadding.y * 2.0f));</span>

<span style = "background-color:#fdd">    if (!BeginListBox(label, size))
        return false;</span>

    // Assume all items have even height (= 1 line of text). If you need items of different height,
    // you can create a custom version of ListBox() in your code without using the clipper.
<span style = "background-color:#fdd">    bool value_changed = false;
    ImGuiListClipper clipper;
    clipper.Begin(items_count, GetTextLineHeightWithSpacing()); // We know exactly our line height here so we pass it as a minor optimization, but generally you don't need to.
    while (clipper.Step())
        for (int i = clipper.DisplayStart; i &lt; clipper.DisplayEnd; i++)</span>
        {
            const char* item_text;
<span style = "background-color:#fdd">            if (!items_getter(data, i, &amp;item_text))
                item_text = "*Unknown item*";</span>

<span style = "background-color:#fdd">            PushID(i);
            const bool item_selected = (i == *current_item);
            if (Selectable(item_text, item_selected))</span>
            {
<span style = "background-color:#fdd">                *current_item = i;
                value_changed = true;</span>
            }
<span style = "background-color:#fdd">            if (item_selected)
                SetItemDefaultFocus();
            PopID();
        }
    EndListBox();</span>

<span style = "background-color:#fdd">    if (value_changed)
        MarkItemEdited(g.LastItemData.ID);</span>

<span style = "background-color:#fdd">    return value_changed;
}</span>

//-------------------------------------------------------------------------
// [SECTION] Widgets: PlotLines, PlotHistogram
//-------------------------------------------------------------------------
// - PlotEx() [Internal]
// - PlotLines()
// - PlotHistogram()
//-------------------------------------------------------------------------
// Plot/Graph widgets are not very good.
// Consider writing your own, or using a third-party one, see:
// - ImPlot https://github.com/epezent/implot
// - others https://github.com/ocornut/imgui/wiki/Useful-Extensions
//-------------------------------------------------------------------------

int ImGui::PlotEx(ImGuiPlotType plot_type, const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 frame_size)
<span style = "background-color:#fdd">{
    ImGuiContext&amp; g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();
    if (window-&gt;SkipItems)
        return -1;</span>

<span style = "background-color:#fdd">    const ImGuiStyle&amp; style = g.Style;
    const ImGuiID id = window-&gt;GetID(label);</span>

<span style = "background-color:#fdd">    const ImVec2 label_size = CalcTextSize(label, NULL, true);
    if (frame_size.x == 0.0f)
        frame_size.x = CalcItemWidth();
    if (frame_size.y == 0.0f)
        frame_size.y = label_size.y + (style.FramePadding.y * 2);</span>

<span style = "background-color:#fdd">    const ImRect frame_bb(window-&gt;DC.CursorPos, window-&gt;DC.CursorPos + frame_size);
    const ImRect inner_bb(frame_bb.Min + style.FramePadding, frame_bb.Max - style.FramePadding);
    const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x &gt; 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0));
    ItemSize(total_bb, style.FramePadding.y);
    if (!ItemAdd(total_bb, 0, &amp;frame_bb))
        return -1;
    const bool hovered = ItemHoverable(frame_bb, id);</span>

    // Determine scale from values if not specified
<span style = "background-color:#fdd">    if (scale_min == FLT_MAX || scale_max == FLT_MAX)</span>
    {
<span style = "background-color:#fdd">        float v_min = FLT_MAX;
        float v_max = -FLT_MAX;
        for (int i = 0; i &lt; values_count; i++)</span>
        {
<span style = "background-color:#fdd">            const float v = values_getter(data, i);
            if (v != v) // Ignore NaN values
                continue;
            v_min = ImMin(v_min, v);
            v_max = ImMax(v_max, v);
        }
        if (scale_min == FLT_MAX)
            scale_min = v_min;
        if (scale_max == FLT_MAX)
            scale_max = v_max;</span>
    }

<span style = "background-color:#fdd">    RenderFrame(frame_bb.Min, frame_bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);</span>

<span style = "background-color:#fdd">    const int values_count_min = (plot_type == ImGuiPlotType_Lines) ? 2 : 1;
    int idx_hovered = -1;
    if (values_count &gt;= values_count_min)</span>
    {
<span style = "background-color:#fdd">        int res_w = ImMin((int)frame_size.x, values_count) + ((plot_type == ImGuiPlotType_Lines) ? -1 : 0);
        int item_count = values_count + ((plot_type == ImGuiPlotType_Lines) ? -1 : 0);</span>

        // Tooltip on hover
<span style = "background-color:#fdd">        if (hovered &amp;&amp; inner_bb.Contains(g.IO.MousePos))</span>
        {
<span style = "background-color:#fdd">            const float t = ImClamp((g.IO.MousePos.x - inner_bb.Min.x) / (inner_bb.Max.x - inner_bb.Min.x), 0.0f, 0.9999f);
            const int v_idx = (int)(t * item_count);
            IM_ASSERT(v_idx &gt;= 0 &amp;&amp; v_idx &lt; values_count);</span>

<span style = "background-color:#fdd">            const float v0 = values_getter(data, (v_idx + values_offset) % values_count);
            const float v1 = values_getter(data, (v_idx + 1 + values_offset) % values_count);
            if (plot_type == ImGuiPlotType_Lines)
                SetTooltip("%d: %8.4g\n%d: %8.4g", v_idx, v0, v_idx + 1, v1);
            else if (plot_type == ImGuiPlotType_Histogram)
                SetTooltip("%d: %8.4g", v_idx, v0);
            idx_hovered = v_idx;</span>
        }

<span style = "background-color:#fdd">        const float t_step = 1.0f / (float)res_w;
        const float inv_scale = (scale_min == scale_max) ? 0.0f : (1.0f / (scale_max - scale_min));</span>

<span style = "background-color:#fdd">        float v0 = values_getter(data, (0 + values_offset) % values_count);
        float t0 = 0.0f;
        ImVec2 tp0 = ImVec2( t0, 1.0f - ImSaturate((v0 - scale_min) * inv_scale) );                       // Point in the normalized space of our target rectangle
        float histogram_zero_line_t = (scale_min * scale_max &lt; 0.0f) ? (1 + scale_min * inv_scale) : (scale_min &lt; 0.0f ? 0.0f : 1.0f);   // Where does the zero line stands</span>

<span style = "background-color:#fdd">        const ImU32 col_base = GetColorU32((plot_type == ImGuiPlotType_Lines) ? ImGuiCol_PlotLines : ImGuiCol_PlotHistogram);
        const ImU32 col_hovered = GetColorU32((plot_type == ImGuiPlotType_Lines) ? ImGuiCol_PlotLinesHovered : ImGuiCol_PlotHistogramHovered);</span>

<span style = "background-color:#fdd">        for (int n = 0; n &lt; res_w; n++)</span>
        {
<span style = "background-color:#fdd">            const float t1 = t0 + t_step;
            const int v1_idx = (int)(t0 * item_count + 0.5f);
            IM_ASSERT(v1_idx &gt;= 0 &amp;&amp; v1_idx &lt; values_count);
            const float v1 = values_getter(data, (v1_idx + values_offset + 1) % values_count);
            const ImVec2 tp1 = ImVec2( t1, 1.0f - ImSaturate((v1 - scale_min) * inv_scale) );</span>

            // NB: Draw calls are merged together by the DrawList system. Still, we should render our batch are lower level to save a bit of CPU.
<span style = "background-color:#fdd">            ImVec2 pos0 = ImLerp(inner_bb.Min, inner_bb.Max, tp0);
            ImVec2 pos1 = ImLerp(inner_bb.Min, inner_bb.Max, (plot_type == ImGuiPlotType_Lines) ? tp1 : ImVec2(tp1.x, histogram_zero_line_t));
            if (plot_type == ImGuiPlotType_Lines)</span>
            {
<span style = "background-color:#fdd">                window-&gt;DrawList-&gt;AddLine(pos0, pos1, idx_hovered == v1_idx ? col_hovered : col_base);
            }
            else if (plot_type == ImGuiPlotType_Histogram)</span>
            {
<span style = "background-color:#fdd">                if (pos1.x &gt;= pos0.x + 2.0f)
                    pos1.x -= 1.0f;
                window-&gt;DrawList-&gt;AddRectFilled(pos0, pos1, idx_hovered == v1_idx ? col_hovered : col_base);</span>
            }

<span style = "background-color:#fdd">            t0 = t1;
            tp0 = tp1;
        }</span>
    }

    // Text overlay
<span style = "background-color:#fdd">    if (overlay_text)
        RenderTextClipped(ImVec2(frame_bb.Min.x, frame_bb.Min.y + style.FramePadding.y), frame_bb.Max, overlay_text, NULL, NULL, ImVec2(0.5f, 0.0f));</span>

<span style = "background-color:#fdd">    if (label_size.x &gt; 0.0f)
        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, inner_bb.Min.y), label);</span>

    // Return hovered index or -1 if none are hovered.
    // This is currently not exposed in the public API because we need a larger redesign of the whole thing, but in the short-term we are making it available in PlotEx().
<span style = "background-color:#fdd">    return idx_hovered;
}</span>

struct ImGuiPlotArrayGetterData
{
    const float* Values;
    int Stride;

<span style = "background-color:#fdd">    ImGuiPlotArrayGetterData(const float* values, int stride) { Values = values; Stride = stride; }</span>
};

static float Plot_ArrayGetter(void* data, int idx)
<span style = "background-color:#fdd">{
    ImGuiPlotArrayGetterData* plot_data = (ImGuiPlotArrayGetterData*)data;
    const float v = *(const float*)(const void*)((const unsigned char*)plot_data-&gt;Values + (size_t)idx * plot_data-&gt;Stride);
    return v;
}</span>

void ImGui::PlotLines(const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride)
<span style = "background-color:#fdd">{
    ImGuiPlotArrayGetterData data(values, stride);
    PlotEx(ImGuiPlotType_Lines, label, &amp;Plot_ArrayGetter, (void*)&amp;data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);
}</span>

void ImGui::PlotLines(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)
<span style = "background-color:#fdd">{
    PlotEx(ImGuiPlotType_Lines, label, values_getter, data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);
}</span>

void ImGui::PlotHistogram(const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride)
<span style = "background-color:#fdd">{
    ImGuiPlotArrayGetterData data(values, stride);
    PlotEx(ImGuiPlotType_Histogram, label, &amp;Plot_ArrayGetter, (void*)&amp;data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);
}</span>

void ImGui::PlotHistogram(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)
<span style = "background-color:#fdd">{
    PlotEx(ImGuiPlotType_Histogram, label, values_getter, data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);
}</span>

//-------------------------------------------------------------------------
// [SECTION] Widgets: Value helpers
// Those is not very useful, legacy API.
//-------------------------------------------------------------------------
// - Value()
//-------------------------------------------------------------------------

void ImGui::Value(const char* prefix, bool b)
<span style = "background-color:#fdd">{
    Text("%s: %s", prefix, (b ? "true" : "false"));
}</span>

void ImGui::Value(const char* prefix, int v)
<span style = "background-color:#fdd">{
    Text("%s: %d", prefix, v);
}</span>

void ImGui::Value(const char* prefix, unsigned int v)
<span style = "background-color:#fdd">{
    Text("%s: %d", prefix, v);
}</span>

void ImGui::Value(const char* prefix, float v, const char* float_format)
<span style = "background-color:#fdd">{
    if (float_format)</span>
    {
        char fmt[64];
<span style = "background-color:#fdd">        ImFormatString(fmt, IM_ARRAYSIZE(fmt), "%%s: %s", float_format);
        Text(fmt, prefix, v);
    }</span>
    else
    {
<span style = "background-color:#fdd">        Text("%s: %.3f", prefix, v);</span>
    }
<span style = "background-color:#fdd">}</span>

//-------------------------------------------------------------------------
// [SECTION] MenuItem, BeginMenu, EndMenu, etc.
//-------------------------------------------------------------------------
// - ImGuiMenuColumns [Internal]
// - BeginMenuBar()
// - EndMenuBar()
// - BeginMainMenuBar()
// - EndMainMenuBar()
// - BeginMenu()
// - EndMenu()
// - MenuItemEx() [Internal]
// - MenuItem()
//-------------------------------------------------------------------------

// Helpers for internal use
void ImGuiMenuColumns::Update(float spacing, bool window_reappearing)
<span style = "background-color:#dfd">{
    if (window_reappearing)
        memset(Widths, 0, sizeof(Widths));
    Spacing = (ImU16)spacing;
    CalcNextTotalWidth(true);
    memset(Widths, 0, sizeof(Widths));
    TotalWidth = NextTotalWidth;
    NextTotalWidth = 0;
}</span>

void ImGuiMenuColumns::CalcNextTotalWidth(bool update_offsets)
<span style = "background-color:#dfd">{
    ImU16 offset = 0;
    bool want_spacing = false;
    for (int i = 0; i &lt; IM_ARRAYSIZE(Widths); i++)</span>
    {
<span style = "background-color:#dfd">        ImU16 width = Widths[i];
        if (want_spacing &amp;&amp; width &gt; 0)</span>
<span style = "background-color:#fdd">            offset += Spacing;</span>
<span style = "background-color:#dfd">        want_spacing |= (width &gt; 0);
        if (update_offsets)</span>
        {
<span style = "background-color:#dfd">            if (i == 1) { OffsetLabel = offset; }
            if (i == 2) { OffsetShortcut = offset; }
            if (i == 3) { OffsetMark = offset; }</span>
        }
<span style = "background-color:#dfd">        offset += width;
    }
    NextTotalWidth = offset;
}</span>

float ImGuiMenuColumns::DeclColumns(float w_icon, float w_label, float w_shortcut, float w_mark)
<span style = "background-color:#fdd">{
    Widths[0] = ImMax(Widths[0], (ImU16)w_icon);
    Widths[1] = ImMax(Widths[1], (ImU16)w_label);
    Widths[2] = ImMax(Widths[2], (ImU16)w_shortcut);
    Widths[3] = ImMax(Widths[3], (ImU16)w_mark);
    CalcNextTotalWidth(false);
    return (float)ImMax(TotalWidth, NextTotalWidth);
}</span>

// FIXME: Provided a rectangle perhaps e.g. a BeginMenuBarEx() could be used anywhere..
// Currently the main responsibility of this function being to setup clip-rect + horizontal layout + menu navigation layer.
// Ideally we also want this to be responsible for claiming space out of the main window scrolling rectangle, in which case ImGuiWindowFlags_MenuBar will become unnecessary.
// Then later the same system could be used for multiple menu-bars, scrollbars, side-bars.
bool ImGui::BeginMenuBar()
<span style = "background-color:#fdd">{
    ImGuiWindow* window = GetCurrentWindow();
    if (window-&gt;SkipItems)
        return false;
    if (!(window-&gt;Flags &amp; ImGuiWindowFlags_MenuBar))
        return false;</span>

<span style = "background-color:#fdd">    IM_ASSERT(!window-&gt;DC.MenuBarAppending);
    BeginGroup(); // Backup position on layer 0 // FIXME: Misleading to use a group for that backup/restore
    PushID("##menubar");</span>

    // We don't clip with current window clipping rectangle as it is already set to the area below. However we clip with window full rect.
    // We remove 1 worth of rounding to Max.x to that text in long menus and small windows don't tend to display over the lower-right rounded area, which looks particularly glitchy.
<span style = "background-color:#fdd">    ImRect bar_rect = window-&gt;MenuBarRect();
    ImRect clip_rect(IM_ROUND(bar_rect.Min.x + window-&gt;WindowBorderSize), IM_ROUND(bar_rect.Min.y + window-&gt;WindowBorderSize), IM_ROUND(ImMax(bar_rect.Min.x, bar_rect.Max.x - ImMax(window-&gt;WindowRounding, window-&gt;WindowBorderSize))), IM_ROUND(bar_rect.Max.y));
    clip_rect.ClipWith(window-&gt;OuterRectClipped);
    PushClipRect(clip_rect.Min, clip_rect.Max, false);</span>

    // We overwrite CursorMaxPos because BeginGroup sets it to CursorPos (essentially the .EmitItem hack in EndMenuBar() would need something analogous here, maybe a BeginGroupEx() with flags).
<span style = "background-color:#fdd">    window-&gt;DC.CursorPos = window-&gt;DC.CursorMaxPos = ImVec2(bar_rect.Min.x + window-&gt;DC.MenuBarOffset.x, bar_rect.Min.y + window-&gt;DC.MenuBarOffset.y);
    window-&gt;DC.LayoutType = ImGuiLayoutType_Horizontal;
    window-&gt;DC.NavLayerCurrent = ImGuiNavLayer_Menu;
    window-&gt;DC.MenuBarAppending = true;
    AlignTextToFramePadding();
    return true;
}</span>

void ImGui::EndMenuBar()
<span style = "background-color:#fdd">{
    ImGuiWindow* window = GetCurrentWindow();
    if (window-&gt;SkipItems)
        return;
    ImGuiContext&amp; g = *GImGui;</span>

    // Nav: When a move request within one of our child menu failed, capture the request to navigate among our siblings.
<span style = "background-color:#fdd">    if (NavMoveRequestButNoResultYet() &amp;&amp; (g.NavMoveDir == ImGuiDir_Left || g.NavMoveDir == ImGuiDir_Right) &amp;&amp; (g.NavWindow-&gt;Flags &amp; ImGuiWindowFlags_ChildMenu))</span>
    {
        // Try to find out if the request is for one of our child menu
<span style = "background-color:#fdd">        ImGuiWindow* nav_earliest_child = g.NavWindow;
        while (nav_earliest_child-&gt;ParentWindow &amp;&amp; (nav_earliest_child-&gt;ParentWindow-&gt;Flags &amp; ImGuiWindowFlags_ChildMenu))
            nav_earliest_child = nav_earliest_child-&gt;ParentWindow;
        if (nav_earliest_child-&gt;ParentWindow == window &amp;&amp; nav_earliest_child-&gt;DC.ParentLayoutType == ImGuiLayoutType_Horizontal &amp;&amp; (g.NavMoveFlags &amp; ImGuiNavMoveFlags_Forwarded) == 0)</span>
        {
            // To do so we claim focus back, restore NavId and then process the movement request for yet another frame.
            // This involve a one-frame delay which isn't very problematic in this situation. We could remove it by scoring in advance for multiple window (probably not worth bothering)
<span style = "background-color:#fdd">            const ImGuiNavLayer layer = ImGuiNavLayer_Menu;
            IM_ASSERT(window-&gt;DC.NavLayersActiveMaskNext &amp; (1 &lt;&lt; layer)); // Sanity check
            FocusWindow(window);
            SetNavID(window-&gt;NavLastIds[layer], layer, 0, window-&gt;NavRectRel[layer]);
            g.NavDisableHighlight = true; // Hide highlight for the current frame so we don't see the intermediary selection.
            g.NavDisableMouseHover = g.NavMousePosDirty = true;
            NavMoveRequestForward(g.NavMoveDir, g.NavMoveClipDir, g.NavMoveFlags, g.NavMoveScrollFlags); // Repeat</span>
        }
    }

    IM_MSVC_WARNING_SUPPRESS(6011); // Static Analysis false positive "warning C6011: Dereferencing NULL pointer 'window'"
<span style = "background-color:#fdd">    IM_ASSERT(window-&gt;Flags &amp; ImGuiWindowFlags_MenuBar);
    IM_ASSERT(window-&gt;DC.MenuBarAppending);
    PopClipRect();
    PopID();
    window-&gt;DC.MenuBarOffset.x = window-&gt;DC.CursorPos.x - window-&gt;Pos.x; // Save horizontal position so next append can reuse it. This is kinda equivalent to a per-layer CursorPos.
    g.GroupStack.back().EmitItem = false;
    EndGroup(); // Restore position on layer 0
    window-&gt;DC.LayoutType = ImGuiLayoutType_Vertical;
    window-&gt;DC.NavLayerCurrent = ImGuiNavLayer_Main;
    window-&gt;DC.MenuBarAppending = false;
}</span>

// Important: calling order matters!
// FIXME: Somehow overlapping with docking tech.
// FIXME: The "rect-cut" aspect of this could be formalized into a lower-level helper (rect-cut: https://halt.software/dead-simple-layouts)
bool ImGui::BeginViewportSideBar(const char* name, ImGuiViewport* viewport_p, ImGuiDir dir, float axis_size, ImGuiWindowFlags window_flags)
<span style = "background-color:#fdd">{
    IM_ASSERT(dir != ImGuiDir_None);</span>

<span style = "background-color:#fdd">    ImGuiWindow* bar_window = FindWindowByName(name);
    if (bar_window == NULL || bar_window-&gt;BeginCount == 0)</span>
    {
        // Calculate and set window size/position
<span style = "background-color:#fdd">        ImGuiViewportP* viewport = (ImGuiViewportP*)(void*)(viewport_p ? viewport_p : GetMainViewport());
        ImRect avail_rect = viewport-&gt;GetBuildWorkRect();
        ImGuiAxis axis = (dir == ImGuiDir_Up || dir == ImGuiDir_Down) ? ImGuiAxis_Y : ImGuiAxis_X;
        ImVec2 pos = avail_rect.Min;
        if (dir == ImGuiDir_Right || dir == ImGuiDir_Down)
            pos[axis] = avail_rect.Max[axis] - axis_size;
        ImVec2 size = avail_rect.GetSize();
        size[axis] = axis_size;
        SetNextWindowPos(pos);
        SetNextWindowSize(size);</span>

        // Report our size into work area (for next frame) using actual window size
<span style = "background-color:#fdd">        if (dir == ImGuiDir_Up || dir == ImGuiDir_Left)
            viewport-&gt;BuildWorkOffsetMin[axis] += axis_size;
        else if (dir == ImGuiDir_Down || dir == ImGuiDir_Right)
            viewport-&gt;BuildWorkOffsetMax[axis] -= axis_size;</span>
    }

<span style = "background-color:#fdd">    window_flags |= ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove;
    PushStyleVar(ImGuiStyleVar_WindowRounding, 0.0f);
    PushStyleVar(ImGuiStyleVar_WindowMinSize, ImVec2(0, 0)); // Lift normal size constraint
    bool is_open = Begin(name, NULL, window_flags);
    PopStyleVar(2);</span>

<span style = "background-color:#fdd">    return is_open;
}</span>

bool ImGui::BeginMainMenuBar()
<span style = "background-color:#fdd">{
    ImGuiContext&amp; g = *GImGui;
    ImGuiViewportP* viewport = (ImGuiViewportP*)(void*)GetMainViewport();</span>

    // For the main menu bar, which cannot be moved, we honor g.Style.DisplaySafeAreaPadding to ensure text can be visible on a TV set.
    // FIXME: This could be generalized as an opt-in way to clamp window-&gt;DC.CursorStartPos to avoid SafeArea?
    // FIXME: Consider removing support for safe area down the line... it's messy. Nowadays consoles have support for TV calibration in OS settings.
<span style = "background-color:#fdd">    g.NextWindowData.MenuBarOffsetMinVal = ImVec2(g.Style.DisplaySafeAreaPadding.x, ImMax(g.Style.DisplaySafeAreaPadding.y - g.Style.FramePadding.y, 0.0f));
    ImGuiWindowFlags window_flags = ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_MenuBar;
    float height = GetFrameHeight();
    bool is_open = BeginViewportSideBar("##MainMenuBar", viewport, ImGuiDir_Up, height, window_flags);
    g.NextWindowData.MenuBarOffsetMinVal = ImVec2(0.0f, 0.0f);</span>

<span style = "background-color:#fdd">    if (is_open)
        BeginMenuBar();</span>
    else
<span style = "background-color:#fdd">        End();
    return is_open;
}</span>

void ImGui::EndMainMenuBar()
<span style = "background-color:#fdd">{
    EndMenuBar();</span>

    // When the user has left the menu layer (typically: closed menus through activation of an item), we restore focus to the previous window
    // FIXME: With this strategy we won't be able to restore a NULL focus.
<span style = "background-color:#fdd">    ImGuiContext&amp; g = *GImGui;
    if (g.CurrentWindow == g.NavWindow &amp;&amp; g.NavLayer == ImGuiNavLayer_Main &amp;&amp; !g.NavAnyRequest)
        FocusTopMostWindowUnderOne(g.NavWindow, NULL);</span>

<span style = "background-color:#fdd">    End();
}</span>

bool ImGui::BeginMenuEx(const char* label, const char* icon, bool enabled)
<span style = "background-color:#fdd">{
    ImGuiWindow* window = GetCurrentWindow();
    if (window-&gt;SkipItems)
        return false;</span>

<span style = "background-color:#fdd">    ImGuiContext&amp; g = *GImGui;
    const ImGuiStyle&amp; style = g.Style;
    const ImGuiID id = window-&gt;GetID(label);
    bool menu_is_open = IsPopupOpen(id, ImGuiPopupFlags_None);</span>

    // Sub-menus are ChildWindow so that mouse can be hovering across them (otherwise top-most popup menu would steal focus and not allow hovering on parent menu)
<span style = "background-color:#fdd">    ImGuiWindowFlags flags = ImGuiWindowFlags_ChildMenu | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoNavFocus;
    if (window-&gt;Flags &amp; (ImGuiWindowFlags_Popup | ImGuiWindowFlags_ChildMenu))
        flags |= ImGuiWindowFlags_ChildWindow;</span>

    // If a menu with same the ID was already submitted, we will append to it, matching the behavior of Begin().
    // We are relying on a O(N) search - so O(N log N) over the frame - which seems like the most efficient for the expected small amount of BeginMenu() calls per frame.
    // If somehow this is ever becoming a problem we can switch to use e.g. ImGuiStorage mapping key to last frame used.
<span style = "background-color:#fdd">    if (g.MenusIdSubmittedThisFrame.contains(id))</span>
    {
<span style = "background-color:#fdd">        if (menu_is_open)
            menu_is_open = BeginPopupEx(id, flags); // menu_is_open can be 'false' when the popup is completely clipped (e.g. zero size display)</span>
        else
<span style = "background-color:#fdd">            g.NextWindowData.ClearFlags();          // we behave like Begin() and need to consume those values
        return menu_is_open;</span>
    }

    // Tag menu as used. Next time BeginMenu() with same ID is called it will append to existing menu
<span style = "background-color:#fdd">    g.MenusIdSubmittedThisFrame.push_back(id);</span>

<span style = "background-color:#fdd">    ImVec2 label_size = CalcTextSize(label, NULL, true);</span>
    bool pressed;
<span style = "background-color:#fdd">    bool menuset_is_open = !(window-&gt;Flags &amp; ImGuiWindowFlags_Popup) &amp;&amp; (g.OpenPopupStack.Size &gt; g.BeginPopupStack.Size &amp;&amp; g.OpenPopupStack[g.BeginPopupStack.Size].OpenParentId == window-&gt;IDStack.back());
    ImGuiWindow* backed_nav_window = g.NavWindow;
    if (menuset_is_open)
        g.NavWindow = window;  // Odd hack to allow hovering across menus of a same menu-set (otherwise we wouldn't be able to hover parent)</span>

    // The reference position stored in popup_pos will be used by Begin() to find a suitable position for the child menu,
    // However the final position is going to be different! It is chosen by FindBestWindowPosForPopup().
    // e.g. Menus tend to overlap each other horizontally to amplify relative Z-ordering.
<span style = "background-color:#fdd">    ImVec2 popup_pos, pos = window-&gt;DC.CursorPos;
    PushID(label);
    if (!enabled)
        BeginDisabled();
    const ImGuiMenuColumns* offsets = &amp;window-&gt;DC.MenuColumns;
    if (window-&gt;DC.LayoutType == ImGuiLayoutType_Horizontal)</span>
    {
        // Menu inside an horizontal menu bar
        // Selectable extend their highlight by half ItemSpacing in each direction.
        // For ChildMenu, the popup position will be overwritten by the call to FindBestWindowPosForPopup() in Begin()
<span style = "background-color:#fdd">        popup_pos = ImVec2(pos.x - 1.0f - IM_FLOOR(style.ItemSpacing.x * 0.5f), pos.y - style.FramePadding.y + window-&gt;MenuBarHeight());
        window-&gt;DC.CursorPos.x += IM_FLOOR(style.ItemSpacing.x * 0.5f);
        PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(style.ItemSpacing.x * 2.0f, style.ItemSpacing.y));
        float w = label_size.x;
        ImVec2 text_pos(window-&gt;DC.CursorPos.x + offsets-&gt;OffsetLabel, window-&gt;DC.CursorPos.y + window-&gt;DC.CurrLineTextBaseOffset);
        pressed = Selectable("", menu_is_open, ImGuiSelectableFlags_NoHoldingActiveID | ImGuiSelectableFlags_SelectOnClick | ImGuiSelectableFlags_DontClosePopups, ImVec2(w, 0.0f));
        RenderText(text_pos, label);
        PopStyleVar();
        window-&gt;DC.CursorPos.x += IM_FLOOR(style.ItemSpacing.x * (-1.0f + 0.5f)); // -1 spacing to compensate the spacing added when Selectable() did a SameLine(). It would also work to call SameLine() ourselves after the PopStyleVar().
    }</span>
    else
    {
        // Menu inside a regular/vertical menu
        // (In a typical menu window where all items are BeginMenu() or MenuItem() calls, extra_w will always be 0.0f.
        //  Only when they are other items sticking out we're going to add spacing, yet only register minimum width into the layout system.
<span style = "background-color:#fdd">        popup_pos = ImVec2(pos.x, pos.y - style.WindowPadding.y);
        float icon_w = (icon &amp;&amp; icon[0]) ? CalcTextSize(icon, NULL).x : 0.0f;
        float checkmark_w = IM_FLOOR(g.FontSize * 1.20f);
        float min_w = window-&gt;DC.MenuColumns.DeclColumns(icon_w, label_size.x, 0.0f, checkmark_w); // Feedback to next frame
        float extra_w = ImMax(0.0f, GetContentRegionAvail().x - min_w);
        ImVec2 text_pos(window-&gt;DC.CursorPos.x + offsets-&gt;OffsetLabel, window-&gt;DC.CursorPos.y + window-&gt;DC.CurrLineTextBaseOffset);
        pressed = Selectable("", menu_is_open, ImGuiSelectableFlags_NoHoldingActiveID | ImGuiSelectableFlags_SelectOnClick | ImGuiSelectableFlags_DontClosePopups | ImGuiSelectableFlags_SpanAvailWidth, ImVec2(min_w, 0.0f));
        RenderText(text_pos, label);
        if (icon_w &gt; 0.0f)
            RenderText(pos + ImVec2(offsets-&gt;OffsetIcon, 0.0f), icon);
        RenderArrow(window-&gt;DrawList, pos + ImVec2(offsets-&gt;OffsetMark + extra_w + g.FontSize * 0.30f, 0.0f), GetColorU32(ImGuiCol_Text), ImGuiDir_Right);</span>
    }
<span style = "background-color:#fdd">    if (!enabled)
        EndDisabled();</span>

<span style = "background-color:#fdd">    const bool hovered = (g.HoveredId == id) &amp;&amp; enabled;
    if (menuset_is_open)
        g.NavWindow = backed_nav_window;</span>

<span style = "background-color:#fdd">    bool want_open = false;
    bool want_close = false;
    if (window-&gt;DC.LayoutType == ImGuiLayoutType_Vertical) // (window-&gt;Flags &amp; (ImGuiWindowFlags_Popup|ImGuiWindowFlags_ChildMenu))</span>
    {
        // Close menu when not hovering it anymore unless we are moving roughly in the direction of the menu
        // Implement http://bjk5.com/post/44698559168/breaking-down-amazons-mega-dropdown to avoid using timers, so menus feels more reactive.
<span style = "background-color:#fdd">        bool moving_toward_other_child_menu = false;
        ImGuiWindow* child_menu_window = (g.BeginPopupStack.Size &lt; g.OpenPopupStack.Size &amp;&amp; g.OpenPopupStack[g.BeginPopupStack.Size].SourceWindow == window) ? g.OpenPopupStack[g.BeginPopupStack.Size].Window : NULL;
        if (g.HoveredWindow == window &amp;&amp; child_menu_window != NULL &amp;&amp; !(window-&gt;Flags &amp; ImGuiWindowFlags_MenuBar))</span>
        {
<span style = "background-color:#fdd">            float ref_unit = g.FontSize; // FIXME-DPI
            ImRect next_window_rect = child_menu_window-&gt;Rect();
            ImVec2 ta = (g.IO.MousePos - g.IO.MouseDelta);
            ImVec2 tb = (window-&gt;Pos.x &lt; child_menu_window-&gt;Pos.x) ? next_window_rect.GetTL() : next_window_rect.GetTR();
            ImVec2 tc = (window-&gt;Pos.x &lt; child_menu_window-&gt;Pos.x) ? next_window_rect.GetBL() : next_window_rect.GetBR();
            float extra = ImClamp(ImFabs(ta.x - tb.x) * 0.30f, ref_unit * 0.5f, ref_unit * 2.5f);   // add a bit of extra slack.
            ta.x += (window-&gt;Pos.x &lt; child_menu_window-&gt;Pos.x) ? -0.5f : +0.5f;                     // to avoid numerical issues (FIXME: ??)
            tb.y = ta.y + ImMax((tb.y - extra) - ta.y, -ref_unit * 8.0f);                           // triangle is maximum 200 high to limit the slope and the bias toward large sub-menus // FIXME: Multiply by fb_scale?
            tc.y = ta.y + ImMin((tc.y + extra) - ta.y, +ref_unit * 8.0f);
            moving_toward_other_child_menu = ImTriangleContainsPoint(ta, tb, tc, g.IO.MousePos);</span>
            //GetForegroundDrawList()-&gt;AddTriangleFilled(ta, tb, tc, moving_toward_other_child_menu ? IM_COL32(0,128,0,128) : IM_COL32(128,0,0,128)); // [DEBUG]
        }
<span style = "background-color:#fdd">        if (menu_is_open &amp;&amp; !hovered &amp;&amp; g.HoveredWindow == window &amp;&amp; g.HoveredIdPreviousFrame != 0 &amp;&amp; g.HoveredIdPreviousFrame != id &amp;&amp; !moving_toward_other_child_menu)
            want_close = true;</span>

        // Open
<span style = "background-color:#fdd">        if (!menu_is_open &amp;&amp; pressed) // Click/activate to open
            want_open = true;
        else if (!menu_is_open &amp;&amp; hovered &amp;&amp; !moving_toward_other_child_menu) // Hover to open
            want_open = true;
        if (g.NavId == id &amp;&amp; g.NavMoveDir == ImGuiDir_Right) // Nav-Right to open</span>
        {
<span style = "background-color:#fdd">            want_open = true;
            NavMoveRequestCancel();</span>
        }
<span style = "background-color:#fdd">    }</span>
    else
    {
        // Menu bar
<span style = "background-color:#fdd">        if (menu_is_open &amp;&amp; pressed &amp;&amp; menuset_is_open) // Click an open menu again to close it</span>
        {
<span style = "background-color:#fdd">            want_close = true;
            want_open = menu_is_open = false;
        }
        else if (pressed || (hovered &amp;&amp; menuset_is_open &amp;&amp; !menu_is_open)) // First click to open, then hover to open others</span>
        {
<span style = "background-color:#fdd">            want_open = true;
        }
        else if (g.NavId == id &amp;&amp; g.NavMoveDir == ImGuiDir_Down) // Nav-Down to open</span>
        {
<span style = "background-color:#fdd">            want_open = true;
            NavMoveRequestCancel();</span>
        }
    }

<span style = "background-color:#fdd">    if (!enabled) // explicitly close if an open menu becomes disabled, facilitate users code a lot in pattern such as 'if (BeginMenu("options", has_object)) { ..use object.. }'
        want_close = true;
    if (want_close &amp;&amp; IsPopupOpen(id, ImGuiPopupFlags_None))
        ClosePopupToLevel(g.BeginPopupStack.Size, true);</span>

    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags | ImGuiItemStatusFlags_Openable | (menu_is_open ? ImGuiItemStatusFlags_Opened : 0));
<span style = "background-color:#fdd">    PopID();</span>

<span style = "background-color:#fdd">    if (!menu_is_open &amp;&amp; want_open &amp;&amp; g.OpenPopupStack.Size &gt; g.BeginPopupStack.Size)</span>
    {
        // Don't recycle same menu level in the same frame, first close the other menu and yield for a frame.
<span style = "background-color:#fdd">        OpenPopup(label);
        return false;</span>
    }

<span style = "background-color:#fdd">    menu_is_open |= want_open;
    if (want_open)
        OpenPopup(label);</span>

<span style = "background-color:#fdd">    if (menu_is_open)</span>
    {
<span style = "background-color:#fdd">        SetNextWindowPos(popup_pos, ImGuiCond_Always); // Note: this is super misleading! The value will serve as reference for FindBestWindowPosForPopup(), not actual pos.
        menu_is_open = BeginPopupEx(id, flags); // menu_is_open can be 'false' when the popup is completely clipped (e.g. zero size display)
    }</span>
    else
    {
<span style = "background-color:#fdd">        g.NextWindowData.ClearFlags(); // We behave like Begin() and need to consume those values</span>
    }

<span style = "background-color:#fdd">    return menu_is_open;
}</span>

bool ImGui::BeginMenu(const char* label, bool enabled)
<span style = "background-color:#fdd">{
    return BeginMenuEx(label, NULL, enabled);
}</span>

void ImGui::EndMenu()
<span style = "background-color:#fdd">{</span>
    // Nav: When a left move request _within our child menu_ failed, close ourselves (the _parent_ menu).
    // A menu doesn't close itself because EndMenuBar() wants the catch the last Left&lt;&gt;Right inputs.
    // However, it means that with the current code, a BeginMenu() from outside another menu or a menu-bar won't be closable with the Left direction.
<span style = "background-color:#fdd">    ImGuiContext&amp; g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (g.NavMoveDir == ImGuiDir_Left &amp;&amp; NavMoveRequestButNoResultYet() &amp;&amp; window-&gt;DC.LayoutType == ImGuiLayoutType_Vertical)
        if (g.NavWindow &amp;&amp; (g.NavWindow-&gt;RootWindowForNav-&gt;Flags &amp; ImGuiWindowFlags_Popup) &amp;&amp; g.NavWindow-&gt;RootWindowForNav-&gt;ParentWindow == window)</span>
        {
<span style = "background-color:#fdd">            ClosePopupToLevel(g.BeginPopupStack.Size, true);
            NavMoveRequestCancel();</span>
        }

<span style = "background-color:#fdd">    EndPopup();
}</span>

bool ImGui::MenuItemEx(const char* label, const char* icon, const char* shortcut, bool selected, bool enabled)
<span style = "background-color:#fdd">{
    ImGuiWindow* window = GetCurrentWindow();
    if (window-&gt;SkipItems)
        return false;</span>

<span style = "background-color:#fdd">    ImGuiContext&amp; g = *GImGui;
    ImGuiStyle&amp; style = g.Style;
    ImVec2 pos = window-&gt;DC.CursorPos;
    ImVec2 label_size = CalcTextSize(label, NULL, true);</span>

    // We've been using the equivalent of ImGuiSelectableFlags_SetNavIdOnHover on all Selectable() since early Nav system days (commit 43ee5d73),
    // but I am unsure whether this should be kept at all. For now moved it to be an opt-in feature used by menus only.
    bool pressed;
<span style = "background-color:#fdd">    PushID(label);
    if (!enabled)
        BeginDisabled();
    const ImGuiSelectableFlags flags = ImGuiSelectableFlags_SelectOnRelease | ImGuiSelectableFlags_SetNavIdOnHover;
    const ImGuiMenuColumns* offsets = &amp;window-&gt;DC.MenuColumns;
    if (window-&gt;DC.LayoutType == ImGuiLayoutType_Horizontal)</span>
    {
        // Mimic the exact layout spacing of BeginMenu() to allow MenuItem() inside a menu bar, which is a little misleading but may be useful
        // Note that in this situation: we don't render the shortcut, we render a highlight instead of the selected tick mark.
<span style = "background-color:#fdd">        float w = label_size.x;
        window-&gt;DC.CursorPos.x += IM_FLOOR(style.ItemSpacing.x * 0.5f);
        ImVec2 text_pos(window-&gt;DC.CursorPos.x + offsets-&gt;OffsetLabel, window-&gt;DC.CursorPos.y + window-&gt;DC.CurrLineTextBaseOffset);
        PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(style.ItemSpacing.x * 2.0f, style.ItemSpacing.y));
        pressed = Selectable("", selected, flags, ImVec2(w, 0.0f));
        PopStyleVar();
        RenderText(text_pos, label);
        window-&gt;DC.CursorPos.x += IM_FLOOR(style.ItemSpacing.x * (-1.0f + 0.5f)); // -1 spacing to compensate the spacing added when Selectable() did a SameLine(). It would also work to call SameLine() ourselves after the PopStyleVar().
    }</span>
    else
    {
        // Menu item inside a vertical menu
        // (In a typical menu window where all items are BeginMenu() or MenuItem() calls, extra_w will always be 0.0f.
        //  Only when they are other items sticking out we're going to add spacing, yet only register minimum width into the layout system.
<span style = "background-color:#fdd">        float icon_w = (icon &amp;&amp; icon[0]) ? CalcTextSize(icon, NULL).x : 0.0f;
        float shortcut_w = (shortcut &amp;&amp; shortcut[0]) ? CalcTextSize(shortcut, NULL).x : 0.0f;
        float checkmark_w = IM_FLOOR(g.FontSize * 1.20f);
        float min_w = window-&gt;DC.MenuColumns.DeclColumns(icon_w, label_size.x, shortcut_w, checkmark_w); // Feedback for next frame
        float stretch_w = ImMax(0.0f, GetContentRegionAvail().x - min_w);
        pressed = Selectable("", false, flags | ImGuiSelectableFlags_SpanAvailWidth, ImVec2(min_w, 0.0f));
        RenderText(pos + ImVec2(offsets-&gt;OffsetLabel, 0.0f), label);
        if (icon_w &gt; 0.0f)
            RenderText(pos + ImVec2(offsets-&gt;OffsetIcon, 0.0f), icon);
        if (shortcut_w &gt; 0.0f)</span>
        {
<span style = "background-color:#fdd">            PushStyleColor(ImGuiCol_Text, style.Colors[ImGuiCol_TextDisabled]);
            RenderText(pos + ImVec2(offsets-&gt;OffsetShortcut + stretch_w, 0.0f), shortcut, NULL, false);
            PopStyleColor();</span>
        }
<span style = "background-color:#fdd">        if (selected)
            RenderCheckMark(window-&gt;DrawList, pos + ImVec2(offsets-&gt;OffsetMark + stretch_w + g.FontSize * 0.40f, g.FontSize * 0.134f * 0.5f), GetColorU32(ImGuiCol_Text), g.FontSize  * 0.866f);</span>
    }
    IMGUI_TEST_ENGINE_ITEM_INFO(g.LastItemData.ID, label, g.LastItemData.StatusFlags | ImGuiItemStatusFlags_Checkable | (selected ? ImGuiItemStatusFlags_Checked : 0));
<span style = "background-color:#fdd">    if (!enabled)
        EndDisabled();
    PopID();</span>

<span style = "background-color:#fdd">    return pressed;
}</span>

bool ImGui::MenuItem(const char* label, const char* shortcut, bool selected, bool enabled)
<span style = "background-color:#fdd">{
    return MenuItemEx(label, NULL, shortcut, selected, enabled);
}</span>

bool ImGui::MenuItem(const char* label, const char* shortcut, bool* p_selected, bool enabled)
<span style = "background-color:#fdd">{
    if (MenuItemEx(label, NULL, shortcut, p_selected ? *p_selected : false, enabled))</span>
    {
<span style = "background-color:#fdd">        if (p_selected)
            *p_selected = !*p_selected;
        return true;</span>
    }
<span style = "background-color:#fdd">    return false;
}</span>

//-------------------------------------------------------------------------
// [SECTION] Widgets: BeginTabBar, EndTabBar, etc.
//-------------------------------------------------------------------------
// - BeginTabBar()
// - BeginTabBarEx() [Internal]
// - EndTabBar()
// - TabBarLayout() [Internal]
// - TabBarCalcTabID() [Internal]
// - TabBarCalcMaxTabWidth() [Internal]
// - TabBarFindTabById() [Internal]
// - TabBarRemoveTab() [Internal]
// - TabBarCloseTab() [Internal]
// - TabBarScrollClamp() [Internal]
// - TabBarScrollToTab() [Internal]
// - TabBarQueueChangeTabOrder() [Internal]
// - TabBarScrollingButtons() [Internal]
// - TabBarTabListPopupButton() [Internal]
//-------------------------------------------------------------------------

struct ImGuiTabBarSection
{
    int                 TabCount;               // Number of tabs in this section.
    float               Width;                  // Sum of width of tabs in this section (after shrinking down)
    float               Spacing;                // Horizontal spacing at the end of the section.

<span style = "background-color:#fdd">    ImGuiTabBarSection() { memset(this, 0, sizeof(*this)); }</span>
};

namespace ImGui
{
    static void             TabBarLayout(ImGuiTabBar* tab_bar);
    static ImU32            TabBarCalcTabID(ImGuiTabBar* tab_bar, const char* label);
    static float            TabBarCalcMaxTabWidth();
    static float            TabBarScrollClamp(ImGuiTabBar* tab_bar, float scrolling);
    static void             TabBarScrollToTab(ImGuiTabBar* tab_bar, ImGuiID tab_id, ImGuiTabBarSection* sections);
    static ImGuiTabItem*    TabBarScrollingButtons(ImGuiTabBar* tab_bar);
    static ImGuiTabItem*    TabBarTabListPopupButton(ImGuiTabBar* tab_bar);
}

ImGuiTabBar::ImGuiTabBar()
<span style = "background-color:#fdd">{
    memset(this, 0, sizeof(*this));
    CurrFrameVisible = PrevFrameVisible = -1;
    LastTabItemIdx = -1;
}</span>

static inline int TabItemGetSectionIdx(const ImGuiTabItem* tab)
<span style = "background-color:#fdd">{
    return (tab-&gt;Flags &amp; ImGuiTabItemFlags_Leading) ? 0 : (tab-&gt;Flags &amp; ImGuiTabItemFlags_Trailing) ? 2 : 1;
}</span>

static int IMGUI_CDECL TabItemComparerBySection(const void* lhs, const void* rhs)
<span style = "background-color:#fdd">{
    const ImGuiTabItem* a = (const ImGuiTabItem*)lhs;
    const ImGuiTabItem* b = (const ImGuiTabItem*)rhs;
    const int a_section = TabItemGetSectionIdx(a);
    const int b_section = TabItemGetSectionIdx(b);
    if (a_section != b_section)
        return a_section - b_section;
    return (int)(a-&gt;IndexDuringLayout - b-&gt;IndexDuringLayout);
}</span>

static int IMGUI_CDECL TabItemComparerByBeginOrder(const void* lhs, const void* rhs)
<span style = "background-color:#fdd">{
    const ImGuiTabItem* a = (const ImGuiTabItem*)lhs;
    const ImGuiTabItem* b = (const ImGuiTabItem*)rhs;
    return (int)(a-&gt;BeginOrder - b-&gt;BeginOrder);
}</span>

static ImGuiTabBar* GetTabBarFromTabBarRef(const ImGuiPtrOrIndex&amp; ref)
<span style = "background-color:#fdd">{
    ImGuiContext&amp; g = *GImGui;
    return ref.Ptr ? (ImGuiTabBar*)ref.Ptr : g.TabBars.GetByIndex(ref.Index);
}</span>

static ImGuiPtrOrIndex GetTabBarRefFromTabBar(ImGuiTabBar* tab_bar)
<span style = "background-color:#fdd">{
    ImGuiContext&amp; g = *GImGui;
    if (g.TabBars.Contains(tab_bar))
        return ImGuiPtrOrIndex(g.TabBars.GetIndex(tab_bar));
    return ImGuiPtrOrIndex(tab_bar);
}</span>

bool    ImGui::BeginTabBar(const char* str_id, ImGuiTabBarFlags flags)
<span style = "background-color:#fdd">{
    ImGuiContext&amp; g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (window-&gt;SkipItems)
        return false;</span>

<span style = "background-color:#fdd">    ImGuiID id = window-&gt;GetID(str_id);
    ImGuiTabBar* tab_bar = g.TabBars.GetOrAddByKey(id);
    ImRect tab_bar_bb = ImRect(window-&gt;DC.CursorPos.x, window-&gt;DC.CursorPos.y, window-&gt;WorkRect.Max.x, window-&gt;DC.CursorPos.y + g.FontSize + g.Style.FramePadding.y * 2);
    tab_bar-&gt;ID = id;
    return BeginTabBarEx(tab_bar, tab_bar_bb, flags | ImGuiTabBarFlags_IsFocused);
}</span>

bool    ImGui::BeginTabBarEx(ImGuiTabBar* tab_bar, const ImRect&amp; tab_bar_bb, ImGuiTabBarFlags flags)
<span style = "background-color:#fdd">{
    ImGuiContext&amp; g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (window-&gt;SkipItems)
        return false;</span>

<span style = "background-color:#fdd">    if ((flags &amp; ImGuiTabBarFlags_DockNode) == 0)
        PushOverrideID(tab_bar-&gt;ID);</span>

    // Add to stack
<span style = "background-color:#fdd">    g.CurrentTabBarStack.push_back(GetTabBarRefFromTabBar(tab_bar));
    g.CurrentTabBar = tab_bar;</span>

    // Append with multiple BeginTabBar()/EndTabBar() pairs.
<span style = "background-color:#fdd">    tab_bar-&gt;BackupCursorPos = window-&gt;DC.CursorPos;
    if (tab_bar-&gt;CurrFrameVisible == g.FrameCount)</span>
    {
<span style = "background-color:#fdd">        window-&gt;DC.CursorPos = ImVec2(tab_bar-&gt;BarRect.Min.x, tab_bar-&gt;BarRect.Max.y + tab_bar-&gt;ItemSpacingY);
        tab_bar-&gt;BeginCount++;
        return true;</span>
    }

    // Ensure correct ordering when toggling ImGuiTabBarFlags_Reorderable flag, or when a new tab was added while being not reorderable
<span style = "background-color:#fdd">    if ((flags &amp; ImGuiTabBarFlags_Reorderable) != (tab_bar-&gt;Flags &amp; ImGuiTabBarFlags_Reorderable) || (tab_bar-&gt;TabsAddedNew &amp;&amp; !(flags &amp; ImGuiTabBarFlags_Reorderable)))
        if (tab_bar-&gt;Tabs.Size &gt; 1)
            ImQsort(tab_bar-&gt;Tabs.Data, tab_bar-&gt;Tabs.Size, sizeof(ImGuiTabItem), TabItemComparerByBeginOrder);
    tab_bar-&gt;TabsAddedNew = false;</span>

    // Flags
<span style = "background-color:#fdd">    if ((flags &amp; ImGuiTabBarFlags_FittingPolicyMask_) == 0)
        flags |= ImGuiTabBarFlags_FittingPolicyDefault_;</span>

<span style = "background-color:#fdd">    tab_bar-&gt;Flags = flags;
    tab_bar-&gt;BarRect = tab_bar_bb;
    tab_bar-&gt;WantLayout = true; // Layout will be done on the first call to ItemTab()
    tab_bar-&gt;PrevFrameVisible = tab_bar-&gt;CurrFrameVisible;
    tab_bar-&gt;CurrFrameVisible = g.FrameCount;
    tab_bar-&gt;PrevTabsContentsHeight = tab_bar-&gt;CurrTabsContentsHeight;
    tab_bar-&gt;CurrTabsContentsHeight = 0.0f;
    tab_bar-&gt;ItemSpacingY = g.Style.ItemSpacing.y;
    tab_bar-&gt;FramePadding = g.Style.FramePadding;
    tab_bar-&gt;TabsActiveCount = 0;
    tab_bar-&gt;BeginCount = 1;</span>

    // Set cursor pos in a way which only be used in the off-chance the user erroneously submits item before BeginTabItem(): items will overlap
<span style = "background-color:#fdd">    window-&gt;DC.CursorPos = ImVec2(tab_bar-&gt;BarRect.Min.x, tab_bar-&gt;BarRect.Max.y + tab_bar-&gt;ItemSpacingY);</span>

    // Draw separator
<span style = "background-color:#fdd">    const ImU32 col = GetColorU32((flags &amp; ImGuiTabBarFlags_IsFocused) ? ImGuiCol_TabActive : ImGuiCol_TabUnfocusedActive);
    const float y = tab_bar-&gt;BarRect.Max.y - 1.0f;</span>
    {
<span style = "background-color:#fdd">        const float separator_min_x = tab_bar-&gt;BarRect.Min.x - IM_FLOOR(window-&gt;WindowPadding.x * 0.5f);
        const float separator_max_x = tab_bar-&gt;BarRect.Max.x + IM_FLOOR(window-&gt;WindowPadding.x * 0.5f);
        window-&gt;DrawList-&gt;AddLine(ImVec2(separator_min_x, y), ImVec2(separator_max_x, y), col, 1.0f);</span>
    }
<span style = "background-color:#fdd">    return true;
}</span>

void    ImGui::EndTabBar()
<span style = "background-color:#fdd">{
    ImGuiContext&amp; g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (window-&gt;SkipItems)
        return;</span>

<span style = "background-color:#fdd">    ImGuiTabBar* tab_bar = g.CurrentTabBar;
    if (tab_bar == NULL)</span>
    {
<span style = "background-color:#fdd">        IM_ASSERT_USER_ERROR(tab_bar != NULL, "Mismatched BeginTabBar()/EndTabBar()!");
        return;</span>
    }

    // Fallback in case no TabItem have been submitted
<span style = "background-color:#fdd">    if (tab_bar-&gt;WantLayout)
        TabBarLayout(tab_bar);</span>

    // Restore the last visible height if no tab is visible, this reduce vertical flicker/movement when a tabs gets removed without calling SetTabItemClosed().
<span style = "background-color:#fdd">    const bool tab_bar_appearing = (tab_bar-&gt;PrevFrameVisible + 1 &lt; g.FrameCount);
    if (tab_bar-&gt;VisibleTabWasSubmitted || tab_bar-&gt;VisibleTabId == 0 || tab_bar_appearing)</span>
    {
<span style = "background-color:#fdd">        tab_bar-&gt;CurrTabsContentsHeight = ImMax(window-&gt;DC.CursorPos.y - tab_bar-&gt;BarRect.Max.y, tab_bar-&gt;CurrTabsContentsHeight);
        window-&gt;DC.CursorPos.y = tab_bar-&gt;BarRect.Max.y + tab_bar-&gt;CurrTabsContentsHeight;
    }</span>
    else
    {
<span style = "background-color:#fdd">        window-&gt;DC.CursorPos.y = tab_bar-&gt;BarRect.Max.y + tab_bar-&gt;PrevTabsContentsHeight;</span>
    }
<span style = "background-color:#fdd">    if (tab_bar-&gt;BeginCount &gt; 1)
        window-&gt;DC.CursorPos = tab_bar-&gt;BackupCursorPos;</span>

<span style = "background-color:#fdd">    if ((tab_bar-&gt;Flags &amp; ImGuiTabBarFlags_DockNode) == 0)
        PopID();</span>

<span style = "background-color:#fdd">    g.CurrentTabBarStack.pop_back();
    g.CurrentTabBar = g.CurrentTabBarStack.empty() ? NULL : GetTabBarFromTabBarRef(g.CurrentTabBarStack.back());
}</span>

// This is called only once a frame before by the first call to ItemTab()
// The reason we're not calling it in BeginTabBar() is to leave a chance to the user to call the SetTabItemClosed() functions.
static void ImGui::TabBarLayout(ImGuiTabBar* tab_bar)
<span style = "background-color:#fdd">{
    ImGuiContext&amp; g = *GImGui;
    tab_bar-&gt;WantLayout = false;</span>

    // Garbage collect by compacting list
    // Detect if we need to sort out tab list (e.g. in rare case where a tab changed section)
<span style = "background-color:#fdd">    int tab_dst_n = 0;
    bool need_sort_by_section = false;
    ImGuiTabBarSection sections[3]; // Layout sections: Leading, Central, Trailing
    for (int tab_src_n = 0; tab_src_n &lt; tab_bar-&gt;Tabs.Size; tab_src_n++)</span>
    {
<span style = "background-color:#fdd">        ImGuiTabItem* tab = &amp;tab_bar-&gt;Tabs[tab_src_n];
        if (tab-&gt;LastFrameVisible &lt; tab_bar-&gt;PrevFrameVisible || tab-&gt;WantClose)</span>
        {
            // Remove tab
<span style = "background-color:#fdd">            if (tab_bar-&gt;VisibleTabId == tab-&gt;ID) { tab_bar-&gt;VisibleTabId = 0; }
            if (tab_bar-&gt;SelectedTabId == tab-&gt;ID) { tab_bar-&gt;SelectedTabId = 0; }
            if (tab_bar-&gt;NextSelectedTabId == tab-&gt;ID) { tab_bar-&gt;NextSelectedTabId = 0; }
            continue;</span>
        }
<span style = "background-color:#fdd">        if (tab_dst_n != tab_src_n)
            tab_bar-&gt;Tabs[tab_dst_n] = tab_bar-&gt;Tabs[tab_src_n];</span>

<span style = "background-color:#fdd">        tab = &amp;tab_bar-&gt;Tabs[tab_dst_n];
        tab-&gt;IndexDuringLayout = (ImS16)tab_dst_n;</span>

        // We will need sorting if tabs have changed section (e.g. moved from one of Leading/Central/Trailing to another)
<span style = "background-color:#fdd">        int curr_tab_section_n = TabItemGetSectionIdx(tab);
        if (tab_dst_n &gt; 0)</span>
        {
<span style = "background-color:#fdd">            ImGuiTabItem* prev_tab = &amp;tab_bar-&gt;Tabs[tab_dst_n - 1];
            int prev_tab_section_n = TabItemGetSectionIdx(prev_tab);
            if (curr_tab_section_n == 0 &amp;&amp; prev_tab_section_n != 0)
                need_sort_by_section = true;
            if (prev_tab_section_n == 2 &amp;&amp; curr_tab_section_n != 2)
                need_sort_by_section = true;</span>
        }

<span style = "background-color:#fdd">        sections[curr_tab_section_n].TabCount++;
        tab_dst_n++;
    }
    if (tab_bar-&gt;Tabs.Size != tab_dst_n)
        tab_bar-&gt;Tabs.resize(tab_dst_n);</span>

<span style = "background-color:#fdd">    if (need_sort_by_section)
        ImQsort(tab_bar-&gt;Tabs.Data, tab_bar-&gt;Tabs.Size, sizeof(ImGuiTabItem), TabItemComparerBySection);</span>

    // Calculate spacing between sections
<span style = "background-color:#fdd">    sections[0].Spacing = sections[0].TabCount &gt; 0 &amp;&amp; (sections[1].TabCount + sections[2].TabCount) &gt; 0 ? g.Style.ItemInnerSpacing.x : 0.0f;
    sections[1].Spacing = sections[1].TabCount &gt; 0 &amp;&amp; sections[2].TabCount &gt; 0 ? g.Style.ItemInnerSpacing.x : 0.0f;</span>

    // Setup next selected tab
<span style = "background-color:#fdd">    ImGuiID scroll_to_tab_id = 0;
    if (tab_bar-&gt;NextSelectedTabId)</span>
    {
<span style = "background-color:#fdd">        tab_bar-&gt;SelectedTabId = tab_bar-&gt;NextSelectedTabId;
        tab_bar-&gt;NextSelectedTabId = 0;
        scroll_to_tab_id = tab_bar-&gt;SelectedTabId;</span>
    }

    // Process order change request (we could probably process it when requested but it's just saner to do it in a single spot).
<span style = "background-color:#fdd">    if (tab_bar-&gt;ReorderRequestTabId != 0)</span>
    {
<span style = "background-color:#fdd">        if (TabBarProcessReorder(tab_bar))
            if (tab_bar-&gt;ReorderRequestTabId == tab_bar-&gt;SelectedTabId)
                scroll_to_tab_id = tab_bar-&gt;ReorderRequestTabId;
        tab_bar-&gt;ReorderRequestTabId = 0;</span>
    }

    // Tab List Popup (will alter tab_bar-&gt;BarRect and therefore the available width!)
<span style = "background-color:#fdd">    const bool tab_list_popup_button = (tab_bar-&gt;Flags &amp; ImGuiTabBarFlags_TabListPopupButton) != 0;
    if (tab_list_popup_button)
        if (ImGuiTabItem* tab_to_select = TabBarTabListPopupButton(tab_bar)) // NB: Will alter BarRect.Min.x!
            scroll_to_tab_id = tab_bar-&gt;SelectedTabId = tab_to_select-&gt;ID;</span>

    // Leading/Trailing tabs will be shrink only if central one aren't visible anymore, so layout the shrink data as: leading, trailing, central
    // (whereas our tabs are stored as: leading, central, trailing)
<span style = "background-color:#fdd">    int shrink_buffer_indexes[3] = { 0, sections[0].TabCount + sections[2].TabCount, sections[0].TabCount };
    g.ShrinkWidthBuffer.resize(tab_bar-&gt;Tabs.Size);</span>

    // Compute ideal tabs widths + store them into shrink buffer
<span style = "background-color:#fdd">    ImGuiTabItem* most_recently_selected_tab = NULL;
    int curr_section_n = -1;
    bool found_selected_tab_id = false;
    for (int tab_n = 0; tab_n &lt; tab_bar-&gt;Tabs.Size; tab_n++)</span>
    {
<span style = "background-color:#fdd">        ImGuiTabItem* tab = &amp;tab_bar-&gt;Tabs[tab_n];
        IM_ASSERT(tab-&gt;LastFrameVisible &gt;= tab_bar-&gt;PrevFrameVisible);</span>

<span style = "background-color:#fdd">        if ((most_recently_selected_tab == NULL || most_recently_selected_tab-&gt;LastFrameSelected &lt; tab-&gt;LastFrameSelected) &amp;&amp; !(tab-&gt;Flags &amp; ImGuiTabItemFlags_Button))
            most_recently_selected_tab = tab;
        if (tab-&gt;ID == tab_bar-&gt;SelectedTabId)
            found_selected_tab_id = true;
        if (scroll_to_tab_id == 0 &amp;&amp; g.NavJustMovedToId == tab-&gt;ID)
            scroll_to_tab_id = tab-&gt;ID;</span>

        // Refresh tab width immediately, otherwise changes of style e.g. style.FramePadding.x would noticeably lag in the tab bar.
        // Additionally, when using TabBarAddTab() to manipulate tab bar order we occasionally insert new tabs that don't have a width yet,
        // and we cannot wait for the next BeginTabItem() call. We cannot compute this width within TabBarAddTab() because font size depends on the active window.
<span style = "background-color:#fdd">        const char* tab_name = tab_bar-&gt;GetTabName(tab);
        const bool has_close_button = (tab-&gt;Flags &amp; ImGuiTabItemFlags_NoCloseButton) ? false : true;
        tab-&gt;ContentWidth = TabItemCalcSize(tab_name, has_close_button).x;</span>

<span style = "background-color:#fdd">        int section_n = TabItemGetSectionIdx(tab);
        ImGuiTabBarSection* section = &amp;sections[section_n];
        section-&gt;Width += tab-&gt;ContentWidth + (section_n == curr_section_n ? g.Style.ItemInnerSpacing.x : 0.0f);
        curr_section_n = section_n;</span>

        // Store data so we can build an array sorted by width if we need to shrink tabs down
        IM_MSVC_WARNING_SUPPRESS(6385);
<span style = "background-color:#fdd">        int shrink_buffer_index = shrink_buffer_indexes[section_n]++;
        g.ShrinkWidthBuffer[shrink_buffer_index].Index = tab_n;
        g.ShrinkWidthBuffer[shrink_buffer_index].Width = tab-&gt;ContentWidth;</span>

<span style = "background-color:#fdd">        IM_ASSERT(tab-&gt;ContentWidth &gt; 0.0f);
        tab-&gt;Width = tab-&gt;ContentWidth;
    }</span>

    // Compute total ideal width (used for e.g. auto-resizing a window)
<span style = "background-color:#fdd">    tab_bar-&gt;WidthAllTabsIdeal = 0.0f;
    for (int section_n = 0; section_n &lt; 3; section_n++)
        tab_bar-&gt;WidthAllTabsIdeal += sections[section_n].Width + sections[section_n].Spacing;</span>

    // Horizontal scrolling buttons
    // (note that TabBarScrollButtons() will alter BarRect.Max.x)
<span style = "background-color:#fdd">    if ((tab_bar-&gt;WidthAllTabsIdeal &gt; tab_bar-&gt;BarRect.GetWidth() &amp;&amp; tab_bar-&gt;Tabs.Size &gt; 1) &amp;&amp; !(tab_bar-&gt;Flags &amp; ImGuiTabBarFlags_NoTabListScrollingButtons) &amp;&amp; (tab_bar-&gt;Flags &amp; ImGuiTabBarFlags_FittingPolicyScroll))
        if (ImGuiTabItem* scroll_and_select_tab = TabBarScrollingButtons(tab_bar))</span>
        {
<span style = "background-color:#fdd">            scroll_to_tab_id = scroll_and_select_tab-&gt;ID;
            if ((scroll_and_select_tab-&gt;Flags &amp; ImGuiTabItemFlags_Button) == 0)
                tab_bar-&gt;SelectedTabId = scroll_to_tab_id;</span>
        }

    // Shrink widths if full tabs don't fit in their allocated space
<span style = "background-color:#fdd">    float section_0_w = sections[0].Width + sections[0].Spacing;
    float section_1_w = sections[1].Width + sections[1].Spacing;
    float section_2_w = sections[2].Width + sections[2].Spacing;
    bool central_section_is_visible = (section_0_w + section_2_w) &lt; tab_bar-&gt;BarRect.GetWidth();</span>
    float width_excess;
<span style = "background-color:#fdd">    if (central_section_is_visible)
        width_excess = ImMax(section_1_w - (tab_bar-&gt;BarRect.GetWidth() - section_0_w - section_2_w), 0.0f); // Excess used to shrink central section</span>
    else
<span style = "background-color:#fdd">        width_excess = (section_0_w + section_2_w) - tab_bar-&gt;BarRect.GetWidth(); // Excess used to shrink leading/trailing section</span>

    // With ImGuiTabBarFlags_FittingPolicyScroll policy, we will only shrink leading/trailing if the central section is not visible anymore
<span style = "background-color:#fdd">    if (width_excess &gt; 0.0f &amp;&amp; ((tab_bar-&gt;Flags &amp; ImGuiTabBarFlags_FittingPolicyResizeDown) || !central_section_is_visible))</span>
    {
<span style = "background-color:#fdd">        int shrink_data_count = (central_section_is_visible ? sections[1].TabCount : sections[0].TabCount + sections[2].TabCount);
        int shrink_data_offset = (central_section_is_visible ? sections[0].TabCount + sections[2].TabCount : 0);
        ShrinkWidths(g.ShrinkWidthBuffer.Data + shrink_data_offset, shrink_data_count, width_excess);</span>

        // Apply shrunk values into tabs and sections
<span style = "background-color:#fdd">        for (int tab_n = shrink_data_offset; tab_n &lt; shrink_data_offset + shrink_data_count; tab_n++)</span>
        {
<span style = "background-color:#fdd">            ImGuiTabItem* tab = &amp;tab_bar-&gt;Tabs[g.ShrinkWidthBuffer[tab_n].Index];
            float shrinked_width = IM_FLOOR(g.ShrinkWidthBuffer[tab_n].Width);
            if (shrinked_width &lt; 0.0f)
                continue;</span>

<span style = "background-color:#fdd">            int section_n = TabItemGetSectionIdx(tab);
            sections[section_n].Width -= (tab-&gt;Width - shrinked_width);
            tab-&gt;Width = shrinked_width;
        }</span>
    }

    // Layout all active tabs
<span style = "background-color:#fdd">    int section_tab_index = 0;
    float tab_offset = 0.0f;
    tab_bar-&gt;WidthAllTabs = 0.0f;
    for (int section_n = 0; section_n &lt; 3; section_n++)</span>
    {
<span style = "background-color:#fdd">        ImGuiTabBarSection* section = &amp;sections[section_n];
        if (section_n == 2)
            tab_offset = ImMin(ImMax(0.0f, tab_bar-&gt;BarRect.GetWidth() - section-&gt;Width), tab_offset);</span>

<span style = "background-color:#fdd">        for (int tab_n = 0; tab_n &lt; section-&gt;TabCount; tab_n++)</span>
        {
<span style = "background-color:#fdd">            ImGuiTabItem* tab = &amp;tab_bar-&gt;Tabs[section_tab_index + tab_n];
            tab-&gt;Offset = tab_offset;
            tab_offset += tab-&gt;Width + (tab_n &lt; section-&gt;TabCount - 1 ? g.Style.ItemInnerSpacing.x : 0.0f);
        }
        tab_bar-&gt;WidthAllTabs += ImMax(section-&gt;Width + section-&gt;Spacing, 0.0f);
        tab_offset += section-&gt;Spacing;
        section_tab_index += section-&gt;TabCount;
    }</span>

    // If we have lost the selected tab, select the next most recently active one
<span style = "background-color:#fdd">    if (found_selected_tab_id == false)
        tab_bar-&gt;SelectedTabId = 0;
    if (tab_bar-&gt;SelectedTabId == 0 &amp;&amp; tab_bar-&gt;NextSelectedTabId == 0 &amp;&amp; most_recently_selected_tab != NULL)
        scroll_to_tab_id = tab_bar-&gt;SelectedTabId = most_recently_selected_tab-&gt;ID;</span>

    // Lock in visible tab
<span style = "background-color:#fdd">    tab_bar-&gt;VisibleTabId = tab_bar-&gt;SelectedTabId;
    tab_bar-&gt;VisibleTabWasSubmitted = false;</span>

    // Update scrolling
<span style = "background-color:#fdd">    if (scroll_to_tab_id != 0)
        TabBarScrollToTab(tab_bar, scroll_to_tab_id, sections);
    tab_bar-&gt;ScrollingAnim = TabBarScrollClamp(tab_bar, tab_bar-&gt;ScrollingAnim);
    tab_bar-&gt;ScrollingTarget = TabBarScrollClamp(tab_bar, tab_bar-&gt;ScrollingTarget);
    if (tab_bar-&gt;ScrollingAnim != tab_bar-&gt;ScrollingTarget)</span>
    {
        // Scrolling speed adjust itself so we can always reach our target in 1/3 seconds.
        // Teleport if we are aiming far off the visible line
<span style = "background-color:#fdd">        tab_bar-&gt;ScrollingSpeed = ImMax(tab_bar-&gt;ScrollingSpeed, 70.0f * g.FontSize);
        tab_bar-&gt;ScrollingSpeed = ImMax(tab_bar-&gt;ScrollingSpeed, ImFabs(tab_bar-&gt;ScrollingTarget - tab_bar-&gt;ScrollingAnim) / 0.3f);
        const bool teleport = (tab_bar-&gt;PrevFrameVisible + 1 &lt; g.FrameCount) || (tab_bar-&gt;ScrollingTargetDistToVisibility &gt; 10.0f * g.FontSize);
        tab_bar-&gt;ScrollingAnim = teleport ? tab_bar-&gt;ScrollingTarget : ImLinearSweep(tab_bar-&gt;ScrollingAnim, tab_bar-&gt;ScrollingTarget, g.IO.DeltaTime * tab_bar-&gt;ScrollingSpeed);
    }</span>
    else
    {
<span style = "background-color:#fdd">        tab_bar-&gt;ScrollingSpeed = 0.0f;</span>
    }
<span style = "background-color:#fdd">    tab_bar-&gt;ScrollingRectMinX = tab_bar-&gt;BarRect.Min.x + sections[0].Width + sections[0].Spacing;
    tab_bar-&gt;ScrollingRectMaxX = tab_bar-&gt;BarRect.Max.x - sections[2].Width - sections[1].Spacing;</span>

    // Clear name buffers
<span style = "background-color:#fdd">    if ((tab_bar-&gt;Flags &amp; ImGuiTabBarFlags_DockNode) == 0)
        tab_bar-&gt;TabsNames.Buf.resize(0);</span>

    // Actual layout in host window (we don't do it in BeginTabBar() so as not to waste an extra frame)
<span style = "background-color:#fdd">    ImGuiWindow* window = g.CurrentWindow;
    window-&gt;DC.CursorPos = tab_bar-&gt;BarRect.Min;
    ItemSize(ImVec2(tab_bar-&gt;WidthAllTabs, tab_bar-&gt;BarRect.GetHeight()), tab_bar-&gt;FramePadding.y);
    window-&gt;DC.IdealMaxPos.x = ImMax(window-&gt;DC.IdealMaxPos.x, tab_bar-&gt;BarRect.Min.x + tab_bar-&gt;WidthAllTabsIdeal);
}</span>

// Dockables uses Name/ID in the global namespace. Non-dockable items use the ID stack.
static ImU32   ImGui::TabBarCalcTabID(ImGuiTabBar* tab_bar, const char* label)
<span style = "background-color:#fdd">{
    if (tab_bar-&gt;Flags &amp; ImGuiTabBarFlags_DockNode)</span>
    {
<span style = "background-color:#fdd">        ImGuiID id = ImHashStr(label);
        KeepAliveID(id);
        return id;
    }</span>
    else
    {
<span style = "background-color:#fdd">        ImGuiWindow* window = GImGui-&gt;CurrentWindow;
        return window-&gt;GetID(label);</span>
    }
<span style = "background-color:#fdd">}</span>

static float ImGui::TabBarCalcMaxTabWidth()
<span style = "background-color:#fdd">{
    ImGuiContext&amp; g = *GImGui;
    return g.FontSize * 20.0f;
}</span>

ImGuiTabItem* ImGui::TabBarFindTabByID(ImGuiTabBar* tab_bar, ImGuiID tab_id)
<span style = "background-color:#fdd">{
    if (tab_id != 0)
        for (int n = 0; n &lt; tab_bar-&gt;Tabs.Size; n++)
            if (tab_bar-&gt;Tabs[n].ID == tab_id)
                return &amp;tab_bar-&gt;Tabs[n];
    return NULL;
}</span>

// The *TabId fields be already set by the docking system _before_ the actual TabItem was created, so we clear them regardless.
void ImGui::TabBarRemoveTab(ImGuiTabBar* tab_bar, ImGuiID tab_id)
<span style = "background-color:#fdd">{
    if (ImGuiTabItem* tab = TabBarFindTabByID(tab_bar, tab_id))
        tab_bar-&gt;Tabs.erase(tab);
    if (tab_bar-&gt;VisibleTabId == tab_id)      { tab_bar-&gt;VisibleTabId = 0; }
    if (tab_bar-&gt;SelectedTabId == tab_id)     { tab_bar-&gt;SelectedTabId = 0; }
    if (tab_bar-&gt;NextSelectedTabId == tab_id) { tab_bar-&gt;NextSelectedTabId = 0; }
}</span>

// Called on manual closure attempt
void ImGui::TabBarCloseTab(ImGuiTabBar* tab_bar, ImGuiTabItem* tab)
<span style = "background-color:#fdd">{
    IM_ASSERT(!(tab-&gt;Flags &amp; ImGuiTabItemFlags_Button));
    if (!(tab-&gt;Flags &amp; ImGuiTabItemFlags_UnsavedDocument))</span>
    {
        // This will remove a frame of lag for selecting another tab on closure.
        // However we don't run it in the case where the 'Unsaved' flag is set, so user gets a chance to fully undo the closure
<span style = "background-color:#fdd">        tab-&gt;WantClose = true;
        if (tab_bar-&gt;VisibleTabId == tab-&gt;ID)</span>
        {
<span style = "background-color:#fdd">            tab-&gt;LastFrameVisible = -1;
            tab_bar-&gt;SelectedTabId = tab_bar-&gt;NextSelectedTabId = 0;</span>
        }
<span style = "background-color:#fdd">    }</span>
    else
    {
        // Actually select before expecting closure attempt (on an UnsavedDocument tab user is expect to e.g. show a popup)
<span style = "background-color:#fdd">        if (tab_bar-&gt;VisibleTabId != tab-&gt;ID)
            tab_bar-&gt;NextSelectedTabId = tab-&gt;ID;</span>
    }
<span style = "background-color:#fdd">}</span>

static float ImGui::TabBarScrollClamp(ImGuiTabBar* tab_bar, float scrolling)
<span style = "background-color:#fdd">{
    scrolling = ImMin(scrolling, tab_bar-&gt;WidthAllTabs - tab_bar-&gt;BarRect.GetWidth());
    return ImMax(scrolling, 0.0f);
}</span>

// Note: we may scroll to tab that are not selected! e.g. using keyboard arrow keys
static void ImGui::TabBarScrollToTab(ImGuiTabBar* tab_bar, ImGuiID tab_id, ImGuiTabBarSection* sections)
<span style = "background-color:#fdd">{
    ImGuiTabItem* tab = TabBarFindTabByID(tab_bar, tab_id);
    if (tab == NULL)
        return;
    if (tab-&gt;Flags &amp; ImGuiTabItemFlags_SectionMask_)
        return;</span>

<span style = "background-color:#fdd">    ImGuiContext&amp; g = *GImGui;
    float margin = g.FontSize * 1.0f; // When to scroll to make Tab N+1 visible always make a bit of N visible to suggest more scrolling area (since we don't have a scrollbar)
    int order = tab_bar-&gt;GetTabOrder(tab);</span>

    // Scrolling happens only in the central section (leading/trailing sections are not scrolling)
    // FIXME: This is all confusing.
<span style = "background-color:#fdd">    float scrollable_width = tab_bar-&gt;BarRect.GetWidth() - sections[0].Width - sections[2].Width - sections[1].Spacing;</span>

    // We make all tabs positions all relative Sections[0].Width to make code simpler
<span style = "background-color:#fdd">    float tab_x1 = tab-&gt;Offset - sections[0].Width + (order &gt; sections[0].TabCount - 1 ? -margin : 0.0f);
    float tab_x2 = tab-&gt;Offset - sections[0].Width + tab-&gt;Width + (order + 1 &lt; tab_bar-&gt;Tabs.Size - sections[2].TabCount ? margin : 1.0f);
    tab_bar-&gt;ScrollingTargetDistToVisibility = 0.0f;
    if (tab_bar-&gt;ScrollingTarget &gt; tab_x1 || (tab_x2 - tab_x1 &gt;= scrollable_width))</span>
    {
        // Scroll to the left
<span style = "background-color:#fdd">        tab_bar-&gt;ScrollingTargetDistToVisibility = ImMax(tab_bar-&gt;ScrollingAnim - tab_x2, 0.0f);
        tab_bar-&gt;ScrollingTarget = tab_x1;
    }
    else if (tab_bar-&gt;ScrollingTarget &lt; tab_x2 - scrollable_width)</span>
    {
        // Scroll to the right
<span style = "background-color:#fdd">        tab_bar-&gt;ScrollingTargetDistToVisibility = ImMax((tab_x1 - scrollable_width) - tab_bar-&gt;ScrollingAnim, 0.0f);
        tab_bar-&gt;ScrollingTarget = tab_x2 - scrollable_width;</span>
    }
<span style = "background-color:#fdd">}</span>

void ImGui::TabBarQueueReorder(ImGuiTabBar* tab_bar, const ImGuiTabItem* tab, int offset)
<span style = "background-color:#fdd">{
    IM_ASSERT(offset != 0);
    IM_ASSERT(tab_bar-&gt;ReorderRequestTabId == 0);
    tab_bar-&gt;ReorderRequestTabId = tab-&gt;ID;
    tab_bar-&gt;ReorderRequestOffset = (ImS16)offset;
}</span>

void ImGui::TabBarQueueReorderFromMousePos(ImGuiTabBar* tab_bar, const ImGuiTabItem* src_tab, ImVec2 mouse_pos)
<span style = "background-color:#fdd">{
    ImGuiContext&amp; g = *GImGui;
    IM_ASSERT(tab_bar-&gt;ReorderRequestTabId == 0);
    if ((tab_bar-&gt;Flags &amp; ImGuiTabBarFlags_Reorderable) == 0)
        return;</span>

<span style = "background-color:#fdd">    const bool is_central_section = (src_tab-&gt;Flags &amp; ImGuiTabItemFlags_SectionMask_) == 0;
    const float bar_offset = tab_bar-&gt;BarRect.Min.x - (is_central_section ? tab_bar-&gt;ScrollingTarget : 0);</span>

    // Count number of contiguous tabs we are crossing over
<span style = "background-color:#fdd">    const int dir = (bar_offset + src_tab-&gt;Offset) &gt; mouse_pos.x ? -1 : +1;
    const int src_idx = tab_bar-&gt;Tabs.index_from_ptr(src_tab);
    int dst_idx = src_idx;
    for (int i = src_idx; i &gt;= 0 &amp;&amp; i &lt; tab_bar-&gt;Tabs.Size; i += dir)</span>
    {
        // Reordered tabs must share the same section
<span style = "background-color:#fdd">        const ImGuiTabItem* dst_tab = &amp;tab_bar-&gt;Tabs[i];
        if (dst_tab-&gt;Flags &amp; ImGuiTabItemFlags_NoReorder)
            break;
        if ((dst_tab-&gt;Flags &amp; ImGuiTabItemFlags_SectionMask_) != (src_tab-&gt;Flags &amp; ImGuiTabItemFlags_SectionMask_))
            break;
        dst_idx = i;</span>

        // Include spacing after tab, so when mouse cursor is between tabs we would not continue checking further tabs that are not hovered.
<span style = "background-color:#fdd">        const float x1 = bar_offset + dst_tab-&gt;Offset - g.Style.ItemInnerSpacing.x;
        const float x2 = bar_offset + dst_tab-&gt;Offset + dst_tab-&gt;Width + g.Style.ItemInnerSpacing.x;</span>
        //GetForegroundDrawList()-&gt;AddRect(ImVec2(x1, tab_bar-&gt;BarRect.Min.y), ImVec2(x2, tab_bar-&gt;BarRect.Max.y), IM_COL32(255, 0, 0, 255));
<span style = "background-color:#fdd">        if ((dir &lt; 0 &amp;&amp; mouse_pos.x &gt; x1) || (dir &gt; 0 &amp;&amp; mouse_pos.x &lt; x2))
            break;
    }</span>

<span style = "background-color:#fdd">    if (dst_idx != src_idx)
        TabBarQueueReorder(tab_bar, src_tab, dst_idx - src_idx);
}</span>

bool ImGui::TabBarProcessReorder(ImGuiTabBar* tab_bar)
<span style = "background-color:#fdd">{
    ImGuiTabItem* tab1 = TabBarFindTabByID(tab_bar, tab_bar-&gt;ReorderRequestTabId);
    if (tab1 == NULL || (tab1-&gt;Flags &amp; ImGuiTabItemFlags_NoReorder))
        return false;</span>

    //IM_ASSERT(tab_bar-&gt;Flags &amp; ImGuiTabBarFlags_Reorderable); // &lt;- this may happen when using debug tools
<span style = "background-color:#fdd">    int tab2_order = tab_bar-&gt;GetTabOrder(tab1) + tab_bar-&gt;ReorderRequestOffset;
    if (tab2_order &lt; 0 || tab2_order &gt;= tab_bar-&gt;Tabs.Size)
        return false;</span>

    // Reordered tabs must share the same section
    // (Note: TabBarQueueReorderFromMousePos() also has a similar test but since we allow direct calls to TabBarQueueReorder() we do it here too)
<span style = "background-color:#fdd">    ImGuiTabItem* tab2 = &amp;tab_bar-&gt;Tabs[tab2_order];
    if (tab2-&gt;Flags &amp; ImGuiTabItemFlags_NoReorder)
        return false;
    if ((tab1-&gt;Flags &amp; ImGuiTabItemFlags_SectionMask_) != (tab2-&gt;Flags &amp; ImGuiTabItemFlags_SectionMask_))
        return false;</span>

<span style = "background-color:#fdd">    ImGuiTabItem item_tmp = *tab1;
    ImGuiTabItem* src_tab = (tab_bar-&gt;ReorderRequestOffset &gt; 0) ? tab1 + 1 : tab2;
    ImGuiTabItem* dst_tab = (tab_bar-&gt;ReorderRequestOffset &gt; 0) ? tab1 : tab2 + 1;
    const int move_count = (tab_bar-&gt;ReorderRequestOffset &gt; 0) ? tab_bar-&gt;ReorderRequestOffset : -tab_bar-&gt;ReorderRequestOffset;
    memmove(dst_tab, src_tab, move_count * sizeof(ImGuiTabItem));
    *tab2 = item_tmp;</span>

<span style = "background-color:#fdd">    if (tab_bar-&gt;Flags &amp; ImGuiTabBarFlags_SaveSettings)
        MarkIniSettingsDirty();
    return true;
}</span>

static ImGuiTabItem* ImGui::TabBarScrollingButtons(ImGuiTabBar* tab_bar)
<span style = "background-color:#fdd">{
    ImGuiContext&amp; g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;</span>

<span style = "background-color:#fdd">    const ImVec2 arrow_button_size(g.FontSize - 2.0f, g.FontSize + g.Style.FramePadding.y * 2.0f);
    const float scrolling_buttons_width = arrow_button_size.x * 2.0f;</span>

<span style = "background-color:#fdd">    const ImVec2 backup_cursor_pos = window-&gt;DC.CursorPos;</span>
    //window-&gt;DrawList-&gt;AddRect(ImVec2(tab_bar-&gt;BarRect.Max.x - scrolling_buttons_width, tab_bar-&gt;BarRect.Min.y), ImVec2(tab_bar-&gt;BarRect.Max.x, tab_bar-&gt;BarRect.Max.y), IM_COL32(255,0,0,255));

<span style = "background-color:#fdd">    int select_dir = 0;
    ImVec4 arrow_col = g.Style.Colors[ImGuiCol_Text];
    arrow_col.w *= 0.5f;</span>

<span style = "background-color:#fdd">    PushStyleColor(ImGuiCol_Text, arrow_col);
    PushStyleColor(ImGuiCol_Button, ImVec4(0, 0, 0, 0));
    const float backup_repeat_delay = g.IO.KeyRepeatDelay;
    const float backup_repeat_rate = g.IO.KeyRepeatRate;
    g.IO.KeyRepeatDelay = 0.250f;
    g.IO.KeyRepeatRate = 0.200f;
    float x = ImMax(tab_bar-&gt;BarRect.Min.x, tab_bar-&gt;BarRect.Max.x - scrolling_buttons_width);
    window-&gt;DC.CursorPos = ImVec2(x, tab_bar-&gt;BarRect.Min.y);
    if (ArrowButtonEx("##&lt;", ImGuiDir_Left, arrow_button_size, ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_Repeat))
        select_dir = -1;
    window-&gt;DC.CursorPos = ImVec2(x + arrow_button_size.x, tab_bar-&gt;BarRect.Min.y);
    if (ArrowButtonEx("##&gt;", ImGuiDir_Right, arrow_button_size, ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_Repeat))
        select_dir = +1;
    PopStyleColor(2);
    g.IO.KeyRepeatRate = backup_repeat_rate;
    g.IO.KeyRepeatDelay = backup_repeat_delay;</span>

<span style = "background-color:#fdd">    ImGuiTabItem* tab_to_scroll_to = NULL;
    if (select_dir != 0)
        if (ImGuiTabItem* tab_item = TabBarFindTabByID(tab_bar, tab_bar-&gt;SelectedTabId))</span>
        {
<span style = "background-color:#fdd">            int selected_order = tab_bar-&gt;GetTabOrder(tab_item);
            int target_order = selected_order + select_dir;</span>

            // Skip tab item buttons until another tab item is found or end is reached
<span style = "background-color:#fdd">            while (tab_to_scroll_to == NULL)</span>
            {
                // If we are at the end of the list, still scroll to make our tab visible
<span style = "background-color:#fdd">                tab_to_scroll_to = &amp;tab_bar-&gt;Tabs[(target_order &gt;= 0 &amp;&amp; target_order &lt; tab_bar-&gt;Tabs.Size) ? target_order : selected_order];</span>

                // Cross through buttons
                // (even if first/last item is a button, return it so we can update the scroll)
<span style = "background-color:#fdd">                if (tab_to_scroll_to-&gt;Flags &amp; ImGuiTabItemFlags_Button)</span>
                {
<span style = "background-color:#fdd">                    target_order += select_dir;
                    selected_order += select_dir;
                    tab_to_scroll_to = (target_order &lt; 0 || target_order &gt;= tab_bar-&gt;Tabs.Size) ? tab_to_scroll_to : NULL;</span>
                }
<span style = "background-color:#fdd">            }</span>
        }
<span style = "background-color:#fdd">    window-&gt;DC.CursorPos = backup_cursor_pos;
    tab_bar-&gt;BarRect.Max.x -= scrolling_buttons_width + 1.0f;</span>

<span style = "background-color:#fdd">    return tab_to_scroll_to;
}</span>

static ImGuiTabItem* ImGui::TabBarTabListPopupButton(ImGuiTabBar* tab_bar)
<span style = "background-color:#fdd">{
    ImGuiContext&amp; g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;</span>

    // We use g.Style.FramePadding.y to match the square ArrowButton size
<span style = "background-color:#fdd">    const float tab_list_popup_button_width = g.FontSize + g.Style.FramePadding.y;
    const ImVec2 backup_cursor_pos = window-&gt;DC.CursorPos;
    window-&gt;DC.CursorPos = ImVec2(tab_bar-&gt;BarRect.Min.x - g.Style.FramePadding.y, tab_bar-&gt;BarRect.Min.y);
    tab_bar-&gt;BarRect.Min.x += tab_list_popup_button_width;</span>

<span style = "background-color:#fdd">    ImVec4 arrow_col = g.Style.Colors[ImGuiCol_Text];
    arrow_col.w *= 0.5f;
    PushStyleColor(ImGuiCol_Text, arrow_col);
    PushStyleColor(ImGuiCol_Button, ImVec4(0, 0, 0, 0));
    bool open = BeginCombo("##v", NULL, ImGuiComboFlags_NoPreview | ImGuiComboFlags_HeightLargest);
    PopStyleColor(2);</span>

<span style = "background-color:#fdd">    ImGuiTabItem* tab_to_select = NULL;
    if (open)</span>
    {
<span style = "background-color:#fdd">        for (int tab_n = 0; tab_n &lt; tab_bar-&gt;Tabs.Size; tab_n++)</span>
        {
<span style = "background-color:#fdd">            ImGuiTabItem* tab = &amp;tab_bar-&gt;Tabs[tab_n];
            if (tab-&gt;Flags &amp; ImGuiTabItemFlags_Button)
                continue;</span>

<span style = "background-color:#fdd">            const char* tab_name = tab_bar-&gt;GetTabName(tab);
            if (Selectable(tab_name, tab_bar-&gt;SelectedTabId == tab-&gt;ID))
                tab_to_select = tab;
        }
        EndCombo();</span>
    }

<span style = "background-color:#fdd">    window-&gt;DC.CursorPos = backup_cursor_pos;
    return tab_to_select;
}</span>

//-------------------------------------------------------------------------
// [SECTION] Widgets: BeginTabItem, EndTabItem, etc.
//-------------------------------------------------------------------------
// - BeginTabItem()
// - EndTabItem()
// - TabItemButton()
// - TabItemEx() [Internal]
// - SetTabItemClosed()
// - TabItemCalcSize() [Internal]
// - TabItemBackground() [Internal]
// - TabItemLabelAndCloseButton() [Internal]
//-------------------------------------------------------------------------

bool    ImGui::BeginTabItem(const char* label, bool* p_open, ImGuiTabItemFlags flags)
<span style = "background-color:#fdd">{
    ImGuiContext&amp; g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (window-&gt;SkipItems)
        return false;</span>

<span style = "background-color:#fdd">    ImGuiTabBar* tab_bar = g.CurrentTabBar;
    if (tab_bar == NULL)</span>
    {
<span style = "background-color:#fdd">        IM_ASSERT_USER_ERROR(tab_bar, "Needs to be called between BeginTabBar() and EndTabBar()!");
        return false;</span>
    }
<span style = "background-color:#fdd">    IM_ASSERT(!(flags &amp; ImGuiTabItemFlags_Button)); // BeginTabItem() Can't be used with button flags, use TabItemButton() instead!</span>

<span style = "background-color:#fdd">    bool ret = TabItemEx(tab_bar, label, p_open, flags);
    if (ret &amp;&amp; !(flags &amp; ImGuiTabItemFlags_NoPushId))</span>
    {
<span style = "background-color:#fdd">        ImGuiTabItem* tab = &amp;tab_bar-&gt;Tabs[tab_bar-&gt;LastTabItemIdx];
        PushOverrideID(tab-&gt;ID); // We already hashed 'label' so push into the ID stack directly instead of doing another hash through PushID(label)</span>
    }
<span style = "background-color:#fdd">    return ret;
}</span>

void    ImGui::EndTabItem()
<span style = "background-color:#fdd">{
    ImGuiContext&amp; g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (window-&gt;SkipItems)
        return;</span>

<span style = "background-color:#fdd">    ImGuiTabBar* tab_bar = g.CurrentTabBar;
    if (tab_bar == NULL)</span>
    {
<span style = "background-color:#fdd">        IM_ASSERT_USER_ERROR(tab_bar != NULL, "Needs to be called between BeginTabBar() and EndTabBar()!");
        return;</span>
    }
<span style = "background-color:#fdd">    IM_ASSERT(tab_bar-&gt;LastTabItemIdx &gt;= 0);
    ImGuiTabItem* tab = &amp;tab_bar-&gt;Tabs[tab_bar-&gt;LastTabItemIdx];
    if (!(tab-&gt;Flags &amp; ImGuiTabItemFlags_NoPushId))
        PopID();
}</span>

bool    ImGui::TabItemButton(const char* label, ImGuiTabItemFlags flags)
<span style = "background-color:#fdd">{
    ImGuiContext&amp; g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (window-&gt;SkipItems)
        return false;</span>

<span style = "background-color:#fdd">    ImGuiTabBar* tab_bar = g.CurrentTabBar;
    if (tab_bar == NULL)</span>
    {
<span style = "background-color:#fdd">        IM_ASSERT_USER_ERROR(tab_bar != NULL, "Needs to be called between BeginTabBar() and EndTabBar()!");
        return false;</span>
    }
<span style = "background-color:#fdd">    return TabItemEx(tab_bar, label, NULL, flags | ImGuiTabItemFlags_Button | ImGuiTabItemFlags_NoReorder);
}</span>

bool    ImGui::TabItemEx(ImGuiTabBar* tab_bar, const char* label, bool* p_open, ImGuiTabItemFlags flags)
<span style = "background-color:#fdd">{</span>
    // Layout whole tab bar if not already done
<span style = "background-color:#fdd">    if (tab_bar-&gt;WantLayout)
        TabBarLayout(tab_bar);</span>

<span style = "background-color:#fdd">    ImGuiContext&amp; g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (window-&gt;SkipItems)
        return false;</span>

<span style = "background-color:#fdd">    const ImGuiStyle&amp; style = g.Style;
    const ImGuiID id = TabBarCalcTabID(tab_bar, label);</span>

    // If the user called us with *p_open == false, we early out and don't render.
    // We make a call to ItemAdd() so that attempts to use a contextual popup menu with an implicit ID won't use an older ID.
    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags);
<span style = "background-color:#fdd">    if (p_open &amp;&amp; !*p_open)</span>
    {
<span style = "background-color:#fdd">        ItemAdd(ImRect(), id, NULL, ImGuiItemFlags_NoNav | ImGuiItemFlags_NoNavDefaultFocus);
        return false;</span>
    }

<span style = "background-color:#fdd">    IM_ASSERT(!p_open || !(flags &amp; ImGuiTabItemFlags_Button));
    IM_ASSERT((flags &amp; (ImGuiTabItemFlags_Leading | ImGuiTabItemFlags_Trailing)) != (ImGuiTabItemFlags_Leading | ImGuiTabItemFlags_Trailing)); // Can't use both Leading and Trailing</span>

    // Store into ImGuiTabItemFlags_NoCloseButton, also honor ImGuiTabItemFlags_NoCloseButton passed by user (although not documented)
<span style = "background-color:#fdd">    if (flags &amp; ImGuiTabItemFlags_NoCloseButton)
        p_open = NULL;
    else if (p_open == NULL)
        flags |= ImGuiTabItemFlags_NoCloseButton;</span>

    // Calculate tab contents size
<span style = "background-color:#fdd">    ImVec2 size = TabItemCalcSize(label, p_open != NULL);</span>

    // Acquire tab data
<span style = "background-color:#fdd">    ImGuiTabItem* tab = TabBarFindTabByID(tab_bar, id);
    bool tab_is_new = false;
    if (tab == NULL)</span>
    {
<span style = "background-color:#fdd">        tab_bar-&gt;Tabs.push_back(ImGuiTabItem());
        tab = &amp;tab_bar-&gt;Tabs.back();
        tab-&gt;ID = id;
        tab-&gt;Width = size.x;
        tab_bar-&gt;TabsAddedNew = true;
        tab_is_new = true;</span>
    }
<span style = "background-color:#fdd">    tab_bar-&gt;LastTabItemIdx = (ImS16)tab_bar-&gt;Tabs.index_from_ptr(tab);
    tab-&gt;ContentWidth = size.x;
    tab-&gt;BeginOrder = tab_bar-&gt;TabsActiveCount++;</span>

<span style = "background-color:#fdd">    const bool tab_bar_appearing = (tab_bar-&gt;PrevFrameVisible + 1 &lt; g.FrameCount);
    const bool tab_bar_focused = (tab_bar-&gt;Flags &amp; ImGuiTabBarFlags_IsFocused) != 0;
    const bool tab_appearing = (tab-&gt;LastFrameVisible + 1 &lt; g.FrameCount);
    const bool is_tab_button = (flags &amp; ImGuiTabItemFlags_Button) != 0;
    tab-&gt;LastFrameVisible = g.FrameCount;
    tab-&gt;Flags = flags;</span>

    // Append name with zero-terminator
<span style = "background-color:#fdd">    tab-&gt;NameOffset = (ImS32)tab_bar-&gt;TabsNames.size();
    tab_bar-&gt;TabsNames.append(label, label + strlen(label) + 1);</span>

    // Update selected tab
<span style = "background-color:#fdd">    if (tab_appearing &amp;&amp; (tab_bar-&gt;Flags &amp; ImGuiTabBarFlags_AutoSelectNewTabs) &amp;&amp; tab_bar-&gt;NextSelectedTabId == 0)
        if (!tab_bar_appearing || tab_bar-&gt;SelectedTabId == 0)
            if (!is_tab_button)
                tab_bar-&gt;NextSelectedTabId = id;  // New tabs gets activated
    if ((flags &amp; ImGuiTabItemFlags_SetSelected) &amp;&amp; (tab_bar-&gt;SelectedTabId != id)) // SetSelected can only be passed on explicit tab bar
        if (!is_tab_button)
            tab_bar-&gt;NextSelectedTabId = id;</span>

    // Lock visibility
    // (Note: tab_contents_visible != tab_selected... because CTRL+TAB operations may preview some tabs without selecting them!)
<span style = "background-color:#fdd">    bool tab_contents_visible = (tab_bar-&gt;VisibleTabId == id);
    if (tab_contents_visible)
        tab_bar-&gt;VisibleTabWasSubmitted = true;</span>

    // On the very first frame of a tab bar we let first tab contents be visible to minimize appearing glitches
<span style = "background-color:#fdd">    if (!tab_contents_visible &amp;&amp; tab_bar-&gt;SelectedTabId == 0 &amp;&amp; tab_bar_appearing)
        if (tab_bar-&gt;Tabs.Size == 1 &amp;&amp; !(tab_bar-&gt;Flags &amp; ImGuiTabBarFlags_AutoSelectNewTabs))
            tab_contents_visible = true;</span>

    // Note that tab_is_new is not necessarily the same as tab_appearing! When a tab bar stops being submitted
    // and then gets submitted again, the tabs will have 'tab_appearing=true' but 'tab_is_new=false'.
<span style = "background-color:#fdd">    if (tab_appearing &amp;&amp; (!tab_bar_appearing || tab_is_new))</span>
    {
<span style = "background-color:#fdd">        ItemAdd(ImRect(), id, NULL, ImGuiItemFlags_NoNav | ImGuiItemFlags_NoNavDefaultFocus);
        if (is_tab_button)
            return false;
        return tab_contents_visible;</span>
    }

<span style = "background-color:#fdd">    if (tab_bar-&gt;SelectedTabId == id)
        tab-&gt;LastFrameSelected = g.FrameCount;</span>

    // Backup current layout position
<span style = "background-color:#fdd">    const ImVec2 backup_main_cursor_pos = window-&gt;DC.CursorPos;</span>

    // Layout
<span style = "background-color:#fdd">    const bool is_central_section = (tab-&gt;Flags &amp; ImGuiTabItemFlags_SectionMask_) == 0;
    size.x = tab-&gt;Width;
    if (is_central_section)
        window-&gt;DC.CursorPos = tab_bar-&gt;BarRect.Min + ImVec2(IM_FLOOR(tab-&gt;Offset - tab_bar-&gt;ScrollingAnim), 0.0f);</span>
    else
<span style = "background-color:#fdd">        window-&gt;DC.CursorPos = tab_bar-&gt;BarRect.Min + ImVec2(tab-&gt;Offset, 0.0f);
    ImVec2 pos = window-&gt;DC.CursorPos;
    ImRect bb(pos, pos + size);</span>

    // We don't have CPU clipping primitives to clip the CloseButton (until it becomes a texture), so need to add an extra draw call (temporary in the case of vertical animation)
<span style = "background-color:#fdd">    const bool want_clip_rect = is_central_section &amp;&amp; (bb.Min.x &lt; tab_bar-&gt;ScrollingRectMinX || bb.Max.x &gt; tab_bar-&gt;ScrollingRectMaxX);
    if (want_clip_rect)
        PushClipRect(ImVec2(ImMax(bb.Min.x, tab_bar-&gt;ScrollingRectMinX), bb.Min.y - 1), ImVec2(tab_bar-&gt;ScrollingRectMaxX, bb.Max.y), true);</span>

<span style = "background-color:#fdd">    ImVec2 backup_cursor_max_pos = window-&gt;DC.CursorMaxPos;
    ItemSize(bb.GetSize(), style.FramePadding.y);
    window-&gt;DC.CursorMaxPos = backup_cursor_max_pos;</span>

<span style = "background-color:#fdd">    if (!ItemAdd(bb, id))</span>
    {
<span style = "background-color:#fdd">        if (want_clip_rect)
            PopClipRect();
        window-&gt;DC.CursorPos = backup_main_cursor_pos;
        return tab_contents_visible;</span>
    }

    // Click to Select a tab
<span style = "background-color:#fdd">    ImGuiButtonFlags button_flags = ((is_tab_button ? ImGuiButtonFlags_PressedOnClickRelease : ImGuiButtonFlags_PressedOnClick) | ImGuiButtonFlags_AllowItemOverlap);
    if (g.DragDropActive)
        button_flags |= ImGuiButtonFlags_PressedOnDragDropHold;</span>
    bool hovered, held;
<span style = "background-color:#fdd">    bool pressed = ButtonBehavior(bb, id, &amp;hovered, &amp;held, button_flags);
    if (pressed &amp;&amp; !is_tab_button)
        tab_bar-&gt;NextSelectedTabId = id;</span>

    // Allow the close button to overlap unless we are dragging (in which case we don't want any overlapping tabs to be hovered)
<span style = "background-color:#fdd">    if (g.ActiveId != id)
        SetItemAllowOverlap();</span>

    // Drag and drop: re-order tabs
<span style = "background-color:#fdd">    if (held &amp;&amp; !tab_appearing &amp;&amp; IsMouseDragging(0))</span>
    {
<span style = "background-color:#fdd">        if (!g.DragDropActive &amp;&amp; (tab_bar-&gt;Flags &amp; ImGuiTabBarFlags_Reorderable))</span>
        {
            // While moving a tab it will jump on the other side of the mouse, so we also test for MouseDelta.x
<span style = "background-color:#fdd">            if (g.IO.MouseDelta.x &lt; 0.0f &amp;&amp; g.IO.MousePos.x &lt; bb.Min.x)</span>
            {
<span style = "background-color:#fdd">                TabBarQueueReorderFromMousePos(tab_bar, tab, g.IO.MousePos);
            }
            else if (g.IO.MouseDelta.x &gt; 0.0f &amp;&amp; g.IO.MousePos.x &gt; bb.Max.x)</span>
            {
<span style = "background-color:#fdd">                TabBarQueueReorderFromMousePos(tab_bar, tab, g.IO.MousePos);</span>
            }
        }
    }

#if 0
    if (hovered &amp;&amp; g.HoveredIdNotActiveTimer &gt; TOOLTIP_DELAY &amp;&amp; bb.GetWidth() &lt; tab-&gt;ContentWidth)
    {
        // Enlarge tab display when hovering
        bb.Max.x = bb.Min.x + IM_FLOOR(ImLerp(bb.GetWidth(), tab-&gt;ContentWidth, ImSaturate((g.HoveredIdNotActiveTimer - 0.40f) * 6.0f)));
        display_draw_list = GetForegroundDrawList(window);
        TabItemBackground(display_draw_list, bb, flags, GetColorU32(ImGuiCol_TitleBgActive));
    }
#endif

    // Render tab shape
<span style = "background-color:#fdd">    ImDrawList* display_draw_list = window-&gt;DrawList;
    const ImU32 tab_col = GetColorU32((held || hovered) ? ImGuiCol_TabHovered : tab_contents_visible ? (tab_bar_focused ? ImGuiCol_TabActive : ImGuiCol_TabUnfocusedActive) : (tab_bar_focused ? ImGuiCol_Tab : ImGuiCol_TabUnfocused));
    TabItemBackground(display_draw_list, bb, flags, tab_col);
    RenderNavHighlight(bb, id);</span>

    // Select with right mouse button. This is so the common idiom for context menu automatically highlight the current widget.
<span style = "background-color:#fdd">    const bool hovered_unblocked = IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup);
    if (hovered_unblocked &amp;&amp; (IsMouseClicked(1) || IsMouseReleased(1)))
        if (!is_tab_button)
            tab_bar-&gt;NextSelectedTabId = id;</span>

<span style = "background-color:#fdd">    if (tab_bar-&gt;Flags &amp; ImGuiTabBarFlags_NoCloseWithMiddleMouseButton)
        flags |= ImGuiTabItemFlags_NoCloseWithMiddleMouseButton;</span>

    // Render tab label, process close button
<span style = "background-color:#fdd">    const ImGuiID close_button_id = p_open ? GetIDWithSeed("#CLOSE", NULL, id) : 0;</span>
    bool just_closed;
    bool text_clipped;
<span style = "background-color:#fdd">    TabItemLabelAndCloseButton(display_draw_list, bb, flags, tab_bar-&gt;FramePadding, label, id, close_button_id, tab_contents_visible, &amp;just_closed, &amp;text_clipped);
    if (just_closed &amp;&amp; p_open != NULL)</span>
    {
<span style = "background-color:#fdd">        *p_open = false;
        TabBarCloseTab(tab_bar, tab);</span>
    }

    // Restore main window position so user can draw there
<span style = "background-color:#fdd">    if (want_clip_rect)
        PopClipRect();
    window-&gt;DC.CursorPos = backup_main_cursor_pos;</span>

    // Tooltip
    // (Won't work over the close button because ItemOverlap systems messes up with HoveredIdTimer-&gt; seems ok)
    // (We test IsItemHovered() to discard e.g. when another item is active or drag and drop over the tab bar, which g.HoveredId ignores)
    // FIXME: This is a mess.
    // FIXME: We may want disabled tab to still display the tooltip?
<span style = "background-color:#fdd">    if (text_clipped &amp;&amp; g.HoveredId == id &amp;&amp; !held &amp;&amp; g.HoveredIdNotActiveTimer &gt; g.TooltipSlowDelay &amp;&amp; IsItemHovered())
        if (!(tab_bar-&gt;Flags &amp; ImGuiTabBarFlags_NoTooltip) &amp;&amp; !(tab-&gt;Flags &amp; ImGuiTabItemFlags_NoTooltip))
            SetTooltip("%.*s", (int)(FindRenderedTextEnd(label) - label), label);</span>

<span style = "background-color:#fdd">    IM_ASSERT(!is_tab_button || !(tab_bar-&gt;SelectedTabId == tab-&gt;ID &amp;&amp; is_tab_button)); // TabItemButton should not be selected
    if (is_tab_button)
        return pressed;
    return tab_contents_visible;
}</span>

// [Public] This is call is 100% optional but it allows to remove some one-frame glitches when a tab has been unexpectedly removed.
// To use it to need to call the function SetTabItemClosed() between BeginTabBar() and EndTabBar().
// Tabs closed by the close button will automatically be flagged to avoid this issue.
void    ImGui::SetTabItemClosed(const char* label)
<span style = "background-color:#fdd">{
    ImGuiContext&amp; g = *GImGui;
    bool is_within_manual_tab_bar = g.CurrentTabBar &amp;&amp; !(g.CurrentTabBar-&gt;Flags &amp; ImGuiTabBarFlags_DockNode);
    if (is_within_manual_tab_bar)</span>
    {
<span style = "background-color:#fdd">        ImGuiTabBar* tab_bar = g.CurrentTabBar;
        ImGuiID tab_id = TabBarCalcTabID(tab_bar, label);
        if (ImGuiTabItem* tab = TabBarFindTabByID(tab_bar, tab_id))
            tab-&gt;WantClose = true; // Will be processed by next call to TabBarLayout()</span>
    }
<span style = "background-color:#fdd">}</span>

ImVec2 ImGui::TabItemCalcSize(const char* label, bool has_close_button)
<span style = "background-color:#fdd">{
    ImGuiContext&amp; g = *GImGui;
    ImVec2 label_size = CalcTextSize(label, NULL, true);
    ImVec2 size = ImVec2(label_size.x + g.Style.FramePadding.x, label_size.y + g.Style.FramePadding.y * 2.0f);
    if (has_close_button)
        size.x += g.Style.FramePadding.x + (g.Style.ItemInnerSpacing.x + g.FontSize); // We use Y intentionally to fit the close button circle.</span>
    else
<span style = "background-color:#fdd">        size.x += g.Style.FramePadding.x + 1.0f;
    return ImVec2(ImMin(size.x, TabBarCalcMaxTabWidth()), size.y);
}</span>

void ImGui::TabItemBackground(ImDrawList* draw_list, const ImRect&amp; bb, ImGuiTabItemFlags flags, ImU32 col)
<span style = "background-color:#fdd">{</span>
    // While rendering tabs, we trim 1 pixel off the top of our bounding box so they can fit within a regular frame height while looking "detached" from it.
<span style = "background-color:#fdd">    ImGuiContext&amp; g = *GImGui;
    const float width = bb.GetWidth();</span>
    IM_UNUSED(flags);
<span style = "background-color:#fdd">    IM_ASSERT(width &gt; 0.0f);
    const float rounding = ImMax(0.0f, ImMin((flags &amp; ImGuiTabItemFlags_Button) ? g.Style.FrameRounding : g.Style.TabRounding, width * 0.5f - 1.0f));
    const float y1 = bb.Min.y + 1.0f;
    const float y2 = bb.Max.y - 1.0f;
    draw_list-&gt;PathLineTo(ImVec2(bb.Min.x, y2));
    draw_list-&gt;PathArcToFast(ImVec2(bb.Min.x + rounding, y1 + rounding), rounding, 6, 9);
    draw_list-&gt;PathArcToFast(ImVec2(bb.Max.x - rounding, y1 + rounding), rounding, 9, 12);
    draw_list-&gt;PathLineTo(ImVec2(bb.Max.x, y2));
    draw_list-&gt;PathFillConvex(col);
    if (g.Style.TabBorderSize &gt; 0.0f)</span>
    {
<span style = "background-color:#fdd">        draw_list-&gt;PathLineTo(ImVec2(bb.Min.x + 0.5f, y2));
        draw_list-&gt;PathArcToFast(ImVec2(bb.Min.x + rounding + 0.5f, y1 + rounding + 0.5f), rounding, 6, 9);
        draw_list-&gt;PathArcToFast(ImVec2(bb.Max.x - rounding - 0.5f, y1 + rounding + 0.5f), rounding, 9, 12);
        draw_list-&gt;PathLineTo(ImVec2(bb.Max.x - 0.5f, y2));
        draw_list-&gt;PathStroke(GetColorU32(ImGuiCol_Border), 0, g.Style.TabBorderSize);</span>
    }
<span style = "background-color:#fdd">}</span>

// Render text label (with custom clipping) + Unsaved Document marker + Close Button logic
// We tend to lock style.FramePadding for a given tab-bar, hence the 'frame_padding' parameter.
void ImGui::TabItemLabelAndCloseButton(ImDrawList* draw_list, const ImRect&amp; bb, ImGuiTabItemFlags flags, ImVec2 frame_padding, const char* label, ImGuiID tab_id, ImGuiID close_button_id, bool is_contents_visible, bool* out_just_closed, bool* out_text_clipped)
<span style = "background-color:#fdd">{
    ImGuiContext&amp; g = *GImGui;
    ImVec2 label_size = CalcTextSize(label, NULL, true);</span>

<span style = "background-color:#fdd">    if (out_just_closed)
        *out_just_closed = false;
    if (out_text_clipped)
        *out_text_clipped = false;</span>

<span style = "background-color:#fdd">    if (bb.GetWidth() &lt;= 1.0f)
        return;</span>

    // In Style V2 we'll have full override of all colors per state (e.g. focused, selected)
    // But right now if you want to alter text color of tabs this is what you need to do.
#if 0
    const float backup_alpha = g.Style.Alpha;
    if (!is_contents_visible)
        g.Style.Alpha *= 0.7f;
#endif

    // Render text label (with clipping + alpha gradient) + unsaved marker
<span style = "background-color:#fdd">    ImRect text_pixel_clip_bb(bb.Min.x + frame_padding.x, bb.Min.y + frame_padding.y, bb.Max.x - frame_padding.x, bb.Max.y);
    ImRect text_ellipsis_clip_bb = text_pixel_clip_bb;</span>

    // Return clipped state ignoring the close button
<span style = "background-color:#fdd">    if (out_text_clipped)</span>
    {
<span style = "background-color:#fdd">        *out_text_clipped = (text_ellipsis_clip_bb.Min.x + label_size.x) &gt; text_pixel_clip_bb.Max.x;</span>
        //draw_list-&gt;AddCircle(text_ellipsis_clip_bb.Min, 3.0f, *out_text_clipped ? IM_COL32(255, 0, 0, 255) : IM_COL32(0, 255, 0, 255));
    }

<span style = "background-color:#fdd">    const float button_sz = g.FontSize;
    const ImVec2 button_pos(ImMax(bb.Min.x, bb.Max.x - frame_padding.x * 2.0f - button_sz), bb.Min.y);</span>

    // Close Button &amp; Unsaved Marker
    // We are relying on a subtle and confusing distinction between 'hovered' and 'g.HoveredId' which happens because we are using ImGuiButtonFlags_AllowOverlapMode + SetItemAllowOverlap()
    //  'hovered' will be true when hovering the Tab but NOT when hovering the close button
    //  'g.HoveredId==id' will be true when hovering the Tab including when hovering the close button
    //  'g.ActiveId==close_button_id' will be true when we are holding on the close button, in which case both hovered booleans are false
<span style = "background-color:#fdd">    bool close_button_pressed = false;
    bool close_button_visible = false;
    if (close_button_id != 0)
        if (is_contents_visible || bb.GetWidth() &gt;= ImMax(button_sz, g.Style.TabMinWidthForCloseButton))
            if (g.HoveredId == tab_id || g.HoveredId == close_button_id || g.ActiveId == tab_id || g.ActiveId == close_button_id)
                close_button_visible = true;
    bool unsaved_marker_visible = (flags &amp; ImGuiTabItemFlags_UnsavedDocument) != 0 &amp;&amp; (button_pos.x + button_sz &lt;= bb.Max.x);</span>

<span style = "background-color:#fdd">    if (close_button_visible)</span>
    {
<span style = "background-color:#fdd">        ImGuiLastItemData last_item_backup = g.LastItemData;
        PushStyleVar(ImGuiStyleVar_FramePadding, frame_padding);
        if (CloseButton(close_button_id, button_pos))
            close_button_pressed = true;
        PopStyleVar();
        g.LastItemData = last_item_backup;</span>

        // Close with middle mouse button
<span style = "background-color:#fdd">        if (!(flags &amp; ImGuiTabItemFlags_NoCloseWithMiddleMouseButton) &amp;&amp; IsMouseClicked(2))
            close_button_pressed = true;
    }
    else if (unsaved_marker_visible)</span>
    {
<span style = "background-color:#fdd">        const ImRect bullet_bb(button_pos, button_pos + ImVec2(button_sz, button_sz) + g.Style.FramePadding * 2.0f);
        RenderBullet(draw_list, bullet_bb.GetCenter(), GetColorU32(ImGuiCol_Text));</span>
    }

    // This is all rather complicated
    // (the main idea is that because the close button only appears on hover, we don't want it to alter the ellipsis position)
    // FIXME: if FramePadding is noticeably large, ellipsis_max_x will be wrong here (e.g. #3497), maybe for consistency that parameter of RenderTextEllipsis() shouldn't exist..
<span style = "background-color:#fdd">    float ellipsis_max_x = close_button_visible ? text_pixel_clip_bb.Max.x : bb.Max.x - 1.0f;
    if (close_button_visible || unsaved_marker_visible)</span>
    {
<span style = "background-color:#fdd">        text_pixel_clip_bb.Max.x -= close_button_visible ? (button_sz) : (button_sz * 0.80f);
        text_ellipsis_clip_bb.Max.x -= unsaved_marker_visible ? (button_sz * 0.80f) : 0.0f;
        ellipsis_max_x = text_pixel_clip_bb.Max.x;</span>
    }
<span style = "background-color:#fdd">    RenderTextEllipsis(draw_list, text_ellipsis_clip_bb.Min, text_ellipsis_clip_bb.Max, text_pixel_clip_bb.Max.x, ellipsis_max_x, label, NULL, &amp;label_size);</span>

#if 0
    if (!is_contents_visible)
        g.Style.Alpha = backup_alpha;
#endif

<span style = "background-color:#fdd">    if (out_just_closed)
        *out_just_closed = close_button_pressed;
}</span>


#endif // #ifndef IMGUI_DISABLE</pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>