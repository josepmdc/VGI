<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>nodebuilder.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
#include &lt;cassert&gt;

#include "nodebuilder.h"
#include "yaml-cpp/node/detail/node.h"
#include "yaml-cpp/node/impl.h"
#include "yaml-cpp/node/node.h"
#include "yaml-cpp/node/type.h"

namespace YAML {
struct Mark;

NodeBuilder::NodeBuilder()
<span style = "background-color:#dfd">    : m_pMemory(new detail::memory_holder),
      m_pRoot(nullptr),
      m_stack{},
      m_anchors{},
      m_keys{},
      m_mapDepth(0) {
  m_anchors.push_back(nullptr);  // since the anchors start at 1
}</span>

<span style = "background-color:#dfd">NodeBuilder::~NodeBuilder() = default;</span>

<span style = "background-color:#dfd">Node NodeBuilder::Root() {
  if (!m_pRoot)</span>
<span style = "background-color:#fdd">    return Node();</span>

<span style = "background-color:#dfd">  return Node(*m_pRoot, m_pMemory);
}</span>

<span style = "background-color:#dfd">void NodeBuilder::OnDocumentStart(const Mark&amp;) {}</span>

<span style = "background-color:#dfd">void NodeBuilder::OnDocumentEnd() {}</span>

<span style = "background-color:#fdd">void NodeBuilder::OnNull(const Mark&amp; mark, anchor_t anchor) {
  detail::node&amp; node = Push(mark, anchor);
  node.set_null();
  Pop();
}</span>

<span style = "background-color:#fdd">void NodeBuilder::OnAlias(const Mark&amp; /* mark */, anchor_t anchor) {
  detail::node&amp; node = *m_anchors[anchor];
  Push(node);
  Pop();
}</span>

void NodeBuilder::OnScalar(const Mark&amp; mark, const std::string&amp; tag,
<span style = "background-color:#dfd">                           anchor_t anchor, const std::string&amp; value) {
  detail::node&amp; node = Push(mark, anchor);
  node.set_scalar(value);
  node.set_tag(tag);
  Pop();
}</span>

void NodeBuilder::OnSequenceStart(const Mark&amp; mark, const std::string&amp; tag,
<span style = "background-color:#dfd">                                  anchor_t anchor, EmitterStyle::value style) {
  detail::node&amp; node = Push(mark, anchor);
  node.set_tag(tag);
  node.set_type(NodeType::Sequence);
  node.set_style(style);
}</span>

<span style = "background-color:#dfd">void NodeBuilder::OnSequenceEnd() { Pop(); }</span>

void NodeBuilder::OnMapStart(const Mark&amp; mark, const std::string&amp; tag,
<span style = "background-color:#dfd">                             anchor_t anchor, EmitterStyle::value style) {
  detail::node&amp; node = Push(mark, anchor);
  node.set_type(NodeType::Map);
  node.set_tag(tag);
  node.set_style(style);
  m_mapDepth++;
}</span>

<span style = "background-color:#dfd">void NodeBuilder::OnMapEnd() {
  assert(m_mapDepth &gt; 0);
  m_mapDepth--;
  Pop();
}</span>

<span style = "background-color:#dfd">detail::node&amp; NodeBuilder::Push(const Mark&amp; mark, anchor_t anchor) {
  detail::node&amp; node = m_pMemory-&gt;create_node();
  node.set_mark(mark);
  RegisterAnchor(anchor, node);
  Push(node);
  return node;
}</span>

<span style = "background-color:#dfd">void NodeBuilder::Push(detail::node&amp; node) {
  const bool needsKey =</span>
      (!m_stack.empty() &amp;&amp; m_stack.back()-&gt;type() == NodeType::Map &amp;&amp;
       m_keys.size() &lt; m_mapDepth);

<span style = "background-color:#dfd">  m_stack.push_back(&amp;node);
  if (needsKey)
    m_keys.emplace_back(&amp;node, false);
}</span>

<span style = "background-color:#dfd">void NodeBuilder::Pop() {
  assert(!m_stack.empty());
  if (m_stack.size() == 1) {
    m_pRoot = m_stack[0];
    m_stack.pop_back();
    return;</span>
  }

<span style = "background-color:#dfd">  detail::node&amp; node = *m_stack.back();
  m_stack.pop_back();</span>

<span style = "background-color:#dfd">  detail::node&amp; collection = *m_stack.back();</span>

<span style = "background-color:#dfd">  if (collection.type() == NodeType::Sequence) {
    collection.push_back(node, m_pMemory);
  } else if (collection.type() == NodeType::Map) {
    assert(!m_keys.empty());
    PushedKey&amp; key = m_keys.back();
    if (key.second) {
      collection.insert(*key.first, node, m_pMemory);
      m_keys.pop_back();
    } else {
      key.second = true;</span>
    }
<span style = "background-color:#dfd">  } else {</span>
<span style = "background-color:#fdd">    assert(false);
    m_stack.clear();</span>
  }
<span style = "background-color:#dfd">}</span>

<span style = "background-color:#dfd">void NodeBuilder::RegisterAnchor(anchor_t anchor, detail::node&amp; node) {
  if (anchor) {</span>
<span style = "background-color:#fdd">    assert(anchor == m_anchors.size());
    m_anchors.push_back(&amp;node);</span>
  }
<span style = "background-color:#dfd">}</span>
}  // namespace YAML</pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>