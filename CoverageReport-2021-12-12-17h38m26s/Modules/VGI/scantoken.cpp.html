<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>scantoken.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
#include &lt;sstream&gt;

#include "exp.h"
#include "regex_yaml.h"
#include "regeximpl.h"
#include "scanner.h"
#include "scanscalar.h"
#include "scantag.h"  // IWYU pragma: keep
#include "tag.h"      // IWYU pragma: keep
#include "token.h"
#include "yaml-cpp/exceptions.h"  // IWYU pragma: keep
#include "yaml-cpp/mark.h"

namespace YAML {
///////////////////////////////////////////////////////////////////////
// Specialization for scanning specific tokens

// Directive
// . Note: no semantic checking is done here (that's for the parser to do)
<span style = "background-color:#fdd">void Scanner::ScanDirective() {
  std::string name;
  std::vector&lt;std::string&gt; params;</span>

  // pop indents and simple keys
<span style = "background-color:#fdd">  PopAllIndents();
  PopAllSimpleKeys();</span>

<span style = "background-color:#fdd">  m_simpleKeyAllowed = false;
  m_canBeJSONFlow = false;</span>

  // store pos and eat indicator
<span style = "background-color:#fdd">  Token token(Token::DIRECTIVE, INPUT.mark());
  INPUT.eat(1);</span>

  // read name
<span style = "background-color:#fdd">  while (INPUT &amp;&amp; !Exp::BlankOrBreak().Matches(INPUT))
    token.value += INPUT.get();</span>

  // read parameters
<span style = "background-color:#fdd">  while (true) {</span>
    // first get rid of whitespace
<span style = "background-color:#fdd">    while (Exp::Blank().Matches(INPUT))
      INPUT.eat(1);</span>

    // break on newline or comment
<span style = "background-color:#fdd">    if (!INPUT || Exp::Break().Matches(INPUT) || Exp::Comment().Matches(INPUT))
      break;</span>

    // now read parameter
<span style = "background-color:#fdd">    std::string param;
    while (INPUT &amp;&amp; !Exp::BlankOrBreak().Matches(INPUT))
      param += INPUT.get();</span>

<span style = "background-color:#fdd">    token.params.push_back(param);
  }</span>

<span style = "background-color:#fdd">  m_tokens.push(token);
}</span>

// DocStart
<span style = "background-color:#fdd">void Scanner::ScanDocStart() {
  PopAllIndents();
  PopAllSimpleKeys();
  m_simpleKeyAllowed = false;
  m_canBeJSONFlow = false;</span>

  // eat
<span style = "background-color:#fdd">  Mark mark = INPUT.mark();
  INPUT.eat(3);
  m_tokens.push(Token(Token::DOC_START, mark));
}</span>

// DocEnd
<span style = "background-color:#fdd">void Scanner::ScanDocEnd() {
  PopAllIndents();
  PopAllSimpleKeys();
  m_simpleKeyAllowed = false;
  m_canBeJSONFlow = false;</span>

  // eat
<span style = "background-color:#fdd">  Mark mark = INPUT.mark();
  INPUT.eat(3);
  m_tokens.push(Token(Token::DOC_END, mark));
}</span>

// FlowStart
<span style = "background-color:#dfd">void Scanner::ScanFlowStart() {</span>
  // flows can be simple keys
<span style = "background-color:#dfd">  InsertPotentialSimpleKey();
  m_simpleKeyAllowed = true;
  m_canBeJSONFlow = false;</span>

  // eat
<span style = "background-color:#dfd">  Mark mark = INPUT.mark();
  char ch = INPUT.get();
  FLOW_MARKER flowType = (ch == Keys::FlowSeqStart ? FLOW_SEQ : FLOW_MAP);
  m_flows.push(flowType);
  Token::TYPE type =</span>
      (flowType == FLOW_SEQ ? Token::FLOW_SEQ_START : Token::FLOW_MAP_START);
<span style = "background-color:#dfd">  m_tokens.push(Token(type, mark));
}</span>

// FlowEnd
<span style = "background-color:#dfd">void Scanner::ScanFlowEnd() {
  if (InBlockContext())</span>
<span style = "background-color:#fdd">    throw ParserException(INPUT.mark(), ErrorMsg::FLOW_END);</span>

  // we might have a solo entry in the flow context
<span style = "background-color:#dfd">  if (InFlowContext()) {
    if (m_flows.top() == FLOW_MAP &amp;&amp; VerifySimpleKey())</span>
<span style = "background-color:#fdd">      m_tokens.push(Token(Token::VALUE, INPUT.mark()));</span>
<span style = "background-color:#dfd">    else if (m_flows.top() == FLOW_SEQ)
      InvalidateSimpleKey();</span>
  }

<span style = "background-color:#dfd">  m_simpleKeyAllowed = false;
  m_canBeJSONFlow = true;</span>

  // eat
<span style = "background-color:#dfd">  Mark mark = INPUT.mark();
  char ch = INPUT.get();</span>

  // check that it matches the start
<span style = "background-color:#dfd">  FLOW_MARKER flowType = (ch == Keys::FlowSeqEnd ? FLOW_SEQ : FLOW_MAP);
  if (m_flows.top() != flowType)</span>
<span style = "background-color:#fdd">    throw ParserException(mark, ErrorMsg::FLOW_END);</span>
<span style = "background-color:#dfd">  m_flows.pop();</span>

<span style = "background-color:#dfd">  Token::TYPE type = (flowType ? Token::FLOW_SEQ_END : Token::FLOW_MAP_END);
  m_tokens.push(Token(type, mark));
}</span>

// FlowEntry
<span style = "background-color:#dfd">void Scanner::ScanFlowEntry() {</span>
  // we might have a solo entry in the flow context
<span style = "background-color:#dfd">  if (InFlowContext()) {
    if (m_flows.top() == FLOW_MAP &amp;&amp; VerifySimpleKey())</span>
<span style = "background-color:#fdd">      m_tokens.push(Token(Token::VALUE, INPUT.mark()));</span>
<span style = "background-color:#dfd">    else if (m_flows.top() == FLOW_SEQ)
      InvalidateSimpleKey();</span>
  }

<span style = "background-color:#dfd">  m_simpleKeyAllowed = true;
  m_canBeJSONFlow = false;</span>

  // eat
<span style = "background-color:#dfd">  Mark mark = INPUT.mark();
  INPUT.eat(1);
  m_tokens.push(Token(Token::FLOW_ENTRY, mark));
}</span>

// BlockEntry
<span style = "background-color:#fdd">void Scanner::ScanBlockEntry() {</span>
  // we better be in the block context!
<span style = "background-color:#fdd">  if (InFlowContext())
    throw ParserException(INPUT.mark(), ErrorMsg::BLOCK_ENTRY);</span>

  // can we put it here?
<span style = "background-color:#fdd">  if (!m_simpleKeyAllowed)
    throw ParserException(INPUT.mark(), ErrorMsg::BLOCK_ENTRY);</span>

<span style = "background-color:#fdd">  PushIndentTo(INPUT.column(), IndentMarker::SEQ);
  m_simpleKeyAllowed = true;
  m_canBeJSONFlow = false;</span>

  // eat
<span style = "background-color:#fdd">  Mark mark = INPUT.mark();
  INPUT.eat(1);
  m_tokens.push(Token(Token::BLOCK_ENTRY, mark));
}</span>

// Key
<span style = "background-color:#fdd">void Scanner::ScanKey() {</span>
  // handle keys differently in the block context (and manage indents)
<span style = "background-color:#fdd">  if (InBlockContext()) {
    if (!m_simpleKeyAllowed)
      throw ParserException(INPUT.mark(), ErrorMsg::MAP_KEY);</span>

<span style = "background-color:#fdd">    PushIndentTo(INPUT.column(), IndentMarker::MAP);</span>
  }

  // can only put a simple key here if we're in block context
<span style = "background-color:#fdd">  m_simpleKeyAllowed = InBlockContext();</span>

  // eat
<span style = "background-color:#fdd">  Mark mark = INPUT.mark();
  INPUT.eat(1);
  m_tokens.push(Token(Token::KEY, mark));
}</span>

// Value
<span style = "background-color:#dfd">void Scanner::ScanValue() {</span>
  // and check that simple key
<span style = "background-color:#dfd">  bool isSimpleKey = VerifySimpleKey();
  m_canBeJSONFlow = false;</span>

<span style = "background-color:#dfd">  if (isSimpleKey) {</span>
    // can't follow a simple key with another simple key (dunno why, though - it
    // seems fine)
<span style = "background-color:#dfd">    m_simpleKeyAllowed = false;
  } else {</span>
    // handle values differently in the block context (and manage indents)
<span style = "background-color:#fdd">    if (InBlockContext()) {
      if (!m_simpleKeyAllowed)
        throw ParserException(INPUT.mark(), ErrorMsg::MAP_VALUE);</span>

<span style = "background-color:#fdd">      PushIndentTo(INPUT.column(), IndentMarker::MAP);</span>
    }

    // can only put a simple key here if we're in block context
<span style = "background-color:#fdd">    m_simpleKeyAllowed = InBlockContext();</span>
  }

  // eat
<span style = "background-color:#dfd">  Mark mark = INPUT.mark();
  INPUT.eat(1);
  m_tokens.push(Token(Token::VALUE, mark));
}</span>

// AnchorOrAlias
<span style = "background-color:#fdd">void Scanner::ScanAnchorOrAlias() {</span>
  bool alias;
<span style = "background-color:#fdd">  std::string name;</span>

  // insert a potential simple key
<span style = "background-color:#fdd">  InsertPotentialSimpleKey();
  m_simpleKeyAllowed = false;
  m_canBeJSONFlow = false;</span>

  // eat the indicator
<span style = "background-color:#fdd">  Mark mark = INPUT.mark();
  char indicator = INPUT.get();
  alias = (indicator == Keys::Alias);</span>

  // now eat the content
<span style = "background-color:#fdd">  while (INPUT &amp;&amp; Exp::Anchor().Matches(INPUT))
    name += INPUT.get();</span>

  // we need to have read SOMETHING!
<span style = "background-color:#fdd">  if (name.empty())
    throw ParserException(INPUT.mark(), alias ? ErrorMsg::ALIAS_NOT_FOUND</span>
                                              : ErrorMsg::ANCHOR_NOT_FOUND);

  // and needs to end correctly
<span style = "background-color:#fdd">  if (INPUT &amp;&amp; !Exp::AnchorEnd().Matches(INPUT))
    throw ParserException(INPUT.mark(), alias ? ErrorMsg::CHAR_IN_ALIAS</span>
                                              : ErrorMsg::CHAR_IN_ANCHOR);

  // and we're done
<span style = "background-color:#fdd">  Token token(alias ? Token::ALIAS : Token::ANCHOR, mark);
  token.value = name;
  m_tokens.push(token);
}</span>

// Tag
<span style = "background-color:#fdd">void Scanner::ScanTag() {</span>
  // insert a potential simple key
<span style = "background-color:#fdd">  InsertPotentialSimpleKey();
  m_simpleKeyAllowed = false;
  m_canBeJSONFlow = false;</span>

<span style = "background-color:#fdd">  Token token(Token::TAG, INPUT.mark());</span>

  // eat the indicator
<span style = "background-color:#fdd">  INPUT.get();</span>

<span style = "background-color:#fdd">  if (INPUT &amp;&amp; INPUT.peek() == Keys::VerbatimTagStart) {
    std::string tag = ScanVerbatimTag(INPUT);</span>

<span style = "background-color:#fdd">    token.value = tag;
    token.data = Tag::VERBATIM;
  } else {</span>
    bool canBeHandle;
<span style = "background-color:#fdd">    token.value = ScanTagHandle(INPUT, canBeHandle);
    if (!canBeHandle &amp;&amp; token.value.empty())
      token.data = Tag::NON_SPECIFIC;
    else if (token.value.empty())
      token.data = Tag::SECONDARY_HANDLE;</span>
    else
<span style = "background-color:#fdd">      token.data = Tag::PRIMARY_HANDLE;</span>

    // is there a suffix?
<span style = "background-color:#fdd">    if (canBeHandle &amp;&amp; INPUT.peek() == Keys::Tag) {</span>
      // eat the indicator
<span style = "background-color:#fdd">      INPUT.get();
      token.params.push_back(ScanTagSuffix(INPUT));
      token.data = Tag::NAMED_HANDLE;</span>
    }
  }

<span style = "background-color:#fdd">  m_tokens.push(token);
}</span>

// PlainScalar
<span style = "background-color:#dfd">void Scanner::ScanPlainScalar() {
  std::string scalar;</span>

  // set up the scanning parameters
<span style = "background-color:#dfd">  ScanScalarParams params;
  params.end =</span>
      (InFlowContext() ? &amp;Exp::ScanScalarEndInFlow() : &amp;Exp::ScanScalarEnd());
<span style = "background-color:#dfd">  params.eatEnd = false;
  params.indent = (InFlowContext() ? 0 : GetTopIndent() + 1);
  params.fold = FOLD_FLOW;
  params.eatLeadingWhitespace = true;
  params.trimTrailingSpaces = true;
  params.chomp = STRIP;
  params.onDocIndicator = BREAK;
  params.onTabInIndentation = THROW;</span>

  // insert a potential simple key
<span style = "background-color:#dfd">  InsertPotentialSimpleKey();</span>

<span style = "background-color:#dfd">  Mark mark = INPUT.mark();
  scalar = ScanScalar(INPUT, params);</span>

  // can have a simple key only if we ended the scalar by starting a new line
<span style = "background-color:#dfd">  m_simpleKeyAllowed = params.leadingSpaces;
  m_canBeJSONFlow = false;</span>

  // finally, check and see if we ended on an illegal character
  // if(Exp::IllegalCharInScalar.Matches(INPUT))
  //	throw ParserException(INPUT.mark(), ErrorMsg::CHAR_IN_SCALAR);

<span style = "background-color:#dfd">  Token token(Token::PLAIN_SCALAR, mark);
  token.value = scalar;
  m_tokens.push(token);
}</span>

// QuotedScalar
<span style = "background-color:#dfd">void Scanner::ScanQuotedScalar() {
  std::string scalar;</span>

  // peek at single or double quote (don't eat because we need to preserve (for
  // the time being) the input position)
<span style = "background-color:#dfd">  char quote = INPUT.peek();
  bool single = (quote == '\'');</span>

  // setup the scanning parameters
<span style = "background-color:#dfd">  ScanScalarParams params;
  RegEx end = (single ? RegEx(quote) &amp; !Exp::EscSingleQuote() : RegEx(quote));
  params.end = &amp;end;
  params.eatEnd = true;
  params.escape = (single ? '\'' : '\\');
  params.indent = 0;
  params.fold = FOLD_FLOW;
  params.eatLeadingWhitespace = true;
  params.trimTrailingSpaces = false;
  params.chomp = CLIP;
  params.onDocIndicator = THROW;</span>

  // insert a potential simple key
<span style = "background-color:#dfd">  InsertPotentialSimpleKey();</span>

<span style = "background-color:#dfd">  Mark mark = INPUT.mark();</span>

  // now eat that opening quote
<span style = "background-color:#dfd">  INPUT.get();</span>

  // and scan
<span style = "background-color:#dfd">  scalar = ScanScalar(INPUT, params);
  m_simpleKeyAllowed = false;
  m_canBeJSONFlow = true;</span>

<span style = "background-color:#dfd">  Token token(Token::NON_PLAIN_SCALAR, mark);
  token.value = scalar;
  m_tokens.push(token);
}</span>

// BlockScalarToken
// . These need a little extra processing beforehand.
// . We need to scan the line where the indicator is (this doesn't count as part
// of the scalar),
//   and then we need to figure out what level of indentation we'll be using.
<span style = "background-color:#fdd">void Scanner::ScanBlockScalar() {
  std::string scalar;</span>

<span style = "background-color:#fdd">  ScanScalarParams params;
  params.indent = 1;
  params.detectIndent = true;</span>

  // eat block indicator ('|' or '&gt;')
<span style = "background-color:#fdd">  Mark mark = INPUT.mark();
  char indicator = INPUT.get();
  params.fold = (indicator == Keys::FoldedScalar ? FOLD_BLOCK : DONT_FOLD);</span>

  // eat chomping/indentation indicators
<span style = "background-color:#fdd">  params.chomp = CLIP;
  int n = Exp::Chomp().Match(INPUT);
  for (int i = 0; i &lt; n; i++) {
    char ch = INPUT.get();
    if (ch == '+')
      params.chomp = KEEP;
    else if (ch == '-')
      params.chomp = STRIP;
    else if (Exp::Digit().Matches(ch)) {
      if (ch == '0')
        throw ParserException(INPUT.mark(), ErrorMsg::ZERO_INDENT_IN_BLOCK);</span>

<span style = "background-color:#fdd">      params.indent = ch - '0';
      params.detectIndent = false;</span>
    }
<span style = "background-color:#fdd">  }</span>

  // now eat whitespace
<span style = "background-color:#fdd">  while (Exp::Blank().Matches(INPUT))
    INPUT.eat(1);</span>

  // and comments to the end of the line
<span style = "background-color:#fdd">  if (Exp::Comment().Matches(INPUT))
    while (INPUT &amp;&amp; !Exp::Break().Matches(INPUT))
      INPUT.eat(1);</span>

  // if it's not a line break, then we ran into a bad character inline
<span style = "background-color:#fdd">  if (INPUT &amp;&amp; !Exp::Break().Matches(INPUT))
    throw ParserException(INPUT.mark(), ErrorMsg::CHAR_IN_BLOCK);</span>

  // set the initial indentation
<span style = "background-color:#fdd">  if (GetTopIndent() &gt;= 0)
    params.indent += GetTopIndent();</span>

<span style = "background-color:#fdd">  params.eatLeadingWhitespace = false;
  params.trimTrailingSpaces = false;
  params.onTabInIndentation = THROW;</span>

<span style = "background-color:#fdd">  scalar = ScanScalar(INPUT, params);</span>

  // simple keys always ok after block scalars (since we're gonna start a new
  // line anyways)
<span style = "background-color:#fdd">  m_simpleKeyAllowed = true;
  m_canBeJSONFlow = false;</span>

<span style = "background-color:#fdd">  Token token(Token::NON_PLAIN_SCALAR, mark);
  token.value = scalar;
  m_tokens.push(token);
}</span>
}  // namespace YAML</pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>